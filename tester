//+------------------------------------------------------------------+
//| tester_v2.mqh |
//| Copyright 2025, HipoAlgoritm - Quantum Division |
//| t.me/hipoalgoritm |
//+------------------------------------------------------------------+
//| نسخه 2.0: بازمهندسی کامل با تمرکز بر پایداری، کیفیت و مقاومت |
//| در برابر اورفیتینگ (Anti-Overfitting) |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, HipoAlgoritm - Quantum Division"
#property link      "t.me/hipoalgoritm"
//+------------------------------------------------------------------+

//--- گروه: تنظیمات بهینه‌سازی سفارشی ---
input group "تنظیمات اصلی بهینه‌سازی";
input int    InpMinTradesPerYear      = 30;  // حداقل تعداد معاملات قابل قبول در یک سال
input double InpMaxAcceptableDrawdown = 20.0; // حداکثر دراوداون قابل قبول به درصد

input group "فیلتر کیفیت معامله (مقابله با اورفیتینگ)";
input double InpMinimumProfitToCostRatio = 3.0; // حداقل نسبت سود خالص هر معامله به هزینه آن
input double InpEstimatedCostPerTrade    = 1.5; // هزینه تخمینی هر معامله (اسپرد+کمیسیون) به پیپ

//--- ساختارهای کمکی ---
// ساختار برای نگهداری نقاط منحنی اکوییتی
struct EquityPoint
{
   datetime time;    // زمان
   double   balance; // موجودی
};

// ساختار برای نگهداری سودهای ماهانه
struct MonthlyProfit
{
   int    year;  // سال
   int    month; // ماه
   double profit; // سود خالص ماه
};

//--- توابع کمکی ریاضی برای محاسبات آماری ---
// محاسبه میانگین یک آرایه
double ArrayMean(const double &arr)
{
   int size = ArraySize(arr);
   if(size == 0) return 0.0;
   return ArraySum(arr) / size;
}

// محاسبه انحراف معیار یک آرایه
double ArrayStdDev(const double &arr)
{
   int size = ArraySize(arr);
   if(size < 2) return 0.0;

   double mean = ArrayMean(arr);
   double sum_sq_diff = 0.0;
   for(int i = 0; i < size; i++)
   {
      sum_sq_diff += pow(arr[i] - mean, 2);
   }
   return sqrt(sum_sq_diff / size);
}


//+------------------------------------------------------------------+
//| [جدید] محاسبه امتیاز پایداری سود ماهانه (Monthly Profit Stability)|
//+------------------------------------------------------------------+
//| هدف: این تابع به شدت استراتژی‌هایی را تشویق می‌کند که سودهای |
//| ماهانه پایدار و قابل اتکایی دارند (مانند یک حقوق ماهانه). |
//| و استراتژی‌های "لاتاری" که با یک معامله بزرگ شانس، کل سود |
//| را کسب می‌کنند، به شدت جریمه می‌کند. |
//+------------------------------------------------------------------+
double CalculateMonthlyProfitStats()
{
   if(!HistorySelect(0, TimeCurrent())) return 0.0;

   uint total_deals = HistoryDealsTotal();
   if(total_deals < 5) return 0.0;

   MonthlyProfit monthly_profits;
   int months_count = 0;

   // حلقه در تمام معاملات برای دسته‌بندی سودها بر اساس ماه
   for(uint i = 0; i < total_deals; i++)
   {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
      {
         datetime deal_time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
         MqlDateTime dt;
         TimeToStruct(deal_time, dt);

         int month_idx = -1;
         // جستجو برای یافتن ماه موجود
         for(int j = 0; j < months_count; j++)
         {
            if(monthly_profits[j].year == dt.year && monthly_profits[j].month == dt.mon)
            {
               month_idx = j;
               break;
            }
         }

         double deal_profit = HistoryDealGetDouble(ticket, DEAL_PROFIT) +
                              HistoryDealGetDouble(ticket, DEAL_COMMISSION) +
                              HistoryDealGetDouble(ticket, DEAL_SWAP);

         if(month_idx == -1) // اگر ماه جدید بود
         {
            ArrayResize(monthly_profits, months_count + 1);
            monthly_profits[months_count].year = dt.year;
            monthly_profits[months_count].month = dt.mon;
            monthly_profits[months_count].profit = deal_profit;
            months_count++;
         }
         else // اگر ماه قبلاً وجود داشت
         {
            monthly_profits[month_idx].profit += deal_profit;
         }
      }
   }

   if(months_count <= 1) return 1.0; // اگر فقط یک ماه فعالیت داشته، پایداری کامل است

   // استخراج سودهای ماهانه در یک آرایه double برای محاسبات آماری
   double profits_array;
   ArrayResize(profits_array, months_count);
   double total_monthly_profit = 0;
   for(int i = 0; i < months_count; i++)
   {
      profits_array[i] = monthly_profits[i].profit;
      total_monthly_profit += profits_array[i];
   }

   // اگر میانگین سود ماهانه منفی باشد، امتیاز صفر است
   if(total_monthly_profit / months_count <= 0) return 0.0;

   // محاسبه انحراف معیار سودهای ماهانه
   double std_dev_monthly_profits = ArrayStdDev(profits_array);

   // فرمول امتیاز: هرچه انحراف معیار (نوسان) کمتر باشد، امتیاز به 1 نزدیک‌تر است
   // از یک مقدار کوچک (مانند 1.0) در مخرج برای جلوگیری از تقسیم بر صفر و نرمال‌سازی استفاده می‌شود
   return 1.0 / (1.0 + std_dev_monthly_profits / fmax(1.0, AccountInfoDouble(ACCOUNT_BALANCE) * 0.01));
}


//+------------------------------------------------------------------+
//| [جدید] محاسبه فاکتور کیفیت معامله (Trade Quality Factor) |
//+------------------------------------------------------------------+
//| هدف: این تابع یک مکانیسم قدرتمند ضد اورفیتینگ است. با فیلتر کردن |
//| معاملاتی که سودشان به قدری ناچیز است که توسط هزینه‌های |
//| واقعی (اسپرد، کمیسیون) از بین می‌رود، از انتخاب استراتژی‌های |
//| غیرواقعی جلوگیری می‌کند. |
//+------------------------------------------------------------------+
double CalculateTradeQualityFactor()
{
   if(!HistorySelect(0, TimeCurrent())) return 0.0;

   uint total_deals = HistoryDealsTotal();
   if(total_deals == 0) return 0.0;

   int high_quality_trades = 0;
   int closed_trades_count = 0;

   double point_value = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double cost_per_pip = InpEstimatedCostPerTrade * point_value;

   for(uint i = 0; i < total_deals; i++)
   {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
      {
         closed_trades_count++;
         double net_profit = HistoryDealGetDouble(ticket, DEAL_PROFIT) +
                             HistoryDealGetDouble(ticket, DEAL_COMMISSION) +
                             HistoryDealGetDouble(ticket, DEAL_SWAP);

         double volume = HistoryDealGetDouble(ticket, DEAL_VOLUME);
         // هزینه تخمینی معامله بر اساس حجم
         double estimated_cost = cost_per_pip * volume / point_value;

         // یک معامله باکیفیت است اگر سود خالص آن حداقل N برابر هزینه تخمینی باشد
         if(net_profit > (estimated_cost * InpMinimumProfitToCostRatio))
         {
            high_quality_trades++;
         }
      }
   }

   if(closed_trades_count == 0) return 0.0;

   // فاکتور کیفیت، درصد معاملات باکیفیت است
   return (double)high_quality_trades / closed_trades_count;
}


//+------------------------------------------------------------------+
//| [جدید] محاسبه نسبت سود به زیان (Profit/Loss Ratio) |
//+------------------------------------------------------------------+
//| هدف: این معیار، میانگین اندازه سودها را با میانگین اندازه ضررها |
//| مقایسه می‌کند. یک نسبت بالا (مثلاً > 1.5) نشان می‌دهد که |
//| استراتژی دارای یک مزیت (Edge) سالم در مدیریت ریسک به ریوارد |
//| است. |
//+------------------------------------------------------------------+
double CalculateProfitLossRatio()
{
   double gross_profit = TesterStatistics(STAT_PROFIT_TRADES);
   double profit_trades_count = TesterStatistics(STAT_PROFIT_TRADES_COUNT);
   double gross_loss = fabs(TesterStatistics(STAT_LOSS_TRADES));
   double loss_trades_count = TesterStatistics(STAT_LOSS_TRADES_COUNT);

   if(profit_trades_count == 0 |

| loss_trades_count == 0 |
| gross_loss == 0)
   {
      // اگر معامله زیان‌ده وجود نداشته باشد، یک مقدار بسیار بالا برمی‌گردانیم
      return 10.0;
   }

   double avg_win = gross_profit / profit_trades_count;
   double avg_loss = gross_loss / loss_trades_count;

   return avg_win / avg_loss;
}


//+------------------------------------------------------------------+
//| [جدید و پیشرفته] محاسبه نسبت سورتینو (Sortino Ratio) |
//+------------------------------------------------------------------+
//| هدف: سورتینو یک نسخه برتر از نسبت شارپ است. این معیار فقط نوسانات|
//| منفی (ریسک نزولی) را جریمه می‌کند و به نوسانات مثبت (رشدهای |
//| سریع) پاداش می‌دهد. این معیار، ریسک را از دیدگاه یک سرمایه‌گذار|
//| واقعی‌تر می‌سنجد. |
//| نکته: محاسبه این معیار نیازمند پردازش منحنی اکوییتی است و کمی |
//| سنگین‌تر از معیارهای استاندارد تستر است، اما ارزش تحلیلی |
//| بسیار بالایی دارد. |
//+------------------------------------------------------------------+
double CalculateSortinoRatio(const EquityPoint &equity_curve)
{
   int points = ArraySize(equity_curve);
   if(points < 5) return 0.0;

   // 1. محاسبه بازده‌های دوره‌ای از روی منحنی اکوییتی
   double returns;
   ArrayResize(returns, points - 1);
   for(int i = 1; i < points; i++)
   {
      if(equity_curve[i-1].balance > 0)
      {
         // استفاده از بازده لگاریتمی برای پایداری ریاضی
         returns[i-1] = log(equity_curve[i].balance / equity_curve[i-1].balance);
      }
      else
      {
         returns[i-1] = 0.0;
      }
   }

   // 2. محاسبه میانگین بازده‌ها
   double average_return = ArrayMean(returns);
   if (average_return <= 0) return 0.0;

   // 3. جداسازی بازده‌های منفی برای محاسبه انحراف معیار نزولی
   double downside_returns;
   ArrayResize(downside_returns, ArraySize(returns));
   int downside_count = 0;
   for(int i = 0; i < ArraySize(returns); i++)
   {
      if(returns[i] < 0)
      {
         downside_returns[downside_count] = returns[i];
         downside_count++;
      }
   }
   if(downside_count < 2) return 10.0; // ریسک نزولی بسیار کم، امتیاز بالا

   ArrayResize(downside_returns, downside_count);

   // 4. محاسبه انحراف معیار نزولی (Downside Deviation)
   double downside_deviation = ArrayStdDev(downside_returns);

   if(downside_deviation == 0) return 10.0; // بدون ریسک نزولی

   // 5. محاسبه نسبت سورتینو
   // در اینجا ریسک فری ریت را صفر در نظر می‌گیریم
   return average_return / downside_deviation;
}


//+------------------------------------------------------------------+
//| [بهینه‌سازی شده] محاسبه معیارهای پیشرفته مبتنی بر منحنی اکوییتی |
//+------------------------------------------------------------------+
//| این تابع اکنون وظیفه ساخت منحنی اکوییتی و سپس فراخوانی توابع |
//| محاسباتی دیگر (R-Squared و Sortino) را بر عهده دارد تا از |
//| محاسبات تکراری جلوگیری شود. |
//+------------------------------------------------------------------+
void ProcessEquityCurve(double &r_squared, double &sortino_ratio)
{
   // مقادیر اولیه
   r_squared = 0.0;
   sortino_ratio = 0.0;

   if(!HistorySelect(0, TimeCurrent())) return;
   uint total_deals = HistoryDealsTotal();
   if(total_deals < 5) return;

   // --- 1. ساخت آرایه منحنی اکوییتی (Equity Curve) ---
   EquityPoint equity_curve;
   ArrayResize(equity_curve, (int)total_deals + 1);

   double final_balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double net_profit = TesterStatistics(STAT_PROFIT);
   double initial_balance = final_balance - net_profit;
   
   equity_curve.time = (HistoryDealsTotal() > 0)? (datetime)HistoryDealGetInteger(0, DEAL_TIME) - 1 : 0;
   equity_curve.balance = initial_balance;

   int equity_points = 1;
   for(uint i = 0; i < total_deals; i++)
   {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
      {
         equity_curve[equity_points].time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
         equity_curve[equity_points].balance = equity_curve[equity_points-1].balance +
                                               HistoryDealGetDouble(ticket, DEAL_PROFIT) +
                                               HistoryDealGetDouble(ticket, DEAL_COMMISSION) +
                                               HistoryDealGetDouble(ticket, DEAL_SWAP);
         equity_points++;
      }
   }
   ArrayResize(equity_curve, equity_points);
   if(equity_points < 3) return;

   // --- 2. محاسبه R-Squared (خطی بودن منحنی) ---
   double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0, sum_y2 = 0;
   for(int i = 0; i < equity_points; i++)
   {
      double x = i + 1.0;
      double y = equity_curve[i].balance;
      sum_x += x; sum_y += y; sum_xy += x * y; sum_x2 += x*x; sum_y2 += y*y;
   }
   double n = equity_points;
   double den_part1 = (n * sum_x2) - (sum_x * sum_x);
   double den_part2 = (n * sum_y2) - (sum_y * sum_y);
   if(den_part1 > 0 && den_part2 > 0)
   {
      double r = ((n * sum_xy) - (sum_x * sum_y)) / sqrt(den_part1 * den_part2);
      r_squared = r * r;
   }

   // --- 3. محاسبه نسبت سورتینو با استفاده از منحنی اکوییتی ساخته شده ---
   sortino_ratio = CalculateSortinoRatio(equity_curve);
}


//+------------------------------------------------------------------+
//| [بدون تغییر] محاسبه ضریب مجازات دراوداون با منحنی کسینوسی |
//+------------------------------------------------------------------+
double CalculateDrawdownPenalty(double max_drawdown_percent)
{
   double penalty_factor = 0.0;
   if (max_drawdown_percent < InpMaxAcceptableDrawdown && InpMaxAcceptableDrawdown > 0)
   {
      // تبدیل درصد دراوداون به یک زاویه بین 0 تا 90 درجه (π/2 رادیان)
      double angle = (max_drawdown_percent / InpMaxAcceptableDrawdown) * (M_PI / 2.0);
      // ضریب مجازات، کسینوس آن زاویه است. هرچه زاویه (دراوداون) بیشتر، کسینوس (امتیاز) کمتر
      penalty_factor = cos(angle);
   }
   // اگر دراوداون بیشتر از حد مجاز باشد، ضریب صفر می‌ماند و کل پاس رد می‌شود
   return penalty_factor;
}


//+------------------------------------------------------------------+
//| تابع اصلی رویداد تستر (OnTester) - نسخه 2.0 |
//| معماری جدید با فرمول امتیازدهی یکپارچه و چندعاملی |
//+------------------------------------------------------------------+
double OnTester()
{
   // --- مرحله 1: دریافت آمارهای استاندارد و اولیه ---
   double total_trades = TesterStatistics(STAT_TRADES);
   double net_profit = TesterStatistics(STAT_PROFIT);
   double profit_factor = TesterStatistics(STAT_PROFIT_FACTOR);
   double recovery_factor = TesterStatistics(STAT_RECOVERY_FACTOR);
   double win_rate_factor = TesterStatistics(STAT_WINRATE) / 100.0;
   double max_dd_percent = TesterStatistics(STAT_BALANCE_DDREL_PERCENT);

   // --- مرحله 2: فیلترهای اولیه برای رد کردن پاس‌های ضعیف ---
   datetime startDate = 0, endDate = 0;
   if(HistoryDealsTotal() > 0)
   {
      startDate = (datetime)HistoryDealGetInteger(0, DEAL_TIME);
      endDate   = (datetime)HistoryDealGetInteger(HistoryDealsTotal() - 1, DEAL_TIME);
   }
   double duration_days = (endDate > startDate)? double(endDate - startDate) / (24.0 * 3600.0) : 1.0;
   double required_min_trades = floor((duration_days / 365.0) * InpMinTradesPerYear);
   if(required_min_trades < 10) required_min_trades = 10;

   if(total_trades < required_min_trades |

| profit_factor < 1.1 |
| net_profit <= 0 |
| recovery_factor < 0.5)
   {
      return 0.0; // رد کردن پاس‌های بی‌کیفیت در ابتدا
   }

   // --- مرحله 3: محاسبه معیارهای پیشرفته و سفارشی ---
   double r_squared = 0.0, sortino_ratio = 0.0;
   ProcessEquityCurve(r_squared, sortino_ratio);

   double monthly_stability_score = CalculateMonthlyProfitStats();
   double trade_quality_factor = CalculateTradeQualityFactor();
   double profit_loss_ratio = CalculateProfitLossRatio();
   double drawdown_penalty = CalculateDrawdownPenalty(max_dd_percent);

   // --- مرحله 4: فرمول نهایی امتیازدهی یکپارچه (Grand Unified Scoring Formula) ---
   // این فرمول به صورت "حاصلضرب فاکتورها" طراحی شده است. این ساختار تضمین می‌کند که
   // ضعف شدید در هر یک از بخش‌های کلیدی (مثلاً پایداری ماهانه صفر یا کیفیت معاملات پایین)
   // کل امتیاز را به شدت کاهش داده و به سمت صفر میل می‌دهد. این یک سیستم "گیت‌های کیفیتی"
   // متوالی است که یک استراتژی باید از همه آنها با موفقیت عبور کند.

   // بخش 1: امتیاز پایه (سود و تعداد معاملات با تعدیل لگاریتمی)
   double base_score = log(1.0 + net_profit) * log(1.0 + total_trades);

   // بخش 2: فاکتورهای اصلی عملکرد و ریسک
   // ترکیبی از معیارهای حیاتی که سلامت و کارایی استراتژی را می‌سنجند.
   // Recovery Factor: توانایی بازیابی از ضرر.
   // Sortino Ratio: بازده تعدیل شده با ریسک نزولی (برتر از شارپ).
   // Profit/Loss Ratio: بزرگی سودها در مقابل ضررها.
   // R-Squared: خطی و پایدار بودن منحنی اکوییتی.
   double core_performance_factor = recovery_factor * fmax(0, sortino_ratio) * profit_loss_ratio * r_squared;

   // بخش 3: فاکتورهای کیفیت، پایداری و واقع‌گرایی
   // این معیارها استراتژی را در برابر اورفیتینگ و شرایط دنیای واقعی مقاوم می‌سنجند.
   double quality_stability_factor = monthly_stability_score * trade_quality_factor * win_rate_factor;
   
   // محاسبه امتیاز نهایی
   double final_score = base_score * core_performance_factor * quality_stability_factor * drawdown_penalty;

   // --- مرحله 5: چاپ نتیجه برای دیباگ و تحلیل ---
   PrintFormat("نتیجه: سود خالص=%.2f, معاملات=%d -> امتیاز نهایی: %.4f", net_profit, (int)total_trades, final_score);
   PrintFormat("   -> جزئیات: PF=%.2f, RF=%.2f, Sortino=%.2f, R²=%.3f, P/L=%.2f", profit_factor, recovery_factor, sortino_ratio, r_squared, profit_loss_ratio);
   PrintFormat("   -> کیفیت: پایداری ماهانه=%.3f, کیفیت معاملات=%.2f, WinRate=%.2f", monthly_stability_score, trade_quality_factor, win_rate_factor);
   PrintFormat("   -> ریسک: دراوداون=%.2f%%, جریمه=%.3f", max_dd_percent, drawdown_penalty);
   
   return final_score;
}
//+------------------------------------------------------------------+
