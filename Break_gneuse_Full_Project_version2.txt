//+------------------------------------------------------------------+
//|                                                   Settings.mqh   |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy       |
//|                                             https://...          |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy"
#property link      "https://..."

// گارد برای جلوگیری از include چندباره فایل
#ifndef SETTINGS_MQH
#define SETTINGS_MQH

//+------------------------------------------------------------------+
//| ENUM برای حالت‌های فیلتر رنج                                   |
//+------------------------------------------------------------------+
enum ENUM_RANGE_FILTER_MODE
  {
   MODE_POINTS, // فاصله سفارشات بر اساس پوینت ثابت
   MODE_ATR     // فاصله سفارشات بر اساس ضریب ATR
  };

//+------------------------------------------------------------------+
//| تنظیمات ورودی                                                  |
//+------------------------------------------------------------------+
// --- تنظیمات کلی ---
input group "====== General Settings ======";
input double InpRiskPercentage = 0.5; // درصد ریسک هر معامله (0.5%)
input bool   InpEnableLogging = true;  // فعال‌سازی لاگینگ برای دیباگ
input int    InpMaxRanges = 100;      // حداکثر تعداد مستطیل‌های پردازش‌شده
input double InpMergeTolerancePercent = 5.0; // درصد تلورانس برای ادغام مستطیل‌ها (5%)

// --- تنظیمات ایچیموکو ---
input group "====== Ichimoku Filter Settings ======";
input bool InpUseIchimokuFilter = true; // فعال‌سازی فیلتر ایچیموکو
input int InpIchimoku_Tenkan = 9;      // دوره تنکان‌سن
input int InpIchimoku_Kijun = 26;      // دوره کیجون‌سن
input int InpIchimoku_Senkou = 52;     // دوره سنکو اسپن B
input int InpMinConsecutiveCandles = 3; // حداقل تعداد کندل‌های متوالی برای رنج
input int InpKijunFlatPeriod = 3;      // دوره بررسی صاف بودن کیجون‌سن

// --- تنظیمات جلسه اول ---
input group "====== Session 1 Settings ======";
input bool   InpS1_IsActive = true;         // فعال بودن جلسه اول
input ENUM_TIMEFRAMES InpS1_TimeFrame = PERIOD_M15; // تایم‌فریم جلسه
input int    InpS1_StartTime_Hour = 21;     // ساعت شروع سشن
input int    InpS1_StartTime_Minute = 0;    // دقیقه شروع سشن
input int    InpS1_EndTime_Hour = 6;        // ساعت پایان سشن
input int    InpS1_EndTime_Minute = 0;      // دقیقه پایان سشن
input int    InpS1_ExpiryTime_Hour = 12;    // ساعت انقضا (پاکسازی)
input int    InpS1_ExpiryTime_Minute = 0;   // دقیقه انقضا
input int    InpS1_MagicNumber = 111101;    // مجیک نامبر جلسه ۱

// --- تنظیمات جلسه دوم ---
input group "====== Session 2 Settings ======";
input bool   InpS2_IsActive = true;
input ENUM_TIMEFRAMES InpS2_TimeFrame = PERIOD_M15;
input int    InpS2_StartTime_Hour = 8;
input int    InpS2_StartTime_Minute = 0;
input int    InpS2_EndTime_Hour = 10;
input int    InpS2_EndTime_Minute = 0;
input int    InpS2_ExpiryTime_Hour = 20;
input int    InpS2_ExpiryTime_Minute = 0;
input int    InpS2_MagicNumber = 222202;

// --- تنظیمات جلسه سوم ---
input group "====== Session 3 Settings ======";
input bool   InpS3_IsActive = true;
input ENUM_TIMEFRAMES InpS3_TimeFrame = PERIOD_M15;
input int    InpS3_StartTime_Hour = 13;
input int    InpS3_StartTime_Minute = 0;
input int    InpS3_EndTime_Hour = 14;
input int    InpS3_EndTime_Minute = 30;
input int    InpS3_ExpiryTime_Hour = 21;
input int    InpS3_ExpiryTime_Minute = 0;
input int    InpS3_MagicNumber = 333303;

// --- تنظیمات جلسه چهارم ---
input group "====== Session 4 Settings ======";
input bool   InpS4_IsActive = false;
input ENUM_TIMEFRAMES InpS4_TimeFrame = PERIOD_M15;
input int    InpS4_StartTime_Hour = 0;
input int    InpS4_StartTime_Minute = 0;
input int    InpS4_EndTime_Hour = 0;
input int    InpS4_EndTime_Minute = 0;
input int    InpS4_ExpiryTime_Hour = 0;
input int    InpS4_ExpiryTime_Minute = 0;
input int    InpS4_MagicNumber = 444404;

// --- تنظیمات رنج ---
input group "====== Range Settings ======";
input ENUM_RANGE_FILTER_MODE InpRangeFilterMode = MODE_ATR; // حالت فاصله‌گذاری سفارشات
input int InpMinRangePoints = 50;           // حداقل اندازه رنج (پوینت)
input int InpMaxRangePoints = 500;          // حداکثر اندازه رنج (پوینت)
input double InpAtrMultiplier_Placement = 0.4; // ضریب ATR برای فاصله سفارشات
input int InRangeATR_Period = 14;           // دوره ATR

// --- تنظیمات فیلتر روند ---
input group "====== Trend Filter Settings ======";
input bool InpTrendFilterIsOn = true;       // فعال‌سازی فیلتر روند
input ENUM_TIMEFRAMES InpTrendEMATimeFrame = PERIOD_H4; // تایم‌فریم EMA
input int InpTrendEMAPeriod = 150;          // دوره EMA
input ENUM_APPLIED_PRICE InpTrendEMAAppliedPrice = PRICE_CLOSE; // قیمت اعمال EMA

// --- تنظیمات مدیریت معامله ---
input group "====== Trade Management Settings ======";
input double InpStopLossAdditionalPercent = 10.0; // درصد اضافی برای استاپ‌لاس
input bool InpEnablePartialClose = true;         // فعال‌سازی خروج پله‌ای
input double InpTakeProfitRatio_Stage1 = 1.5;    // نسبت TP1 به SL
input double InpPartialClosePercentage = 50.0;   // درصد خروج پله‌ای
input int InpTrailingStopATRPeriod = 22;         // دوره ATR برای ترایلینگ
input double InpTrailingStopATRMultiplier = 3.0; // ضریب ATR برای ترایلینگ

#endif // SETTINGS_MQH









//+------------------------------------------------------------------+
//|                                                   hipobreck.mq5  |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy       |
//|                          >> FINAL REVISED VERSION 4.2 <<         |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy"
#property link      "https://..."
#property version   "4.20"
#property strict

#include "Settings.mqh"
#include "SessionTrader.mqh"
#include <Trade\Trade.mqh>

// متغیرهای گلوبال
CSessionTrader g_sessions[4]; // آرایه برای مدیریت چهار جلسه
static datetime last_bar_time[4] = {0}; // زمان آخرین کندل هر جلسه


//+------------------------------------------------------------------+
//| تابع اولیه‌سازی اکسپرت                                          |
//+------------------------------------------------------------------+
int OnInit()
{
   // بررسی نوع حساب برای سازگاری با خروج پله‌ای
   long account_mode = AccountInfoInteger(ACCOUNT_MARGIN_MODE);
   if(account_mode != ACCOUNT_MARGIN_MODE_RETAIL_HEDGING && InpEnableLogging)
      Print("هشدار: حساب netting است - خروج پله‌ای ممکن است کار نکند.");

   // بررسی یکتایی مجیک نامبرها
   int magic_numbers[4] = {InpS1_MagicNumber, InpS2_MagicNumber, InpS3_MagicNumber, InpS4_MagicNumber};
   for(int i = 0; i < 4; i++)
      for(int j = i + 1; j < 4; j++)
         if(magic_numbers[i] == magic_numbers[j] && magic_numbers[i] != 0 && InpEnableLogging)
            Print("خطا: مجیک نامبر " + IntegerToString(magic_numbers[i]) + " تکراری است!");

   // بررسی اعتبار ورودی‌ها
   if(InpRiskPercentage <= 0 || InpMinConsecutiveCandles < 1 || InpKijunFlatPeriod < 1 ||
      InpMinRangePoints < 0 || InpMaxRangePoints < InpMinRangePoints || InpMaxRanges < 1 ||
      InpMergeTolerancePercent < 0 || InpAtrMultiplier_Placement <= 0 || InRangeATR_Period < 1)
   {
      Print("خطا: مقادیر ورودی نامعتبر است!");
      return(INIT_PARAMETERS_INCORRECT);
   }

   // مقداردهی اولیه جلسات
   g_sessions[0].Init(InpS1_IsActive, InpS1_TimeFrame, InpS1_StartTime_Hour, InpS1_StartTime_Minute,
                      InpS1_EndTime_Hour, InpS1_EndTime_Minute, InpS1_ExpiryTime_Hour, InpS1_ExpiryTime_Minute, InpS1_MagicNumber);
   g_sessions[1].Init(InpS2_IsActive, InpS2_TimeFrame, InpS2_StartTime_Hour, InpS2_StartTime_Minute,
                      InpS2_EndTime_Hour, InpS2_EndTime_Minute, InpS2_ExpiryTime_Hour, InpS2_ExpiryTime_Minute, InpS2_MagicNumber);
   g_sessions[2].Init(InpS3_IsActive, InpS3_TimeFrame, InpS3_StartTime_Hour, InpS3_StartTime_Minute,
                      InpS3_EndTime_Hour, InpS3_EndTime_Minute, InpS3_ExpiryTime_Hour, InpS3_ExpiryTime_Minute, InpS3_MagicNumber);
   g_sessions[3].Init(InpS4_IsActive, InpS4_TimeFrame, InpS4_StartTime_Hour, InpS4_StartTime_Minute,
                      InpS4_EndTime_Hour, InpS4_EndTime_Minute, InpS4_ExpiryTime_Hour, InpS4_ExpiryTime_Minute, InpS4_MagicNumber);

   if(InpEnableLogging)
      Print("اکسپرت اولیه‌سازی شد. تعداد جلسات فعال: " + IntegerToString(CountActiveSessions()));

   EventSetTimer(1); // تایمر برای بررسی کندل جدید
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| تابع خاتمه اکسپرت                                              |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   EventKillTimer();
   for(int i = 0; i < 4; i++) g_sessions[i].Deinit();
   if(InpEnableLogging) Print("اکسپرت خاتمه یافت. دلیل: " + IntegerToString(reason));
}

//+------------------------------------------------------------------+
//| تابع تایمر برای بررسی کندل جدید                                |
//+------------------------------------------------------------------+
void OnTimer()
{
   for(int i = 0; i < 4; i++)
   {
      if(!g_sessions[i].IsActive()) continue;
      ENUM_TIMEFRAMES tf = g_sessions[i].GetTimeFrame();
      datetime current_bar_time = (datetime)SeriesInfoInteger(_Symbol, tf, SERIES_LASTBAR_DATE);
      if(current_bar_time > last_bar_time[i])
      {
         g_sessions[i].UpdateOnNewBar();
         last_bar_time[i] = current_bar_time;
         if(InpEnableLogging) Print("کندل جدید برای جلسه " + IntegerToString(g_sessions[i].GetMagicNumber()) + " در " + TimeToString(current_bar_time));
      }
   }

   // نمایش اطلاعات روی چارت
   string comment = "جلسات فعال: " + IntegerToString(CountActiveSessions()) + "\n";
   for(int i = 0; i < 4; i++)
      if(g_sessions[i].IsActive())
         comment += "جلسه " + IntegerToString(g_sessions[i].GetMagicNumber()) + ": فعال\n";
   Comment(comment);
}

//+------------------------------------------------------------------+
//| تابع تیک (خالی برای بهینه‌سازی)                                |
//+------------------------------------------------------------------+
void OnTick()
{
   // خالی برای کاهش بار پردازشی
}

//+------------------------------------------------------------------+
//| تابع مدیریت تراکنش‌های معاملاتی                               |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction &trans, const MqlTradeRequest &request, const MqlTradeResult &result)
{
   if(trans.type == TRADE_TRANSACTION_DEAL_ADD && HistoryDealSelect(trans.deal))
   {
      // اطمینان از اینکه معامله ورودی جدید است.
      if(HistoryDealGetInteger(trans.deal, DEAL_ENTRY) == DEAL_ENTRY_IN)
      {
         long magic = HistoryDealGetInteger(trans.deal, DEAL_MAGIC);
         
         // حلقه while برای اطمینان از حذف تمامی سفارشات پندینگ
         while(OrdersTotal() > 0)
         {
            ulong order_ticket = OrderGetTicket(0); // همیشه اولین سفارش را چک کن
            if(order_ticket > 0 && OrderSelect(order_ticket))
            {
               if(OrderGetInteger(ORDER_MAGIC) == magic)
               {
                  if(trade.OrderDelete(order_ticket))
                  {
                     if(InpEnableLogging) Print("سفارش معکوس با تیکت " + IntegerToString(order_ticket) + " حذف شد (مجیک: " + IntegerToString(magic) + ").");
                     // بعد از حذف، حلقه ادامه پیدا می‌کند و سفارش بعدی در ایندکس 0 قرار می‌گیرد.
                     continue; 
                  }
               }
            }
            break; // در صورتی که سفارش مرتبطی پیدا نشد، از حلقه خارج شو
         }
      }
   }
}


//+------------------------------------------------------------------+
//| تابع شمارش جلسات فعال                                          |
//+------------------------------------------------------------------+
int CountActiveSessions()
{
   int count = 0;
   if(InpS1_IsActive) count++;
   if(InpS2_IsActive) count++;
   if(InpS3_IsActive) count++;
   if(InpS4_IsActive) count++;
   return count;
}












//+------------------------------------------------------------------+
//|                                                 TradeManager.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy       |
//|                          >> FINAL REVISED VERSION 4.2 <<         |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy"
#property link      "https://..."

#ifndef TRADEMANAGER_MQH
#define TRADEMANAGER_MQH

#include "Settings.mqh"
#include "RangeLib.mqh"
#include <Trade\Trade.mqh>

CTrade trade;

//+------------------------------------------------------------------+
//| تابع محاسبه حجم معامله                                         |
//+------------------------------------------------------------------+
double CalculateLotSize(double risk_percent, double stop_loss_pips)
{
   if(stop_loss_pips <= 0)
   {
      if(InpEnableLogging) Print("خطا در محاسبه لات: فاصله استاپ نامعتبر (" + DoubleToString(stop_loss_pips, 2) + ").");
      return 0.0;
   }

   double account_equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double risk_amount = account_equity * (risk_percent / 100.0);

   double tick_value = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tick_size = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);

   if(tick_value <= 0 || tick_size <= 0)
   {
      if(InpEnableLogging) Print("خطا در محاسبه لات: tick_value یا tick_size نامعتبر.");
      return 0.0;
   }

   double value_per_pip = tick_value / tick_size * _Point;
   if(value_per_pip <= 0)
   {
      if(InpEnableLogging) Print("خطا در محاسبه لات: value_per_pip نامعتبر.");
      return 0.0;
   }

   double lot_size = risk_amount / (stop_loss_pips * value_per_pip);
   double min_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double max_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);

   lot_size = MathRound(lot_size / lot_step) * lot_step;
   lot_size = MathMax(min_lot, MathMin(max_lot, lot_size));

   if(InpEnableLogging && lot_size > 0)
      Print("محاسبه لات موفق: حجم=" + DoubleToString(lot_size, 2) +
            ", ریسک=" + DoubleToString(risk_percent, 2) + "%, استاپ=" + DoubleToString(stop_loss_pips, 2));
   return lot_size;
}

//+------------------------------------------------------------------+
//| تابع ثبت سفارشات پندینگ                                        |
//+------------------------------------------------------------------+
void PlacePendingOrders(int session_magic, bool is_trend_on, bool is_uptrend, RangeData &rd, double buy_stop_price, double sell_stop_price, datetime expiry_time)
{
   double sl_additional_pips = rd.rangeSizePips * (InpStopLossAdditionalPercent / 100.0);
   double sl_distance_pips = rd.rangeSizePips + sl_additional_pips;

   double lot_size = CalculateLotSize(InpRiskPercentage, sl_distance_pips);
   if(lot_size <= 0)
   {
      if(InpEnableLogging) Print("خطا در ثبت سفارش: حجم لات نامعتبر (مجیک: " + IntegerToString(session_magic) + ").");
      return;
   }

   double buy_sl = rd.rangeLow - sl_additional_pips * _Point;
   double sell_sl = rd.rangeHigh + sl_additional_pips * _Point;
   double buy_tp = 0.0, sell_tp = 0.0;

   if(!InpEnablePartialClose)
   {
      buy_tp = buy_stop_price + (buy_stop_price - buy_sl) * InpTakeProfitRatio_Stage1;
      sell_tp = sell_stop_price - (sell_sl - sell_stop_price) * InpTakeProfitRatio_Stage1;
   }

   if(!is_trend_on)
   {
      trade.BuyStop(lot_size, buy_stop_price, _Symbol, buy_sl, buy_tp, ORDER_TIME_SPECIFIED, expiry_time, (ulong)session_magic);
      if(InpEnableLogging) Print("سفارش BuyStop ثبت شد: قیمت=" + DoubleToString(buy_stop_price, _Digits) +
                                ", SL=" + DoubleToString(buy_sl, _Digits) + " (مجیک: " + IntegerToString(session_magic) + ").");
      trade.SellStop(lot_size, sell_stop_price, _Symbol, sell_sl, sell_tp, ORDER_TIME_SPECIFIED, expiry_time, (ulong)session_magic);
      if(InpEnableLogging) Print("سفارش SellStop ثبت شد: قیمت=" + DoubleToString(sell_stop_price, _Digits) +
                                ", SL=" + DoubleToString(sell_sl, _Digits) + " (مجیک: " + IntegerToString(session_magic) + ").");
   }
   else
   {
      if(is_uptrend)
      {
         trade.BuyStop(lot_size, buy_stop_price, _Symbol, buy_sl, buy_tp, ORDER_TIME_SPECIFIED, expiry_time, (ulong)session_magic);
         if(InpEnableLogging) Print("سفارش BuyStop (روند صعودی) ثبت شد: قیمت=" + DoubleToString(buy_stop_price, _Digits) +
                                   " (مجیک: " + IntegerToString(session_magic) + ").");
      }
      else
      {
         trade.SellStop(lot_size, sell_stop_price, _Symbol, sell_sl, sell_tp, ORDER_TIME_SPECIFIED, expiry_time, (ulong)session_magic);
         if(InpEnableLogging) Print("سفارش SellStop (روند نزولی) ثبت شد: قیمت=" + DoubleToString(sell_stop_price, _Digits) +
                                   " (مجیک: " + IntegerToString(session_magic) + ").");
      }
   }
}

//+------------------------------------------------------------------+
//| تابع پاکسازی جلسه                                              |
//+------------------------------------------------------------------+
void SessionCleanUp(int session_magic)
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong pos_ticket = PositionGetTicket(i);
      if(pos_ticket > 0 && PositionSelectByTicket(pos_ticket))
      {
         long magic = PositionGetInteger(POSITION_MAGIC);
         if(magic == session_magic)
         {
            trade.PositionClose(pos_ticket);
            if(InpEnableLogging) Print("پوزیشن با تیکت " + IntegerToString(pos_ticket) +
                                      " بسته شد (پاکسازی، مجیک: " + IntegerToString(session_magic) + ").");
         }
      }
   }

   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      ulong ord_ticket = OrderGetTicket(i);
      if(ord_ticket > 0 && OrderSelect(ord_ticket))
      {
         if(OrderGetInteger(ORDER_MAGIC) == session_magic)
         {
            trade.OrderDelete(ord_ticket);
            if(InpEnableLogging) Print("سفارش پندینگ با تیکت " + IntegerToString(ord_ticket) +
                                      " حذف شد (پاکسازی، مجیک: " + IntegerToString(session_magic) + ").");
         }
      }
   }

   ObjectsDeleteAll(0, "Range_" + IntegerToString(session_magic) + "_");
   if(InpEnableLogging) Print("پاکسازی کامل برای جلسه " + IntegerToString(session_magic) + " انجام شد.");
}

#endif // TRADEMANAGER_MQH









//+------------------------------------------------------------------+
//|                                                    RangeLib.mqh  |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy       |
//|                          >> FINAL REVISED VERSION 4.2 <<         |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy"
#property link      "https://..."

#ifndef RANGELIB_MQH
#define RANGELIB_MQH

#include "Settings.mqh"

//+------------------------------------------------------------------+
//| ساختار داده برای محدوده رنج                                   |
//+------------------------------------------------------------------+
struct RangeData
{
   double rangeHigh;      // بالاترین قیمت محدوده
   double rangeLow;       // پایین‌ترین قیمت محدوده
   bool isValid;          // پرچم اعتبار محدوده
   datetime startTime;    // زمان شروع محدوده
   datetime endTime;      // زمان پایان محدوده
   double rangeSizePips;  // اندازه محدوده به پیپ
};

//+------------------------------------------------------------------+
//| تابع ترسیم محدوده روی چارت                                    |
//+------------------------------------------------------------------+
void DrawRangeOnChart(RangeData &rd, int session_magic)
{
   if(!rd.isValid) return;

   string obj_prefix = "Range_" + IntegerToString(session_magic) + "_";
   ObjectsDeleteAll(0, obj_prefix); // حذف مستطیل‌های قبلی
   ObjectCreate(0, obj_prefix + "Rect", OBJ_RECTANGLE, 0, rd.startTime, rd.rangeHigh, rd.endTime, rd.rangeLow);
   ObjectSetInteger(0, obj_prefix + "Rect", OBJPROP_COLOR, clrDarkSlateGray);
   ObjectSetInteger(0, obj_prefix + "Rect", OBJPROP_STYLE, STYLE_SOLID);
   ObjectSetInteger(0, obj_prefix + "Rect", OBJPROP_FILL, true);
   ObjectSetInteger(0, obj_prefix + "Rect", OBJPROP_BACK, true);

   if(InpEnableLogging)
      Print("محدوده روی چارت ترسیم شد: High=" + DoubleToString(rd.rangeHigh, _Digits) +
            ", Low=" + DoubleToString(rd.rangeLow, _Digits) + ", اندازه=" + DoubleToString(rd.rangeSizePips, 2) +
            " (مجیک: " + IntegerToString(session_magic) + ").");
}

//+------------------------------------------------------------------+
//| تابع بررسی صاف بودن کیجون‌سن                                  |
//+------------------------------------------------------------------+
bool IsKijunFlat(int ichimoku_handle, int bar_idx, ENUM_TIMEFRAMES timeframe)
{
   if(bar_idx < InpKijunFlatPeriod)
   {
      if(InpEnableLogging) Print("خطا: تعداد کندل‌ها برای کیجون کافی نیست: " + IntegerToString(bar_idx));
      return false;
   }

   double kijun_buffer[];
   ArrayResize(kijun_buffer, InpKijunFlatPeriod);
   if(CopyBuffer(ichimoku_handle, 1, bar_idx - InpKijunFlatPeriod + 1, InpKijunFlatPeriod, kijun_buffer) != InpKijunFlatPeriod)
   {
      if(InpEnableLogging) Print("خطا در کپی بافر کیجون: ایندکس=" + IntegerToString(bar_idx));
      return false;
   }

   double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0;
   double n = InpKijunFlatPeriod;
   for(int k = 0; k < InpKijunFlatPeriod; k++)
   {
      double x = k + 1.0;
      double y = kijun_buffer[InpKijunFlatPeriod - 1 - k];
      sum_x += x;
      sum_y += y;
      sum_xy += x * y;
      sum_x2 += x * x;
   }

   double denominator = (n * sum_x2 - sum_x * sum_x);
   if(denominator == 0)
   {
      if(InpEnableLogging) Print("خطا در محاسبه شیب کیجون: دنومیناتور صفر.");
      return false;
   }

   double slope = (n * sum_xy - sum_x * sum_y) / denominator;
   bool is_flat = MathAbs(slope) < 0.0001;
   if(InpEnableLogging && is_flat) Print("کیجون صاف تشخیص داده شد: شیب=" + DoubleToString(slope, 6));
   return is_flat;
}

//+------------------------------------------------------------------+
//| تابع بررسی حضور کندل در کومو                                   |
//+------------------------------------------------------------------+
bool IsCandleInKumo(int ichimoku_handle, int bar_idx, ENUM_TIMEFRAMES timeframe)
{
   double senkou_a[1], senkou_b[1];
   if(CopyBuffer(ichimoku_handle, 2, bar_idx, 1, senkou_a) != 1)
   {
      if(InpEnableLogging) Print("خطا در کپی بافر سنکو A: ایندکس=" + IntegerToString(bar_idx));
      return false;
   }
   if(CopyBuffer(ichimoku_handle, 3, bar_idx, 1, senkou_b) != 1)
   {
      if(InpEnableLogging) Print("خطا در کپی بافر سنکو B: ایندکس=" + IntegerToString(bar_idx));
      return false;
   }

   double high = iHigh(_Symbol, timeframe, bar_idx);
   double low = iLow(_Symbol, timeframe, bar_idx);
   double kumo_top = MathMax(senkou_a[0], senkou_b[0]);
   double kumo_bottom = MathMin(senkou_a[0], senkou_b[0]);

   bool in_kumo = (high <= kumo_top && low >= kumo_bottom);
   if(InpEnableLogging && in_kumo)
      Print("کندل داخل کومو: High=" + DoubleToString(high, _Digits) +
            ", Low=" + DoubleToString(low, _Digits) + ", Kumo Top=" + DoubleToString(kumo_top, _Digits) +
            ", Kumo Bottom=" + DoubleToString(kumo_bottom, _Digits));
   return in_kumo;
}

#endif // RANGELIB_MQH



//+------------------------------------------------------------------+
//|                                             SessionTrader.mqh    |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy       |
//|                          >> FINAL REVISED VERSION 4.4 <<         |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy"
#property link      "https://..."

#ifndef SESSIONTRADER_MQH
#define SESSIONTRADER_MQH

#include "Settings.mqh"
#include "RangeLib.mqh"
#include "TradeManager.mqh"

//+------------------------------------------------------------------+
//| کلاس مدیریت جلسه معاملاتی                                      |
//+------------------------------------------------------------------+
class CSessionTrader
{
private:
   bool              m_is_active;
   ulong             m_magic_number; // نوع به ulong
   ENUM_TIMEFRAMES   m_timeframe;
   int               m_start_hour, m_start_min;
   int               m_end_hour, m_end_min;
   int               m_expiry_hour, m_expiry_min;
   int               m_ichimoku_handle;
   int               m_placement_atr_handle;
   int               m_ema_handle;
   int               m_trail_atr_handle;
   bool              m_has_analyzed; // پرچم برای جلوگیری از تحلیل مکرر

public:
   CSessionTrader(void) : m_is_active(false), m_magic_number(0), m_timeframe(PERIOD_M15),
                         m_start_hour(0), m_start_min(0), m_end_hour(0), m_end_min(0),
                         m_expiry_hour(0), m_expiry_min(0), m_ichimoku_handle(INVALID_HANDLE),
                         m_placement_atr_handle(INVALID_HANDLE), m_ema_handle(INVALID_HANDLE),
                         m_trail_atr_handle(INVALID_HANDLE), m_has_analyzed(false) {}

   //+------------------------------------------------------------------+
   //| تابع اولیه‌سازی جلسه                                           |
   //+------------------------------------------------------------------+
   void Init(bool is_active, ENUM_TIMEFRAMES timeframe, int start_h, int start_m, int end_h, int end_m, int expiry_h, int expiry_m, ulong magic)
   {
      m_is_active = is_active;
      m_timeframe = timeframe;
      m_start_hour = start_h;
      m_start_min = start_m;
      m_end_hour = end_h;
      m_end_min = end_m;
      m_expiry_hour = expiry_h;
      m_expiry_min = expiry_m;
      m_magic_number = magic;
      m_has_analyzed = false;

      if(!m_is_active) return;

      if(InpUseIchimokuFilter)
      {
         m_ichimoku_handle = iIchimoku(_Symbol, m_timeframe, InpIchimoku_Tenkan, InpIchimoku_Kijun, InpIchimoku_Senkou);
         if(m_ichimoku_handle == INVALID_HANDLE && InpEnableLogging)
            Print("خطا در ایجاد هندل ایچیموکو برای جلسه " + (string)magic);
      }

      m_placement_atr_handle = iATR(_Symbol, m_timeframe, InRangeATR_Period);
      if(m_placement_atr_handle == INVALID_HANDLE && InpEnableLogging)
         Print("خطا در ایجاد هندل ATR برای جلسه " + (string)magic);

      if(InpTrendFilterIsOn)
      {
         m_ema_handle = iMA(_Symbol, InpTrendEMATimeFrame, InpTrendEMAPeriod, 0, MODE_EMA, InpTrendEMAAppliedPrice);
         if(m_ema_handle == INVALID_HANDLE && InpEnableLogging)
            Print("خطا در ایجاد هندل EMA برای جلسه " + (string)magic);
      }

      m_trail_atr_handle = iATR(_Symbol, m_timeframe, InpTrailingStopATRPeriod);
      if(m_trail_atr_handle == INVALID_HANDLE && InpEnableLogging)
         Print("خطا در ایجاد هندل ATR ترایلینگ برای جلسه " + (string)magic);

      if(InpEnableLogging) Print("جلسه " + (string)magic + " اولیه‌سازی شد.");
   }

   //+------------------------------------------------------------------+
   //| تابع خاتمه جلسه                                               |
   //+------------------------------------------------------------------+
   void Deinit(void)
   {
      if(m_ichimoku_handle != INVALID_HANDLE) IndicatorRelease(m_ichimoku_handle);
      if(m_placement_atr_handle != INVALID_HANDLE) IndicatorRelease(m_placement_atr_handle);
      if(m_ema_handle != INVALID_HANDLE) IndicatorRelease(m_ema_handle);
      if(m_trail_atr_handle != INVALID_HANDLE) IndicatorRelease(m_trail_atr_handle);
      ObjectsDeleteAll(0, "Range_" + (string)m_magic_number + "_");
      if(InpEnableLogging) Print("جلسه " + (string)m_magic_number + " خاتمه یافت.");
   }

   bool IsActive(void) { return m_is_active; }
   ENUM_TIMEFRAMES GetTimeFrame(void) { return m_timeframe; }
   ulong GetMagicNumber(void) { return m_magic_number; }

   //+------------------------------------------------------------------+
   //| تابع بررسی کندل جدید و اجرای منطق                              |
   //+------------------------------------------------------------------+
   void UpdateOnNewBar(void)
   {
      if(!m_is_active) return;

      datetime now = TimeCurrent();
      MqlDateTime now_struct;
      TimeToStruct(now, now_struct);

      // تنظیم زمان‌های شروع، پایان و انقضا با توجه به احتمال روز بعد
      MqlDateTime start_struct = now_struct;
      start_struct.hour = m_start_hour;
      start_struct.min = m_start_min;
      start_struct.sec = 0;
      datetime start_time = StructToTime(start_struct);

      MqlDateTime end_struct = now_struct;
      end_struct.hour = m_end_hour;
      end_struct.min = m_end_min;
      end_struct.sec = 0;
      datetime end_time = StructToTime(end_struct);

      MqlDateTime expiry_struct = now_struct;
      expiry_struct.hour = m_expiry_hour;
      expiry_struct.min = m_expiry_min;
      expiry_struct.sec = 0;
      datetime expiry_time = StructToTime(expiry_struct);

      if(m_start_hour > m_end_hour)
      {
         if(now_struct.hour < m_end_hour) start_time -= 86400;
         else end_time += 86400;
      }
      if(m_end_hour > m_expiry_hour || (m_end_hour == m_expiry_hour && m_end_min > m_expiry_min))
      {
         expiry_time += 86400;
      }

      // بررسی انقضا (پاکسازی)
      if(now >= expiry_time)
      {
         SessionCleanUp(m_magic_number);
         m_has_analyzed = false; // ریست پرچم تحلیل برای سشن بعدی
         if(InpEnableLogging) Print("جلسه " + (string)m_magic_number + " منقضی شد و پاکسازی انجام شد.");
         return;
      }

      // بررسی وجود پوزیشن باز
      for(int i = PositionsTotal() - 1; i >= 0; i--)
      {
         ulong ticket = PositionGetTicket(i);
         if(ticket > 0 && PositionSelectByTicket(ticket))
         {
            if(PositionGetInteger(POSITION_MAGIC) == m_magic_number)
            {
               ManageActiveTrade(ticket);
               if(InpEnableLogging) Print("پوزیشن فعال در جلسه " + (string)m_magic_number + " مدیریت شد.");
               
            }
         }
      }

      // بررسی وجود سفارش پندینگ
      for(int i = OrdersTotal() - 1; i >= 0; i--)
      {
         ulong ticket = OrderGetTicket(i);
         if(ticket > 0 && OrderSelect(ticket))
         {
            if(OrderGetInteger(ORDER_MAGIC) == m_magic_number)
            {
               if(InpEnableLogging) Print("سفارش پندینگ در جلسه " + (string)m_magic_number + " وجود دارد.");
               return;
            }
         }
      }

      // بررسی زمان تحلیل (فقط در اولین کندل بعد از پایان سشن)
      if(now >= end_time && now < end_time + PeriodSeconds(m_timeframe) && !m_has_analyzed)
      {
         AnalyzeAndPlaceOrders(start_time, end_time, expiry_time);
         m_has_analyzed = true; // جلوگیری از تحلیل مکرر
         if(InpEnableLogging) Print("تحلیل برای جلسه " + (string)m_magic_number + " انجام شد.");
      }
   }

private:
   //+------------------------------------------------------------------+
   //| تابع مدیریت پوزیشن‌های باز                                    |
   //+------------------------------------------------------------------+
   bool ManageActiveTrade(ulong ticket)
   {
      if(!PositionSelectByTicket(ticket))
      {
         if(InpEnableLogging) Print("خطا: انتخاب پوزیشن با تیکت " + (string)ticket + " ناموفق.");
         return false;
      }

      long magic = PositionGetInteger(POSITION_MAGIC);
      if(magic != m_magic_number)
      {
         if(InpEnableLogging) Print("خطا: مجیک نامبر پوزیشن " + (string)magic + " با جلسه " + (string)m_magic_number + " مطابقت ندارد.");
         return false;
      }

      double entry_price = PositionGetDouble(POSITION_PRICE_OPEN);
      double current_sl = PositionGetDouble(POSITION_SL);
      double current_tp = PositionGetDouble(POSITION_TP);
      double volume = PositionGetDouble(POSITION_VOLUME);
      ENUM_POSITION_TYPE pos_type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);

      bool is_initial_stage = (pos_type == POSITION_TYPE_BUY) ? (current_sl < entry_price - 2 * _Point) : (current_sl > entry_price + 2 * _Point);
      bool is_breakeven_stage = MathAbs(current_sl - entry_price) < 2 * _Point;

      if(InpEnablePartialClose && is_initial_stage)
      {
         double sl_distance_price = MathAbs(entry_price - current_sl);
         double target_price = (pos_type == POSITION_TYPE_BUY) ? (entry_price + sl_distance_price * InpTakeProfitRatio_Stage1) :
                               (entry_price - sl_distance_price * InpTakeProfitRatio_Stage1);

         double current_price = (pos_type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         if((pos_type == POSITION_TYPE_BUY && current_price >= target_price) ||
            (pos_type == POSITION_TYPE_SELL && current_price <= target_price))
         {
            double lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
            double min_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
            double close_volume = MathRound((volume * InpPartialClosePercentage / 100.0) / lot_step) * lot_step;

            if(volume - close_volume < min_lot && volume > min_lot)
               close_volume = volume;

            if(close_volume >= min_lot && trade.PositionClose(ticket, close_volume))
            {
               if(InpEnableLogging) Print("خروج پله‌ای موفق برای تیکت " + (string)ticket + ": حجم بسته‌شده=" + DoubleToString(close_volume, 2));
               if(PositionSelectByTicket(ticket) && trade.PositionModify(ticket, entry_price, current_tp))
                  if(InpEnableLogging) Print("استاپ‌لاس به نقطه ورود منتقل شد برای تیکت " + (string)ticket);
            }
         }
      }

      bool profitable = (pos_type == POSITION_TYPE_BUY && SymbolInfoDouble(_Symbol, SYMBOL_BID) > entry_price) ||
                       (pos_type == POSITION_TYPE_SELL && SymbolInfoDouble(_Symbol, SYMBOL_ASK) < entry_price);

      if(is_breakeven_stage || profitable)
      {
         double atr_buffer[1];
         if(m_trail_atr_handle != INVALID_HANDLE && CopyBuffer(m_trail_atr_handle, 0, 1, 1, atr_buffer) == 1)
         {
            double atr_value = atr_buffer[0];
            if(atr_value <= 0)
            {
               if(InpEnableLogging) Print("خطا: مقدار ATR نامعتبر برای ترایلینگ استاپ: " + DoubleToString(atr_value, _Digits));
               return false;
            }

            double trail_offset = atr_value * InpTrailingStopATRMultiplier;
            double new_sl = (pos_type == POSITION_TYPE_BUY) ? (SymbolInfoDouble(_Symbol, SYMBOL_BID) - trail_offset) :
                            (SymbolInfoDouble(_Symbol, SYMBOL_ASK) + trail_offset);
            new_sl = NormalizeDouble(new_sl, _Digits); // نرمال‌سازی استاپ‌لاس

            double min_sl_change = _Point * 2; // حداقل تغییر استاپ‌لاس (2 پوینت)
            if((pos_type == POSITION_TYPE_BUY && new_sl > current_sl + min_sl_change) ||
               (pos_type == POSITION_TYPE_SELL && new_sl < current_sl - min_sl_change && new_sl > 0))
            {
               if(trade.PositionModify(ticket, new_sl, current_tp))
                  if(InpEnableLogging) Print("ترایلینگ استاپ به‌روزرسانی شد برای تیکت " + (string)ticket +
                                            ": SL جدید=" + DoubleToString(new_sl, _Digits) +
                                            ", ATR=" + DoubleToString(atr_value, _Digits));
               else
                  if(InpEnableLogging) Print("خطا در به‌روزرسانی ترایلینگ استاپ برای تیکت " + (string)ticket +
                                            ": کد خطا=" + IntegerToString(trade.ResultRetcode()));
            }
         }
         else
         {
            if(InpEnableLogging) Print("خطا در کپی بافر ATR یا هندل نامعتبر برای ترایلینگ استاپ.");
         }
      }
      return true;
   }

   //+------------------------------------------------------------------+
   //| تابع شناسایی محدوده‌های رنج                                   |
   //+------------------------------------------------------------------+
   bool IdentifyRanges(datetime start_time, datetime end_time, RangeData &ranges[])
   {
      ArrayFree(ranges);
      int start_bar_idx = iBarShift(_Symbol, m_timeframe, start_time, true);
      int end_bar_idx = iBarShift(_Symbol, m_timeframe, end_time, true);

      if(start_bar_idx < 0 || end_bar_idx < 0 || start_bar_idx < end_bar_idx)
      {
         if(InpEnableLogging) Print("خطا در ایندکس بارها: شروع=" + IntegerToString(start_bar_idx) +
                                   ", پایان=" + IntegerToString(end_bar_idx));
         return false;
      }

      if(InpUseIchimokuFilter)
      {
         int current_sequence = 0;
         int sequence_start_idx = -1;
         int range_count = 0;

         for(int i = start_bar_idx; i >= end_bar_idx && range_count < InpMaxRanges; i--)
         {
            if(IsCandleInKumo(m_ichimoku_handle, i, m_timeframe) && IsKijunFlat(m_ichimoku_handle, i, m_timeframe))
            {
               if(current_sequence == 0) sequence_start_idx = i;
               current_sequence++;
            }
            else
            {
               if(current_sequence >= InpMinConsecutiveCandles)
               {
                  ArrayResize(ranges, range_count + 1);
                  int high_bar_idx = iHighest(_Symbol, m_timeframe, MODE_HIGH, current_sequence, sequence_start_idx);
                  int low_bar_idx = iLowest(_Symbol, m_timeframe, MODE_LOW, current_sequence, sequence_start_idx);
                  ranges[range_count].rangeHigh = iHigh(_Symbol, m_timeframe, high_bar_idx);
                  ranges[range_count].rangeLow = iLow(_Symbol, m_timeframe, low_bar_idx);
                  ranges[range_count].rangeSizePips = (ranges[range_count].rangeHigh - ranges[range_count].rangeLow) / _Point;
                  ranges[range_count].startTime = iTime(_Symbol, m_timeframe, sequence_start_idx);
                  ranges[range_count].endTime = iTime(_Symbol, m_timeframe, sequence_start_idx - current_sequence + 1);
                  ranges[range_count].isValid = (ranges[range_count].rangeSizePips >= InpMinRangePoints && ranges[range_count].rangeSizePips <= InpMaxRangePoints);
                  range_count++;
                  if(InpEnableLogging)
                     Print("محدوده رنج " + IntegerToString(range_count) + ": High=" + DoubleToString(ranges[range_count-1].rangeHigh, _Digits) +
                           ", Low=" + DoubleToString(ranges[range_count-1].rangeLow, _Digits) + ", اندازه=" + DoubleToString(ranges[range_count-1].rangeSizePips, 2) +
                           ", معتبر=" + (ranges[range_count-1].isValid ? "بله" : "خیر"));
               }
               current_sequence = 0;
            }
         }

         if(current_sequence >= InpMinConsecutiveCandles && range_count < InpMaxRanges)
         {
            ArrayResize(ranges, range_count + 1);
            int high_bar_idx = iHighest(_Symbol, m_timeframe, MODE_HIGH, current_sequence, sequence_start_idx);
            int low_bar_idx = iLowest(_Symbol, m_timeframe, MODE_LOW, current_sequence, sequence_start_idx);
            ranges[range_count].rangeHigh = iHigh(_Symbol, m_timeframe, high_bar_idx);
            ranges[range_count].rangeLow = iLow(_Symbol, m_timeframe, low_bar_idx);
            ranges[range_count].rangeSizePips = (ranges[range_count].rangeHigh - ranges[range_count].rangeLow) / _Point;
            ranges[range_count].startTime = iTime(_Symbol, m_timeframe, sequence_start_idx);
            ranges[range_count].endTime = iTime(_Symbol, m_timeframe, sequence_start_idx - current_sequence + 1);
            ranges[range_count].isValid = (ranges[range_count].rangeSizePips >= InpMinRangePoints && ranges[range_count].rangeSizePips <= InpMaxRangePoints);
            range_count++;
            if(InpEnableLogging)
               Print("محدوده رنج " + IntegerToString(range_count) + ": High=" + DoubleToString(ranges[range_count-1].rangeHigh, _Digits) +
                     ", Low=" + DoubleToString(ranges[range_count-1].rangeLow, _Digits) + ", اندازه=" + DoubleToString(ranges[range_count-1].rangeSizePips, 2) +
                     ", معتبر=" + (ranges[range_count-1].isValid ? "بله" : "خیر"));
         }
         return range_count > 0;
      }
      else
      {
         int bars_to_check = start_bar_idx - end_bar_idx + 1;
         if(bars_to_check <= 0)
         {
            if(InpEnableLogging) Print("خطا: تعداد کندل‌های سشن کافی نیست.");
            return false;
         }

         ArrayResize(ranges, 1);
         int high_bar_idx = iHighest(_Symbol, m_timeframe, MODE_HIGH, bars_to_check, end_bar_idx);
         int low_bar_idx = iLowest(_Symbol, m_timeframe, MODE_LOW, bars_to_check, end_bar_idx);
         ranges[0].rangeHigh = iHigh(_Symbol, m_timeframe, high_bar_idx);
         ranges[0].rangeLow = iLow(_Symbol, m_timeframe, low_bar_idx);
         ranges[0].rangeSizePips = (ranges[0].rangeHigh - ranges[0].rangeLow) / _Point;
         ranges[0].startTime = start_time;
         ranges[0].endTime = end_time;
         ranges[0].isValid = (ranges[0].rangeSizePips >= InpMinRangePoints && ranges[0].rangeSizePips <= InpMaxRangePoints);

         if(InpEnableLogging)
            Print("محدوده رنج (غیرایچیموکو): High=" + DoubleToString(ranges[0].rangeHigh, _Digits) +
                  ", Low=" + DoubleToString(ranges[0].rangeLow, _Digits) + ", اندازه=" + DoubleToString(ranges[0].rangeSizePips, 2) +
                  ", معتبر=" + (ranges[0].isValid ? "بله" : "خیر"));
         return ranges[0].isValid;
      }
   }

   //+------------------------------------------------------------------+
   //| تابع ادغام محدوده‌ها                                          |
   //+------------------------------------------------------------------+
   bool MergeRanges(RangeData &ranges[], RangeData &final_ranges[])
   {
      ArrayFree(final_ranges);
      if(ArraySize(ranges) == 0)
      {
         if(InpEnableLogging) Print("خطا: هیچ محدوده‌ای برای ادغام وجود ندارد.");
         return false;
      }

      ArrayCopy(final_ranges, ranges);
      bool merged = true;
      while(merged)
      {
         merged = false;
         RangeData new_ranges[];
         ArrayFree(new_ranges);
         int temp_size = ArraySize(final_ranges);

         for(int i = 0; i < temp_size; i++)
         {
            if(i == temp_size - 1 || temp_size == 1)
            {
               ArrayResize(new_ranges, ArraySize(new_ranges) + 1);
               new_ranges[ArraySize(new_ranges) - 1] = final_ranges[i];
               continue;
            }

            double range_size_pips = final_ranges[i + 1].rangeSizePips;
            double tolerance_in_pips = range_size_pips * (InpMergeTolerancePercent / 100.0);
            double high_diff_pips = MathAbs(final_ranges[i].rangeHigh - final_ranges[i + 1].rangeHigh) / _Point;
            double low_diff_pips = MathAbs(final_ranges[i].rangeLow - final_ranges[i + 1].rangeLow) / _Point;
            bool can_merge = (high_diff_pips <= tolerance_in_pips) || (low_diff_pips <= tolerance_in_pips);

            if(can_merge)
            {
               RangeData merged_range;
               merged_range.startTime = final_ranges[i].startTime;
               merged_range.endTime = final_ranges[i + 1].endTime;
               int start_idx = iBarShift(_Symbol, m_timeframe, merged_range.startTime, true);
               int end_idx = iBarShift(_Symbol, m_timeframe, merged_range.endTime, true);
               int bars = start_idx - end_idx + 1;
               int high_idx = iHighest(_Symbol, m_timeframe, MODE_HIGH, bars, end_idx);
               int low_idx = iLowest(_Symbol, m_timeframe, MODE_LOW, bars, end_idx);
               merged_range.rangeHigh = iHigh(_Symbol, m_timeframe, high_idx);
               merged_range.rangeLow = iLow(_Symbol, m_timeframe, low_idx);
               merged_range.rangeSizePips = (merged_range.rangeHigh - merged_range.rangeLow) / _Point;
               merged_range.isValid = (merged_range.rangeSizePips >= InpMinRangePoints && merged_range.rangeSizePips <= InpMaxRangePoints);

               ArrayResize(new_ranges, ArraySize(new_ranges) + 1);
               new_ranges[ArraySize(new_ranges) - 1] = merged_range;
               i++;
               merged = true;
               if(InpEnableLogging)
                  Print("ادغام انجام شد: High=" + DoubleToString(merged_range.rangeHigh, _Digits) +
                        ", Low=" + DoubleToString(merged_range.rangeLow, _Digits) + ", اندازه=" + DoubleToString(merged_range.rangeSizePips, 2));
            }
            else
            {
               ArrayResize(new_ranges, ArraySize(new_ranges) + 1);
               new_ranges[ArraySize(new_ranges) - 1] = final_ranges[i];
            }
         }

         ArrayFree(final_ranges);
         ArrayCopy(final_ranges, new_ranges);
      }
      return ArraySize(final_ranges) > 0;
   }

   //+------------------------------------------------------------------+
   //| تابع انتخاب محدوده نهایی                                      |
   //+------------------------------------------------------------------+
   bool SelectFinalRange(RangeData &ranges[], RangeData &final_range)
   {
      final_range.isValid = false;
      if(ArraySize(ranges) == 0)
      {
         if(InpEnableLogging) Print("خطا: هیچ محدوده‌ای برای انتخاب نهایی وجود ندارد.");
         return false;
      }

      double current_bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double current_ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);

      int latest_idx = -1;
      datetime latest_time = 0;

      for(int i = 0; i < ArraySize(ranges); i++)
      {
         if(!ranges[i].isValid) continue;

         double order_distance = 0.0;
         if(InpRangeFilterMode == MODE_POINTS)
            order_distance = InpMinRangePoints * _Point;
         else
         {
            double atr_buffer[1];
            if(CopyBuffer(m_placement_atr_handle, 0, 1, 1, atr_buffer) == 1)
               order_distance = atr_buffer[0] * InpAtrMultiplier_Placement;
            else
            {
               if(InpEnableLogging) Print("خطا در کپی بافر ATR برای محاسبه order_distance.");
               continue;
            }
         }

         double buy_stop_price = ranges[i].rangeHigh + order_distance;
         double sell_stop_price = ranges[i].rangeLow - order_distance;

         if(current_ask < buy_stop_price && current_bid > sell_stop_price)
         {
            if(ranges[i].endTime > latest_time)
            {
               latest_time = ranges[i].endTime;
               latest_idx = i;
            }
         }
      }

      if(latest_idx >= 0)
      {
         final_range = ranges[latest_idx];
         if(InpEnableLogging)
            Print("محدوده نهایی انتخاب شد: High=" + DoubleToString(final_range.rangeHigh, _Digits) +
                  ", Low=" + DoubleToString(final_range.rangeLow, _Digits) + ", اندازه=" + DoubleToString(final_range.rangeSizePips, 2));
         return true;
      }
      if(InpEnableLogging) Print("هیچ محدوده‌ای انتخاب نشد: قیمت از سطوح ورود عبور کرده است.");
      return false;
   }

   //+------------------------------------------------------------------+
   //| تابع تحلیل و ثبت سفارشات                                      |
   //+------------------------------------------------------------------+
   void AnalyzeAndPlaceOrders(datetime start_time, datetime end_time, datetime expiry_time)
   {
      RangeData ranges[];
      if(!IdentifyRanges(start_time, end_time, ranges))
      {
         if(InpEnableLogging) Print("هیچ محدوده معتبری شناسایی نشد برای جلسه " + (string)m_magic_number);
         return;
      }

      RangeData final_ranges[];
      RangeData final_range;
      if(InpUseIchimokuFilter)
      {
         if(!MergeRanges(ranges, final_ranges))
         {
            if(InpEnableLogging) Print("ادغام محدوده‌ها ناموفق بود برای جلسه " + (string)m_magic_number);
            return;
         }
         if(!SelectFinalRange(final_ranges, final_range))
         {
            if(InpEnableLogging) Print("هیچ محدوده نهایی انتخاب نشد برای جلسه " + (string)m_magic_number);
            return;
         }
      }
      else
      {
         final_range = ranges[0];
      }

      if(!final_range.isValid)
      {
         if(InpEnableLogging) Print("محدوده نهایی نامعتبر است برای جلسه " + (string)m_magic_number);
         return;
      }

      DrawRangeOnChart(final_range, m_magic_number);

      bool is_trend_on = InpTrendFilterIsOn;
      bool is_uptrend = false;
      if(is_trend_on)
      {
         double ema_buffer[1];
         if(CopyBuffer(m_ema_handle, 0, 1, 1, ema_buffer) == 1)
         {
            double current_price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
            is_uptrend = current_price > ema_buffer[0];
            if(InpEnableLogging)
               Print("روند: " + (is_uptrend ? "صعودی" : "نزولی") + ", قیمت=" + DoubleToString(current_price, _Digits) +
                     ", EMA=" + DoubleToString(ema_buffer[0], _Digits));
         }
         else
         {
            if(InpEnableLogging) Print("خطا در کپی بافر EMA برای جلسه " + (string)m_magic_number);
            return;
         }
      }

      double order_distance = 0.0;
      if(InpRangeFilterMode == MODE_POINTS)
         order_distance = InpMinRangePoints * _Point;
      else
      {
         double atr_buffer[1];
         if(CopyBuffer(m_placement_atr_handle, 0, 1, 1, atr_buffer) == 1)
            order_distance = atr_buffer[0] * InpAtrMultiplier_Placement;
         else
         {
            if(InpEnableLogging) Print("خطا در کپی بافر ATR برای جلسه " + (string)m_magic_number);
            return;
         }
      }

      double buy_stop_price = final_range.rangeHigh + order_distance;
      double sell_stop_price = final_range.rangeLow - order_distance;

      double current_bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double current_ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      if((is_trend_on && is_uptrend && current_ask >= buy_stop_price) ||
         (is_trend_on && !is_uptrend && current_bid <= sell_stop_price) ||
         (!is_trend_on && (current_ask >= buy_stop_price || current_bid <= sell_stop_price)))
      {
         if(InpEnableLogging) Print("قیمت از سطوح سفارش عبور کرده است. سفارشی ثبت نمی‌شود.");
         return;
      }

      PlacePendingOrders(m_magic_number, is_trend_on, is_uptrend, final_range, buy_stop_price, sell_stop_price, expiry_time);
   }
};

#endif // SESSIONTRADER_MQH








