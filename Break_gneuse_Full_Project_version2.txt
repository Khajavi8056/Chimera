//+------------------------------------------------------------------+
//|                                                   Settings.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                                             https://...        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل برای حفاظت قانونی از کد و جلوگیری از کپی غیرمجاز.
#property link      "https://..." // لینک مرتبط با پروژه یا وبسایت توسعه‌دهنده برای ارجاع و اطلاعات بیشتر.

//--- این گارد برای جلوگیری از include شدن چندباره فایل در پروژه است. این کار کمک می‌کند تا از خطاهای کامپایل مانند redefinition جلوگیری شود و کد تمیز و بدون تکرار بماند.
#ifndef SETTINGS_MQH // چک وجود تعریف گارد برای جلوگیری از کامپایل مجدد.
#define SETTINGS_MQH // تعریف گارد برای جلوگیری از تکرار include.

//+------------------------------------------------------------------+
//| ENUMs for Input Parameters                                       |
//+------------------------------------------------------------------+
//--- enum برای انتخاب حالت فیلتر محدوده. این enum به ما اجازه می‌دهد تا بین دو حالت فیلتر بر اساس پوینت ثابت یا ضریبی از ATR انتخاب کنیم. این یک راه آموزشی برای تعریف گزینه‌های کاربر است و انعطاف‌پذیری سیستم را افزایش می‌دهد. مثلاً در بازارهای با نوسان کم از MODE_POINTS استفاده کنید.
enum ENUM_RANGE_FILTER_MODE // تعریف انوم برای حالت‌های فیلتر محدوده به منظور انتخاب دینامیک یا ثابت.
  {
   MODE_POINTS, // فیلتر بر اساس پوینت ثابت - مناسب برای بازارهای با نوسان ثابت، جایی که اندازه محدوده با مقادیر ثابت کنترل می‌شود و نوسانات کم است.
   MODE_ATR     // فیلتر بر اساس ضریبی از ATR - مناسب برای بازارهای پویا، جایی که فیلتر با نوسانات بازار انطباق پیدا می‌کند و سیستم را adaptive می‌کند.
  };

//+------------------------------------------------------------------+
//| INPUT PARAMETERS                                                 |
//+------------------------------------------------------------------+

// --- تنظیمات کلی پورتفولیو ---
// این بخش تنظیمات کلی مربوط به مدیریت ریسک را شامل می‌شود که برای تمام جلسات مشترک است. این پارامترها پایه مدیریت سرمایه را تشکیل می‌دهند و کمک می‌کنند تا ریسک هر معامله کنترل‌شده باشد. مدیریت ریسک کلیدی برای پایداری سیستم است.
input group "====== Portfolio Global Settings ======"; // گروه ورودی برای تنظیمات کلی پورتفولیو به منظور سازماندهی ورودی‌ها در رابط کاربری MT5.
input double InpRiskPercentage = 0.5; // درصد ریسک از کل سرمایه در هر معامله - این مقدار تعیین می‌کند که چقدر از سرمایه را در هر معامله ریسک کنیم. مثلاً 0.5% به معنای ریسک نیم درصد است و برای جلوگیری از ضررهای بزرگ مفید است. این پارامتر بر اساس equity حساب محاسبه می‌شود.
input bool   InpEnableLogging = true; // آیا لاگینگ فعال باشد؟ - اگر true، سیستم لاگ‌های دقیق و مفید را چاپ می‌کند؛ اگر false، هیچ لاگی چاپ نمی‌شود. این گزینه برای دیباگ و نظارت مفید است بدون اینکه سیستم را سنگین کند.

// --- تنظیمات کلی فیلترها ---
// این بخش برای فیلترهای جهانی مانند ایچیموکو و ATR برای قرارگیری سفارشات استفاده می‌شود. این تنظیمات به سیستم کمک می‌کنند تا محدوده‌های باکیفیت‌تری شناسایی کند و سیگنال‌های کاذب را کاهش دهد.
input group "====== Global Filter Settings ======"; // گروه ورودی برای فیلترهای جهانی به منظور جداسازی تنظیمات فیلتر از دیگر بخش‌ها.
input bool InpUseIchimokuFilter = true; // آیا فیلتر ایچیموکو فعال باشد؟ - اگر true، از فیلتر ایچیموکو برای شناسایی محدوده استفاده می‌شود؛ اگر false، از منطق قدیمی (بالاترین/پایین‌ترین قیمت) استفاده می‌شود. این گزینه انعطاف‌پذیری سیستم را افزایش می‌دهد و برای بازارهای آسیایی مفید است.
input int InpIchimoku_Tenkan = 9; // دوره تنکان‌سن برای ایچیموکو - دوره کوتاه برای محاسبه میانگین بالا/پایین ۹ کندل اخیر، که حساسیت به تغییرات کوتاه‌مدت را نشان می‌دهد. این پارامتر برای تنظیم حساسیت کوتاه‌مدت استفاده می‌شود.
input int InpIchimoku_Kijun = 26; // دوره کیجون‌سن برای ایچیموکو - دوره متوسط برای محاسبه میانگین بالا/پایین ۲۶ کندل، که روند میان‌مدت را نشان می‌دهد. این خط برای چک تعادل بازار کلیدی است.
input int InpIchimoku_Senkou = 52; // دوره سنکو اسپن B برای ایچیموکو - دوره بلند برای ابر کومو، که میانگین بالا/پایین ۵۲ کندل را محاسبه می‌کند و آینده را پیش‌بینی می‌کند. این پارامتر برای فیلتر روند بلندمدت مفید است.
input int InpMinConsecutiveCandles = 3; // حداقل تعداد کندل‌های متوالی برای تعادل بازار در ایچیموکو - برای تأیید پایداری تعادل و جلوگیری از سیگنال‌های کاذب. این مقدار باید بر اساس بک‌تست تنظیم شود تا تعادل واقعی بازار را نشان دهد.
input double InpAtrMultiplier_Placement = 0.4; // ضریب ATR برای بافر قرارگیری سفارشات - برای تنظیم فاصله دینامیک از لبه‌های محدوده، که بر اساس نوسان بازار تنظیم می‌شود و از فعال شدن زودرس سفارشات جلوگیری می‌کند. این پارامتر سیستم را adaptive می‌کند.
input int InpKijunFlatPeriod = 3; // دوره چک صاف بودن کیجون‌سن - تعداد کندل‌های اخیر برای محاسبه شیب رگرسیون (مثلاً ۳ برای سیگنال‌های بیشتر، ۲۰ برای سخت‌گیرانه‌تر و سیگنال‌های باکیفیت‌تر). این پارامتر برای بهینه‌سازی در بک‌تست مفید است و حساسیت فیلتر را کنترل می‌کند.

// --- پارامترهای جلسه اول (Session 1) ---
// هر جلسه دارای پارامترهای مستقل برای فعال/غیرفعال کردن، زمان شروع، پایان و انقضا است. مجیک نامبر برای شناسایی معاملات منحصر به فرد است. این ساختار آموزشی برای مدیریت چند جلسه است و اجازه می‌دهد هر جلسه مانند یک استراتژی مستقل عمل کند و سیستم را scalable کند.
input group"====== Session 1 Settings ======"; // گروه ورودی برای جلسه اول به منظور سازماندهی تنظیمات هر جلسه جداگانه.
input bool   InpS1_IsActive = true;         // آیا جلسه اول فعال باشد؟ - اگر false باشد، این جلسه نادیده گرفته می‌شود و هیچ تحلیلی انجام نمی‌شود. این گزینه برای تست جلسات خاص مفید است.
input ENUM_TIMEFRAMES InpS1_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۱ - مثلاً M15 برای کندل‌های ۱۵ دقیقه‌ای، که دقت و تعداد سیگنال‌ها را تعدیل می‌کند. انتخاب تایم فریم بالاتر سیگنال‌های کمتر اما باکیفیت‌تر می‌دهد.
input int    InpS1_StartTime_Hour = 0;      // ساعت شروع تحلیل جلسه ۱ - زمان شروع بازه برای شناسایی محدوده (ساعت از 0 تا 23). این پارامتر بازه زمانی جلسه را تعریف می‌کند.
input int    InpS1_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۱ (دقیقه از 0 تا 59). دقت دقیقه برای همگام‌سازی با بازار ضروری است.
input int    InpS1_EndTime_Hour = 6;        // ساعت پایان تحلیل جلسه ۱ - زمان پایان بازه برای شناسایی High/Low. این زمان باید بعد از شروع باشد.
input int    InpS1_EndTime_Minute = 0;      // دقیقه پایان تحلیل جلسه ۱. تحلیل دقیقاً در این دقیقه انجام می‌شود تا کندل کامل شود.
input int    InpS1_ExpiryTime_Hour = 12;    // ساعت انقضای جلسه ۱ - زمانی که تمام معاملات و سفارشات این جلسه بسته/حذف می‌شوند. این برای جلوگیری از نگه داشتن سفارشات طولانی مفید است.
input int    InpS1_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۱. انقضا برای مدیریت ریسک زمانی استفاده می‌شود.
const int    S1_MagicNumber = 111101;       // مجیک نامبر اختصاصی جلسه ۱ - برای تمایز معاملات این جلسه از دیگران، باید منحصر به فرد باشد و از تداخل جلوگیری کند. مجیک نامبر برای فیلتر معاملات در OnTick و OnTradeTransaction کلیدی است.

// --- پارامترهای جلسه دوم (Session 2) ---
// مشابه جلسه اول، اما برای جلسه دوم. این تکرار برای انعطاف‌پذیری در تنظیم جلسات مختلف (مثل آسیایی، اروپایی) است.
input group "====== Session 2 Settings ======"; // گروه ورودی برای جلسه دوم.
input bool   InpS2_IsActive = true;         // آیا جلسه دوم فعال باشد؟ اگر false، جلسه نادیده گرفته می‌شود.
input ENUM_TIMEFRAMES InpS2_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۲.
input int    InpS2_StartTime_Hour = 8;      // ساعت شروع تحلیل جلسه ۲.
input int    InpS2_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۲.
input int    InpS2_EndTime_Hour = 10;       // ساعت پایان تحلیل جلسه ۲.
input int    InpS2_EndTime_Minute = 0;      // دقیقه پایان تحلیل جلسه ۲.
input int    InpS2_ExpiryTime_Hour = 20;    // ساعت انقضای جلسه ۲.
input int    InpS2_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۲.
const int    S2_MagicNumber = 222202;       // مجیک نامبر اختصاصی جلسه ۲.

// --- پارامترهای جلسه سوم (Session 3) ---
// مشابه قبلی‌ها، برای جلسه سوم.
input group "====== Session 3 Settings ======"; // گروه ورودی برای جلسه سوم.
input bool   InpS3_IsActive = true;         // آیا جلسه سوم فعال باشد؟
input ENUM_TIMEFRAMES InpS3_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۳.
input int    InpS3_StartTime_Hour = 13;     // ساعت شروع تحلیل جلسه ۳.
input int    InpS3_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۳.
input int    InpS3_EndTime_Hour = 14;       // ساعت پایان تحلیل جلسه ۳.
input int    InpS3_EndTime_Minute = 30;     // دقیقه پایان تحلیل جلسه ۳.
input int    InpS3_ExpiryTime_Hour = 21;    // ساعت انقضای جلسه ۳.
input int    InpS3_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۳.
const int    S3_MagicNumber = 333303;       // مجیک نامبر اختصاصی جلسه ۳.

// --- پارامترهای جلسه چهارم (Session 4) ---
// جلسه چهارم با پیش‌فرض غیرفعال برای گسترش آینده.
input group "====== Session 4 Settings ======"; // گروه ورودی برای جلسه چهارم.
input bool   InpS4_IsActive = false;        // آیا جلسه چهارم فعال باشد؟ - پیش‌فرض false برای غیرفعال بودن تا کاربر فعال کند.
input ENUM_TIMEFRAMES InpS4_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۴.
input int    InpS4_StartTime_Hour = 0;      // ساعت شروع تحلیل جلسه ۴.
input int    InpS4_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۴.
input int    InpS4_EndTime_Hour = 0;        // ساعت پایان تحلیل جلسه ۴.
input int    InpS4_EndTime_Minute = 0;      // دقیقه پایان تحلیل جلسه ۴.
input int    InpS4_ExpiryTime_Hour = 0;     // ساعت انقضای جلسه ۴.
input int    InpS4_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۴.
const int    S4_MagicNumber = 444404;       // مجیک نامبر اختصاصی جلسه ۴.

// --- پارامترهای تعریف محدوده (مشترک برای همه جلسات) ---
// این بخش برای شناسایی و اعتبارسنجی محدوده استفاده می‌شود و برای تمام جلسات مشترک است. این پارامترها پایه استراتژی شکست را تشکیل می‌دهند و فیلترهای اندازه محدوده را کنترل می‌کنند.
input group "====== Range Definition ======"; // گروه ورودی برای تعریف محدوده.
input ENUM_RANGE_FILTER_MODE InpRangeFilterMode        = MODE_ATR;     // حالت فیلتر اندازه محدوده - انتخاب بین POINTS یا ATR برای انعطاف‌پذیری. MODE_ATR برای بازارهای volatile پیشنهاد می‌شود.
input int                    InpMinRangePoints         = 50;           // حداقل اندازه رنج به پوینت (در حالت Points) - اگر کمتر باشد، نامعتبر، برای جلوگیری از رنج‌های کوچک و نوسانی که سیگنال کاذب می‌دهند.
input int                    InpMaxRangePoints         = 500;          // حداکثر اندازه رنج به پوینت (در حالت Points) - اگر بیشتر باشد، نامعتبر، برای جلوگیری از رنج‌های خیلی بزرگ که شکست واقعی ندارند.
input ENUM_TIMEFRAMES        InRangeATR_TimeFrame      = PERIOD_D1;    // تایم فریم محاسبه ATR برای اعتبارسنجی - مثلاً D1 برای روزانه، برای اندازه‌گیری نوسان کلی بازار و فیلتر بهتر.
input int                    InRangeATR_Period         = 14;           // دوره ATR برای اعتبارسنجی - دوره استاندارد ۱۴، برای محاسبه میانگین نوسان. این پارامتر بر اساس Wilder تعریف شده.
input double                 InRangeATR_MinMultiplier  = 0.2;          // ضریب حداقل ATR برای اعتبارسنجی - اندازه رنج حداقل این ضریب ATR باشد، برای فیلتر رنج‌های کوچک نسبت به نوسان و جلوگیری از over-trading.
input double                 InRangeATR_MaxMultiplier  = 1.2;          // ضریب حداکثر ATR برای اعتبارسنجی - اندازه رنج حداکثر این ضریب ATR باشد، برای فیلتر رنج‌های بزرگ که ممکن است روند باشند.

// --- پارامترهای فیلتر روند (مشترک برای همه جلسات) ---
// فیلتر روند برای تعیین جهت معامله بر اساس EMA. این بخش آموزشی برای اضافه کردن فیلتر روند به استراتژی است و معاملات خلاف روند را کاهش می‌دهد.
input group "====== Trend Filter ======"; // گروه ورودی برای فیلتر روند.
input bool               InpTrendFilterIsOn    = true;         // آیا فیلتر روند فعال باشد؟ - اگر true، فقط در جهت روند معامله می‌کند، برای کاهش معاملات خلاف روند و افزایش win rate.
input ENUM_TIMEFRAMES    InpTrendEMATimeFrame  = PERIOD_H4;    // تایم فریم محاسبه EMA - مثلاً H4 برای ۴ ساعته، تایم فریم بالاتر برای روندهای بلندمدت و جلوگیری از نویز کوتاه‌مدت.
input int                InpTrendEMAPeriod     = 150;          // دوره EMA - دوره طولانی برای روندهای بلندمدت، مثلاً ۱۵۰ برای EMA آهسته که روند کلی بازار را نشان می‌دهد.
input ENUM_APPLIED_PRICE InpTrendEMAAppliedPrice = PRICE_CLOSE;  // قیمت اعمالی EMA - معمولاً CLOSE برای قیمت بسته شدن کندل، اما می‌توان به PRICE_MEDIAN تغییر داد برای robustness.

// --- پارامترهای مدیریت معامله و ریسک (مشترک) ---
// این بخش برای مدیریت سفارشات، استاپ لاس، تیک پروفیت و ترلینگ. این پارامترها پایه مدیریت معامله را تشکیل می‌دهند و ریسک را کنترل می‌کنند.
// توجه: InpFixedTakeProfitRatio حذف شده و از InpTakeProfitRatio_Stage1 برای حالت ثابت استفاده می‌شود تا ساده‌سازی شود و کد تمیزتر باشد.
// InpOrderBufferPoints حذف شده و از ATR دینامیک استفاده می‌شود برای adaptive بودن.
input group "====== Trade & Risk Management ======"; // گروه ورودی برای مدیریت معامله و ریسک.
input double InpStopLossAdditionalPercent   = 10.0;         // درصد اضافه به اندازه رنج برای SL اولیه - مثلاً ۱۰% بیشتر از اندازه رنج برای فضای بیشتر و جلوگیری از stop hunt.
input bool   InpEnablePartialClose          = true;         // آیا خروج پله‌ای فعال باشد؟ - اگر false، از تارگت ثابت استفاده می‌شود، برای استراتژی‌های ساده‌تر. این گزینه برای scale out مفید است.
input double InpTakeProfitRatio_Stage1      = 1.5;          // نسبت سود به ضرر برای بستن بخش اول یا TP ثابت - مثلاً ۱.۵ برابر فاصله SL، برای خروج اولیه یا ثابت و افزایش profitability.
input double InpPartialClosePercentage      = 50.0;         // درصد حجمی که در مرحله اول بسته می‌شود - مثلاً ۵۰% برای تقسیم معامله و حفظ بخشی برای روند طولانی.
input ENUM_TIMEFRAMES InpTrailingStopATRTimeFrame = PERIOD_D1;    // تایم فریم ATR برای حد ضرر متحرک - مثلاً D1 برای نوسان روزانه و جلوگیری از نویز کوتاه‌مدت.
input int             InpTrailingStopATRPeriod      = 22;           // دوره ATR برای حد ضرر متحرک - دوره متفاوت برای ترلینگ، مثلاً ۲۲ برای حساسیت کمتر و اجازه دادن به روند.
input double          InpTrailingStopATRMultiplier  = 3.0;          // ضریب ATR برای فاصله حد ضرر متحرک - مثلاً ۳ برابر ATR برای فضای کافی و جلوگیری از خروج زودرس.

//--- گروه: تنظیمات بهینه‌سازی سفارشی ---
// این گروه برای تنظیمات سفارشی در Strategy Tester استفاده می‌شود و حداقل معاملات و حداکثر drawdown را کنترل می‌کند.
input group "  تنظیمات بهینه‌سازی سفارشی"; // گروه بهینه‌سازی برای پارامترهای OnTester.
input int InpMinTradesPerYear = 30; // حداقل تعداد معاملات قابل قبول در یک سال - برای فیلتر پارامترهای با معاملات کم و جلوگیری از over-fitting.
input int InpMaxAcceptableDrawdown = 15; // حداکثر دراوداون قابل قبول - برای جریمه drawdown بالا در امتیازدهی سفارشی.

#endif //SETTINGS_MQH





//+------------------------------------------------------------------+
//|                                                   hipobreck.mq5 |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy      |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
// توضیح: فایل اصلی اکسپرت برای سیستم معاملاتی. مدیریت چندین جلسه معاملاتی،
//        رویدادهای تیک، تراکنش‌های معاملاتی و بهینه‌سازی سفارشی را انجام می‌دهد. این فایل نقطه ورود سیستم است و تمام ماژول‌ها را هماهنگ می‌کند.

#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // کپی‌رایت برای حفاظت قانونی.
#property link      "https://..." // لینک پروژه برای ارجاع.
#property version   "3.00" // نسخه فعلی اکسپرت برای ردیابی تغییرات.
#property strict // فعال‌سازی بررسی سخت‌گیرانه برای جلوگیری از خطاهای کامپایل و ران‌تایم.

// شامل کردن فایل‌های لازم برای ساختار ماژولار سیستم.
#include "Settings.mqh" // تنظیمات ورودی کاربر.
#include "SessionTrader.mqh" // کلاس مدیریت جلسات.
#include <Trade\Trade.mqh> // کتابخانه استاندارد برای عملیات معاملاتی.

//+------------------------------------------------------------------+
//| متغیرهای سراسری                                                |
//+------------------------------------------------------------------+
// توضیح: آرایه‌ای از اشیاء CSessionTrader برای مدیریت چهار جلسه معاملاتی مستقل. این آرایه اجازه می‌دهد تا جلسات مختلف را به طور همزمان مدیریت کنیم بدون تداخل.
CSessionTrader g_sessions[4]; // آرایه جهانی برای جلسات.

//+------------------------------------------------------------------+
//| تابع اولیه‌سازی اکسپرت                                          |
//+------------------------------------------------------------------+
// هدف: راه‌اندازی اکسپرت، تنظیم جلسه‌های معاملاتی و تایمر برای به‌روزرسانی‌های دوره‌ای. این تابع در شروع اکسپرت فراخوانی می‌شود و منابع را تخصیص می‌دهد.
int OnInit()
  {
   // چک نوع حساب برای سازگاری: اگر netting باشد، ممکن است partial close کار نکند.
   long account_mode = AccountInfoInteger(ACCOUNT_MARGIN_MODE); // گرفتن mode حساب.
   if(account_mode != ACCOUNT_MARGIN_MODE_RETAIL_HEDGING) // اگر hedging نباشد.
     {
      if(InpEnableLogging) Print("هشدار: حساب netting است - partial close ممکن است کار نکند. پیشنهاد: حساب hedging استفاده کنید."); // لاگ هشدار.
     }

   // مقداردهی اولیه هر جلسه با پارامترهای تعریف‌شده توسط کاربر. این کار جلسات را مستقل نگه می‌دارد.
   g_sessions[0].Init(InpS1_IsActive, InpS1_TimeFrame, InpS1_StartTime_Hour, InpS1_StartTime_Minute,
                      InpS1_EndTime_Hour, InpS1_EndTime_Minute, InpS1_ExpiryTime_Hour, InpS1_ExpiryTime_Minute, S1_MagicNumber);
   g_sessions[1].Init(InpS2_IsActive, InpS2_TimeFrame, InpS2_StartTime_Hour, InpS2_StartTime_Minute,
                      InpS2_EndTime_Hour, InpS2_EndTime_Minute, InpS2_ExpiryTime_Hour, InpS2_ExpiryTime_Minute, S2_MagicNumber);
   g_sessions[2].Init(InpS3_IsActive, InpS3_TimeFrame, InpS3_StartTime_Hour, InpS3_StartTime_Minute,
                      InpS3_EndTime_Hour, InpS3_EndTime_Minute, InpS3_ExpiryTime_Hour, InpS3_ExpiryTime_Minute, S3_MagicNumber);
   g_sessions[3].Init(InpS4_IsActive, InpS4_TimeFrame, InpS4_StartTime_Hour, InpS4_StartTime_Minute,
                      InpS4_EndTime_Hour, InpS4_EndTime_Minute, InpS4_ExpiryTime_Hour, InpS4_ExpiryTime_Minute, S4_MagicNumber);

   // لاگ موفقیت اولیه‌سازی.
   if(InpEnableLogging) Print("اکسپرت اولیه‌سازی شد. تعداد جلسات فعال: " + IntegerToString(CountActiveSessions())); // لاگ تعداد جلسات فعال برای دیباگ.

   EventSetTimer(60); // تنظیم تایمر برای به‌روزرسانی هر 60 ثانیه، کاهش بار OnTick و بهینه‌سازی عملکرد.

   return(INIT_SUCCEEDED); // بازگشت موفقیت برای ادامه اجرا.
  }

//+------------------------------------------------------------------+
//| تابع خاتمه اکسپرت                                              |
//+------------------------------------------------------------------+
// هدف: آزادسازی منابع هنگام حذف اکسپرت. این تابع در پایان کار اکسپرت فراخوانی می‌شود تا حافظه آزاد شود و سیستم تمیز بماند.
void OnDeinit(const int reason)
  {
   EventKillTimer(); // متوقف کردن تایمر برای جلوگیری از فراخوانی‌های اضافی.

   for(int i = 0; i < 4; i++) g_sessions[i].Deinit(); // خاتمه هر جلسه و آزادسازی هندل‌ها و اشیاء.

   if(InpEnableLogging) Print("اکسپرت خاتمه یافت. دلیل: " + IntegerToString(reason)); // لاگ دلیل خاتمه برای دیباگ.
  }

//+------------------------------------------------------------------+
//| تابع تایمر                                                     |
//+------------------------------------------------------------------+
// هدف: هر 60 ثانیه فراخوانی می‌شود برای به‌روزرسانی تحلیل و پاکسازی جلسات. این روش بهینه‌تر از OnTick برای عملیات دوره‌ای است.
void OnTimer()
  {
   for(int i = 0; i < 4; i++) g_sessions[i].OnTimerUpdate(); // به‌روزرسانی هر جلسه به طور مستقل.
  }

//+------------------------------------------------------------------+
//| تابع تیک                                                       |
//+------------------------------------------------------------------+
// هدف: مدیریت تیک‌های جدید برای به‌روزرسانی پوزیشن‌های فعال (خروج پله‌ای و حد ضرر متحرک). این تابع در هر تیک بازار فراخوانی می‌شود.
void OnTick()
  {
   for(int i = PositionsTotal() - 1; i >= 0; i--) // حلقه روی تمام پوزیشن‌های باز از آخر به اول برای جلوگیری از مشکلات ایندکس.
     {
      ulong ticket = PositionGetTicket(i); // دریافت تیکت پوزیشن به‌صورت ulong برای سازگاری با MQL5 جدید.
      if(ticket > 0 && PositionSelectByTicket(ticket)) // اطمینان از انتخاب پوزیشن و اعتبار تیکت.
        {
         long magic = PositionGetInteger(POSITION_MAGIC); // دریافت مجیک نامبر پوزیشن برای شناسایی جلسه.
         bool managed = false; // پرچم برای چک مدیریت.

         for(int j = 0; j < 4; j++) // حلقه روی جلسات برای پیدا کردن جلسه مربوطه.
           {
            if(g_sessions[j].GetMagicNumber() == magic) // اگر مجیک مطابقت داشت.
              {
               managed = g_sessions[j].ManageActiveTrade(ticket); // فراخوانی تابع مدیریت پوزیشن با تیکت ulong.
               if(InpEnableLogging && managed) Print("پوزیشن با تیکت " + IntegerToString(ticket) + " مدیریت شد (مجیک: " + IntegerToString(magic) + ")."); // لاگ موفقیت مدیریت.
               break; // خروج از حلقه جلسات پس از پیدا کردن.
              }
           }
         // نکته: قبلاً break اینجا بود که باعث می‌شد فقط یک پوزیشن مدیریت شود - حذف شده تا همه پوزیشن‌ها چک شوند.
        }
     }
  }

//+------------------------------------------------------------------+
//| تابع تراکنش معاملاتی                                           |
//+------------------------------------------------------------------+
// هدف: مدیریت منطق OCO (یکی دیگری را لغو می‌کند) با حذف سفارش معکوس هنگام باز شدن معامله. این تابع برای هندلینگ معاملات جدید فراخوانی می‌شود.
void OnTradeTransaction(const MqlTradeTransaction &trans, const MqlTradeRequest &request, const MqlTradeResult &result)
  {
   if(trans.type == TRADE_TRANSACTION_DEAL_ADD) // اگر تراکنش اضافه deal باشد.
     {
      if(HistoryDealSelect(trans.deal)) // انتخاب deal از تاریخچه.
        {
         if(HistoryDealGetInteger(trans.deal, DEAL_ENTRY) == DEAL_ENTRY_IN) // اگر ورود معامله باشد.
           {
            long magic = HistoryDealGetInteger(trans.deal, DEAL_MAGIC); // مجیک deal.
            for(int i = OrdersTotal() - 1; i >= 0; i--) // حلقه روی سفارشات پندینگ.
              {
               ulong order_ticket = OrderGetTicket(i); // تیکت سفارش.
               if(order_ticket > 0 && OrderSelect(order_ticket)) // اگر معتبر.
                 {
                  if(OrderGetInteger(ORDER_MAGIC) == magic) // اگر مجیک مطابقت داشت.
                    {
                     trade.OrderDelete(order_ticket); // حذف سفارش معکوس برای OCO.
                     if(InpEnableLogging) Print("سفارش معکوس با تیکت " + IntegerToString(order_ticket) + " حذف شد (مجیک: " + IntegerToString(magic) + ")."); // لاگ حذف.
                    }
                 }
              }
           }
        }
     }
  }

//+------------------------------------------------------------------+
//| تابع بهینه‌سازی سفارشی (OnTester)                              |
//+------------------------------------------------------------------+
// هدف: محاسبه امتیاز بهینه‌سازی سفارشی بر اساس آمار معاملات و معیارهای پیشرفته. این تابع در Strategy Tester برای امتیازدهی پارامترها استفاده می‌شود.
double OnTester()
  {
   double total_trades = TesterStatistics(STAT_TRADES); // تعداد کل معاملات از آمار تستر.
   double net_profit = TesterStatistics(STAT_PROFIT); // سود خالص.
   double profit_factor = TesterStatistics(STAT_PROFIT_FACTOR); // فاکتور سود (gross profit / gross loss).
   double sharpe_ratio = TesterStatistics(STAT_SHARPE_RATIO); // نسبت شارپ برای اندازه‌گیری ریسک-ریوارد.
   double max_balance_drawdown_percent = TesterStatistics(STAT_BALANCE_DDREL_PERCENT); // حداکثر دراوداون درصدی.

   // محاسبه حداقل معاملات موردنیاز بر اساس مدت تست برای جلوگیری از over-fitting.
   datetime startDate = 0, endDate = 0;
   if(HistoryDealsTotal() > 0) // اگر معامله‌ای وجود داشته باشد.
     {
      startDate = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(0), DEAL_TIME); // زمان اولین deal.
      endDate = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(HistoryDealsTotal() - 1), DEAL_TIME); // زمان آخرین.
     }
   double duration_days = (endDate > startDate) ? double(endDate - startDate) / (24.0 * 3600.0) : 1.0; // مدت تست به روز.
   double required_min_trades = MathFloor((duration_days / 365.0) * InpMinTradesPerYear); // حداقل معاملات بر اساس سال.
   if(required_min_trades < 10) required_min_trades = 10; // حداقل ۱۰ برای اعتبار.

   // اگر معیارهای اولیه برآورده نشوند، امتیاز صفر برای فیلتر پارامترهای ضعیف.
   if(total_trades < required_min_trades || profit_factor < 1.1 || sharpe_ratio <= 0 || net_profit <= 0) return 0.0;

   // محاسبه معیارهای پیشرفته (R-squared و پایداری نزولی) برای امتیازدهی دقیق‌تر.
   double r_squared = 0, downside_consistency = 0;
   CalculateAdvancedMetrics(r_squared, downside_consistency); // فراخوانی تابع کمکی.

   // محاسبه جریمه دراوداون با استفاده از منحنی کسینوسی برای تنبیه غیرخطی drawdown بالا.
   double drawdown_penalty_factor = 0.0;
   if(max_balance_drawdown_percent < InpMaxAcceptableDrawdown && InpMaxAcceptableDrawdown > 0)
     {
      double angle = (max_balance_drawdown_percent / InpMaxAcceptableDrawdown) * (M_PI / 2.0); // زاویه برای کسینوس.
      drawdown_penalty_factor = MathCos(angle); // جریمه کاهشی.
     }

   // محاسبه امتیاز نهایی بر اساس عوامل مختلف برای بهینه‌سازی جامع.
   double final_score = 0.0;
   if(drawdown_penalty_factor > 0)
     {
      double trades_factor = MathLog(total_trades + 1); // فاکتور تعداد معاملات (لگاریتمی برای جلوگیری از extreme).
      double net_profit_factor = MathLog(net_profit + 1); // فاکتور سود خالص.
      final_score = (profit_factor * sharpe_ratio * r_squared * downside_consistency * trades_factor * net_profit_factor) * drawdown_penalty_factor; // امتیاز نهایی.
     }

   // لاگ نتایج برای دیباگ در تستر. این لاگ به فارسی برای خوانایی بهتر.
   if(InpEnableLogging)
     {
      PrintFormat("نتیجه بهینه‌سازی: معاملات=%d, فاکتور سود=%.2f, شارپ=%.2f, R²=%.3f, دراوداون=%.2f%%, جریمه=%.2f -> امتیاز: %.4f",
                  (int)total_trades, profit_factor, sharpe_ratio, r_squared, max_balance_drawdown_percent, drawdown_penalty_factor, final_score);
     }

   return final_score; // بازگشت امتیاز برای تستر.
  }

//+------------------------------------------------------------------+
//| تابع محاسبه معیارهای پیشرفته                                    |
//+------------------------------------------------------------------+
// هدف: محاسبه R-squared و پایداری نزولی برای امتیازدهی بهینه‌سازی. این تابع آمار تاریخچه را تحلیل می‌کند.
void CalculateAdvancedMetrics(double &r_squared, double &downside_consistency)
  {
   r_squared = 0; // اولیه‌سازی R-squared.
   downside_consistency = 1.0; // اولیه‌سازی پایداری.

   if(!HistorySelect(0, TimeCurrent())) return; // انتخاب کل تاریخچه معاملات - اگر شکست، خروج.
   uint total_deals = HistoryDealsTotal(); // تعداد کل dealها.
   if(total_deals < 5) return; // حداقل 5 معامله برای معیارهای معنی‌دار و جلوگیری از آمار ناکافی.

   struct EquityPoint { datetime time; double balance; }; // ساختار برای نقاط منحنی بالانس برای محاسبه R-squared.
   EquityPoint equity_curve[]; // آرایه نقاط.
   ArrayResize(equity_curve, (int)total_deals + 2); // تغییر اندازه آرایه.

   double final_balance = AccountInfoDouble(ACCOUNT_BALANCE); // بالانس نهایی.
   double net_profit = TesterStatistics(STAT_PROFIT); // سود خالص از تستر.
   double initial_balance = final_balance - net_profit; // بالانس اولیه محاسبه‌شده.

   double current_balance = initial_balance; // شروع با بالانس اولیه.
   equity_curve[0].time = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(0), DEAL_TIME) - 1; // نقطه اول قبل از اولین معامله.
   equity_curve[0].balance = current_balance; // ذخیره بالانس.

   int equity_points = 1; // شمارنده نقاط.
   for(uint i = 0; i < total_deals; i++) // حلقه روی dealها.
     {
      ulong ticket = HistoryDealGetTicket(i); // تیکت deal.
      if(ticket > 0) // اگر معتبر.
        {
         if(HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT) // اگر خروج معامله باشد.
           {
            current_balance += HistoryDealGetDouble(ticket, DEAL_PROFIT) + // اضافه سود.
                               HistoryDealGetDouble(ticket, DEAL_COMMISSION) + // کمیسیون.
                               HistoryDealGetDouble(ticket, DEAL_SWAP); // سواپ.
            equity_curve[equity_points].time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME); // زمان deal.
            equity_curve[equity_points].balance = current_balance; // ذخیره بالانس جدید.
            equity_points++; // افزایش شمارنده.
           }
        }
     }
   ArrayResize(equity_curve, equity_points); // تنظیم اندازه نهایی آرایه.
   if(equity_points < 3) return; // حداقل ۳ نقطه برای رگرسیون.

   // محاسبه R-squared برای چک linearity منحنی equity.
   double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0, sum_y2 = 0; // جمع‌ها برای فرمول.
   for(int i = 0; i < equity_points; i++) // حلقه روی نقاط.
     {
      double x = i + 1.0; // x ایندکس.
      double y = equity_curve[i].balance; // y بالانس.
      sum_x += x;
      sum_y += y;
      sum_xy += x * y;
      sum_x2 += x * x;
      sum_y2 += y * y;
     }
   double n = equity_points; // تعداد نقاط.
   double den_part1 = (n * sum_x2) - (sum_x * sum_x); // دنومیناتور اول.
   double den_part2 = (n * sum_y2) - (sum_y * sum_y); // دنومیناتور دوم.
   if(den_part1 > 0 && den_part2 > 0) // جلوگیری از sqrt منفی.
     {
      double r = ((n * sum_xy) - (sum_x * sum_y)) / MathSqrt(den_part1 * den_part2); // ضریب همبستگی.
      r_squared = r * r; // R-squared.
     }

   // محاسبه پایداری نزولی بر اساس توزیع ماهانه معاملات.
   struct MonthlyTrades { int year; int month; int count; }; // ساختار برای شمارش ماهانه.
   MonthlyTrades monthly_counts[]; // آرایه ماه‌ها.
   int total_months = 0; // شمارنده ماه‌ها.

   for(uint i = 0; i < total_deals; i++) // حلقه روی dealها.
     {
      ulong ticket = HistoryDealGetTicket(i); // تیکت.
      if(ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT) // اگر خروج.
        {
         datetime deal_time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME); // زمان deal.
         MqlDateTime dt; // ساختار زمان.
         TimeToStruct(deal_time, dt); // تبدیل به ساختار.

         int month_idx = -1; // ایندکس ماه.
         for(int j = 0; j < total_months; j++) // جستجو در آرایه.
           {
            if(monthly_counts[j].year == dt.year && monthly_counts[j].month == dt.mon) // اگر مطابقت.
              {
               month_idx = j;
               break;
              }
           }

         if(month_idx == -1) // اگر جدید.
           {
            ArrayResize(monthly_counts, total_months + 1); // افزایش اندازه.
            monthly_counts[total_months].year = dt.year;
            monthly_counts[total_months].month = dt.mon;
            monthly_counts[total_months].count = 1; // شروع شمارش.
            total_months++;
           }
         else // اگر موجود.
           {
            monthly_counts[month_idx].count++; // افزایش شمارش.
           }
        }
     }

   if(total_months <= 1) // اگر ماه کم، پیش‌فرض ۱.
     {
      downside_consistency = 1.0;
      return;
     }

   double target_trades_per_month = InpMinTradesPerYear / 12.0; // هدف ماهانه.
   if(target_trades_per_month < 1) target_trades_per_month = 1; // حداقل ۱.

   double sum_of_squared_downside_dev = 0; // جمع مربعات انحرافات نزولی.
   for(int i = 0; i < total_months; i++) // حلقه روی ماه‌ها.
     {
      if(monthly_counts[i].count < target_trades_per_month) // اگر کمتر از هدف.
        {
         double deviation = target_trades_per_month - monthly_counts[i].count; // انحراف.
         sum_of_squared_downside_dev += deviation * deviation; // مربع.
        }
     }

   double downside_variance = sum_of_squared_downside_dev / total_months; // واریانس.
   double downside_deviation = MathSqrt(downside_variance); // انحراف استاندارد.
   downside_consistency = 1.0 / (1.0 + downside_deviation); // پایداری (هرچه کمتر deviation، بالاتر).
  }

//+------------------------------------------------------------------+
//| تابع کمکی: شمارش جلسات فعال                                    |
//+------------------------------------------------------------------+
// هدف: شمارش تعداد جلسات فعال برای لاگ اولیه‌سازی. این تابع آموزشی برای چک وضعیت سیستم است.
int CountActiveSessions()
  {
   int count = 0; // شمارنده.
   if(InpS1_IsActive) count++;
   if(InpS2_IsActive) count++;
   if(InpS3_IsActive) count++;
   if(InpS4_IsActive) count++;
   return count; // بازگشت تعداد.
  }






//+------------------------------------------------------------------+
//|                                                    RangeLib.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل برای حفاظت.
#property link      "https://..." // لینک پروژه.

//--- این گارد از include شدن چندباره فایل در پروژه جلوگیری می‌کند و کد را تمیز نگه می‌دارد.
#ifndef RANGELIB_MQH // چک گارد.
#define RANGELIB_MQH // تعریف گارد.

#include "Settings.mqh"     // کتابخانه تنظیمات ورودی کاربر برای دسترسی به پارامترها.

//+------------------------------------------------------------------+
//| STRUCT for Range Data                                            |
//+------------------------------------------------------------------+
//--- ساختار برای نگهداری داده‌های محدوده. این ساختار مثل یک کلاس ساده عمل می‌کند و تمام داده‌های مرتبط را در یک جا نگه می‌دارد تا کد خواناتر شود و مدیریت داده آسان‌تر باشد.
struct RangeData
  {
   double            rangeHigh;      // بالاترین قیمت شناسایی شده در بازه (High محدوده) برای شکست صعودی.
   double            rangeLow;       // پایین‌ترین قیمت شناسایی شده در بازه (Low محدوده) برای شکست نزولی.
   bool              isValid;        // پرچم اعتبار محدوده (true اگر پس از اعتبارسنجی معتبر باشد) برای چک قبل از معامله.
   datetime          startTime;      // زمان شروع بازه به فرمت datetime برای ترسیم و محاسبات زمانی.
   datetime          endTime;        // زمان پایان بازه به فرمت datetime برای تعریف دقیق بازه.
   double            rangeSizePips;  // اندازه محدوده به پیپ (برای محاسبات ریسک و استاپ لاس) که پایه SL است.
  };

//+------------------------------------------------------------------+
//| Function to Draw Range on Chart                                  |
//+------------------------------------------------------------------+
//--- این تابع برای نمایش بصری محدوده روی چارت استفاده می‌شود تا کاربر بتواند محدوده شناسایی‌شده را به صورت گرافیکی ببیند و استراتژی را ارزیابی کند. این برای دیباگ و آموزش مفید است.
void DrawRangeOnChart(RangeData &rd,int session_magic)
  {
   //--- اگر محدوده نامعتبر باشد، هیچ چیزی ترسیم نکن تا از خطاهای غیرضروری جلوگیری شود و منابع هدر نرود.
   if(!rd.isValid) return;

   //--- ساخت پیشوند منحصر به فرد برای اشیاء این جلسه تا با جلسات دیگر تداخل نداشته باشد و مدیریت اشیاء آسان شود.
   string obj_prefix = "Range_" + IntegerToString(session_magic) + "_";

   //--- ایجاد مستطیل برای نمایش محدوده زمانی و قیمتی روی چارت.
   ObjectCreate(0,obj_prefix + "Rect",OBJ_RECTANGLE,0,rd.startTime,rd.rangeHigh,rd.endTime,rd.rangeLow);
   //--- تنظیم رنگ مستطیل برای تمایز بصری (رنگ خاکستری تیره برای وضوح).
   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_COLOR,clrDarkSlateGray);
   //--- تنظیم استایل خطوط مستطیل (جامد برای وضوح بهتر).
   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_STYLE,STYLE_SOLID);
   //--- پر کردن داخل مستطیل برای نمایش بهتر محدوده و تمایز از کندل‌ها.
   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_FILL,true);
   //--- ارسال مستطیل به پس‌زمینه تا مزاحم دیدن کندل‌ها نشود و چارت خوانا بماند.
   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_BACK,true);

   if(InpEnableLogging) Print("محدوده روی چارت ترسیم شد: High=" + DoubleToString(rd.rangeHigh, _Digits) + ", Low=" + DoubleToString(rd.rangeLow, _Digits) + " (مجیک: " + IntegerToString(session_magic) + ")."); // لاگ ترسیم.
  }

//+------------------------------------------------------------------+
//| Helper Function: IsKijunFlat                                     |
//+------------------------------------------------------------------+
//--- این تابع چک می‌کند آیا کیجون‌سن صاف است (شیب نزدیک به صفر با رگرسیون خطی). تایم فریم را به عنوان ورودی می‌گیرد تا مستقل از چارت باشد.
//--- نکته آموزشی: از رگرسیون خطی ساده برای محاسبه شیب استفاده می‌شود. دوره (InpKijunFlatPeriod) اجازه می‌دهد تا حساسیت را تنظیم کنید: دوره کوتاه (مثل ۳) سیگنال‌های بیشتری می‌دهد اما ممکن است نویز داشته باشد؛ دوره بلند (مثل ۲۰) سیگنال‌های باکیفیت‌تری می‌دهد اما کمتر. این فیلتر برای تأیید تعادل بازار کلیدی است.
bool IsKijunFlat(int ichimoku_handle,int bar_idx,ENUM_TIMEFRAMES timeframe)
  {
  //چک تعداد کندل برای اطمینان مجود بودن 
  if(bar_idx<InpKijunFlatPeriod)
    {
     return false;
     
    }
   //--- تعریف آرایه دینامیک برای کیجون‌سن بر اساس دوره ورودی برای محاسبه شیب.
   double kijun_buffer[]; // آرایه برای مقادیر کیجون.
   ArrayResize(kijun_buffer, InpKijunFlatPeriod); // تغییر اندازه آرایه به دوره مشخص‌شده برای دقت.
   //--- کپی مقادیر کیجون از هندل (از دوره-۱ کندل قبل تا کندل فعلی) برای تحلیل.
   if(CopyBuffer(ichimoku_handle,1,bar_idx - InpKijunFlatPeriod + 1,InpKijunFlatPeriod,kijun_buffer) != InpKijunFlatPeriod) 
     {
      if(InpEnableLogging) Print("خطا در کپی بافر کیجون: ایندکس=" + IntegerToString(bar_idx) + "."); // لاگ خطا.
      return false; // اگر کپی شکست خورد، false برگردان.
     }

   //--- محاسبه شیب رگرسیون خطی ساده برای دوره کندل با استفاده از فرمول استاندارد.
   double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0; // متغیرهای جمع برای فرمول رگرسیون.
   double n = InpKijunFlatPeriod; // تعداد نقاط (دوره) برای محاسبه.
   for(int k = 0; k < InpKijunFlatPeriod; k++) // حلقه روی دوره برای محاسبه جمع‌ها.
     {
      double x = k + 1.0; // x ایندکس از ۱ تا n برای رگرسیون.
      double y = kijun_buffer[InpKijunFlatPeriod - 1 - k]; // y مقادیر کیجون از قدیمی به جدید (چون بافر از جدید به قدیمی است).
      sum_x += x; // جمع x.
      sum_y += y; // جمع y.
      sum_xy += x * y; // جمع xy.
      sum_x2 += x * x; // جمع x^2.
     }

   double denominator = (n * sum_x2 - sum_x * sum_x); // دنومیناتور شیب برای جلوگیری از تقسیم بر صفر.
   if (denominator == 0) // چک ایمنی.
     {
      if(InpEnableLogging) Print("خطا در محاسبه شیب کیجون: دنومیناتور صفر."); // لاگ.
      return false; // جلوگیری از تقسیم بر صفر (هرچند بعید است).
     }

   //--- فرمول شیب رگرسیون برای چک صاف بودن.
   double slope = (n * sum_xy - sum_x * sum_y) / denominator;

   //--- اگر شیب مطلق کمتر از آستانه (مثل ۰.۰۰۰۱) باشد، صاف در نظر بگیر. این آستانه را می‌توان تنظیم کرد اگر نیاز به حساسیت بیشتر باشد.
   bool is_flat = MathAbs(slope) < 0.0001;
   if(InpEnableLogging && is_flat) Print("کیجون صاف تشخیص داده شد: شیب=" + DoubleToString(slope, 6) + " (ایندکس: " + IntegerToString(bar_idx) + ")."); // لاگ موفقیت.
   return is_flat;
  }

//+------------------------------------------------------------------+
//| Helper Function: IsCandleInKumo                                  |
//+------------------------------------------------------------------+
//--- این تابع چک می‌کند آیا کندل کاملاً درون ابر کومو است. تایم فریم را به عنوان ورودی می‌گیرد تا با تایم فریم جلسه همخوانی داشته باشد.
//--- نکته آموزشی: چک می‌کند آیا High کندل زیر سقف کومو و Low بالای کف کومو باشد، که نشان‌دهنده تعادل بازار است. این فیلتر برای جلوگیری از سیگنال در روند قوی مفید است.
bool IsCandleInKumo(int ichimoku_handle,int bar_idx,ENUM_TIMEFRAMES timeframe)
  {
   //--- خواندن سنکو A و B برای کندل مشخص با استفاده از CopyBuffer.
   double senkou_a[1], senkou_b[1]; // بافرها برای سنکو A و B.
   if(CopyBuffer(ichimoku_handle,2,bar_idx,1,senkou_a) != 1) // کپی سنکو A.
     {
      if(InpEnableLogging) Print("خطا در کپی بافر سنکو A: ایندکس=" + IntegerToString(bar_idx) + "."); // لاگ خطا.
      return false; // اگر شکست false.
     }
   if(CopyBuffer(ichimoku_handle,3,bar_idx,1,senkou_b) != 1) // کپی سنکو B.
     {
      if(InpEnableLogging) Print("خطا در کپی بافر سنکو B: ایندکس=" + IntegerToString(bar_idx) + "."); // لاگ.
      return false; // اگر شکست false.
     }

   //--- گرفتن High و Low کندل از تایم فریم جلسه برای چک موقعیت.
   double high = iHigh(_Symbol,timeframe,bar_idx); // بالاترین قیمت کندل.
   double low = iLow(_Symbol,timeframe,bar_idx); // پایین‌ترین قیمت کندل.

   //--- تعیین سقف و کف ابر کومو (سقف Max سنکوها، کف Min) برای مقایسه.
   double kumo_top = MathMax(senkou_a[0],senkou_b[0]); // سقف کومو.
   double kumo_bottom = MathMin(senkou_a[0],senkou_b[0]); // کف کومو.

   //--- چک شرط تعادل: High <= سقف و Low >= کف برای تأیید داخل کومو بودن.
   bool in_kumo = (high <= kumo_top && low >= kumo_bottom);
   if(InpEnableLogging && in_kumo) Print("کندل داخل کومو تشخیص داده شد: High=" + DoubleToString(high, _Digits) + ", Low=" + DoubleToString(low, _Digits) + " (ایندکس: " + IntegerToString(bar_idx) + ")."); // لاگ موفقیت.
   return in_kumo;
  }

#endif //RANGELIB_MQH






//+------------------------------------------------------------------+
//|                                                 TradeManager.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل برای حفاظت قانونی.
#property link      "https://..." // لینک مرتبط با پروژه برای ارجاع.

//--- گارد برای جلوگیری از include شدن چندباره. این گارد کد را تمیز نگه می‌دارد و از خطاهای redefinition جلوگیری می‌کند.
#ifndef TRADEMANAGER_MQH // چک گارد.
#define TRADEMANAGER_MQH // تعریف گارد.

#include "Settings.mqh"     // کتابخانه تنظیمات ورودی کاربر برای دسترسی به پارامترها.
#include "RangeLib.mqh"     // کتابخانه تحلیل و اعتبارسنجی محدوده (شامل struct RangeData) برای استفاده از داده‌های محدوده.
#include <Trade\Trade.mqh>  // کتابخانه استاندارد MQL5 برای معاملات و عملیات CTrade.
CTrade trade;               // نمونه سراسری CTrade برای عملیات معاملاتی. این نمونه جهانی برای دسترسی آسان در همه فایل‌ها است.

//+------------------------------------------------------------------+
//| Function to Calculate Lot Size                                   |
//+------------------------------------------------------------------+
//--- این تابع حجم معامله را بر اساس درصد ریسک و فاصله استاپ لاس محاسبه می‌کند. این محاسبه بر اساس equity حساب است تا ریسک واقعی کنترل شود.
double CalculateLotSize(double risk_percent,double stop_loss_pips)
  {
   //--- شرط ایمنی: اگر فاصله استاپ صفر یا منفی، حجم صفر برگردان تا معامله انجام نشود.
   if(stop_loss_pips <= 0) 
     {
      if(InpEnableLogging) Print("خطا در محاسبه لات: فاصله استاپ نامعتبر (" + DoubleToString(stop_loss_pips, 2) + "). حجم 0 بازگشت."); // لاگ خطا.
      return 0.0;
     }

   //--- گرفتن اکویتی حساب (شامل سود/زیان باز) برای محاسبه ریسک واقعی.
   double account_equity = AccountInfoDouble(ACCOUNT_EQUITY);
   //--- محاسبه مبلغ ریسک مجاز بر اساس درصد ورودی.
   double risk_amount = account_equity * (risk_percent / 100.0);

   //--- گرفتن ارزش تیک و اندازه تیک نماد برای محاسبه ارزش پیپ.
   double tick_value = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
   double tick_size = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);

   //--- شرط ایمنی: اگر اطلاعات نامعتبر، حجم صفر برگردان و لاگ کن.
   if(tick_value <= 0 || tick_size <= 0) 
     {
      if(InpEnableLogging) Print("خطا در محاسبه لات: tick_value یا tick_size نامعتبر."); // لاگ خطا.
      return 0.0;
     }

   //--- محاسبه ارزش هر پیپ برای نماد فعلی.
   double value_per_pip = tick_value / tick_size * _Point;
   if(value_per_pip <= 0) 
     {
      if(InpEnableLogging) Print("خطا در محاسبه لات: value_per_pip نامعتبر."); // لاگ.
      return 0.0;
     }

   //--- محاسبه حجم خام بر اساس ریسک و فاصله.
   double lot_size = risk_amount / (stop_loss_pips * value_per_pip);

   //--- گرفتن قوانین بروکر برای حجم (min, max, step) برای رعایت مقررات.
   double min_lot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   double max_lot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX);
   double lot_step = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);

   //--- گرد کردن حجم به گام مجاز بروکر.
   lot_size = MathRound(lot_size / lot_step) * lot_step;
   //--- محدود کردن بین min و max برای جلوگیری از خطای معامله.
   lot_size = MathMax(min_lot,MathMin(max_lot,lot_size));

   if(InpEnableLogging && lot_size > 0) Print("محاسبه لات موفق: حجم = " + DoubleToString(lot_size, 2) + " (ریسک: " + DoubleToString(risk_percent, 2) + "%, استاپ: " + DoubleToString(stop_loss_pips, 2) + ")."); // لاگ موفقیت.

   return lot_size; // بازگشت حجم نهایی.
  }

//+------------------------------------------------------------------+
//| Function to Place Pending Orders                                 |
//+------------------------------------------------------------------+
//--- این تابع سفارشات پندینگ را بر اساس قیمت‌های محاسبه شده ثبت می‌کند. سفارشات BuyStop و SellStop برای شکست محدوده استفاده می‌شوند.
void PlacePendingOrders(int session_magic_base,bool is_trend_on,bool is_uptrend,RangeData &rd,double buy_stop_price,double sell_stop_price)
  {
   //--- محاسبه فاصله اضافی برای استاپ لاس بر اساس درصد اضافی.
   double sl_additional_pips = rd.rangeSizePips * (InpStopLossAdditionalPercent / 100.0);
   //--- محاسبه فاصله کل استاپ لاس به پیپ برای محاسبه لات.
   double sl_distance_pips = rd.rangeSizePips + sl_additional_pips;

   //--- محاسبه حجم معامله با فراخوانی تابع مربوطه.
   double lot_size = CalculateLotSize(InpRiskPercentage,sl_distance_pips);
   if(lot_size <= 0) 
     {
      if(InpEnableLogging) Print("خطا در قرار سفارش: حجم لات نامعتبر (مجیک: " + IntegerToString(session_magic_base) + ")."); // لاگ خطا.
      return; // اگر حجم نامعتبر، خارج شو.
     }

   //--- محاسبه استاپ لاس برای خرید و فروش با اضافه کردن بافر.
   double buy_sl = rd.rangeLow - sl_additional_pips * _Point;
   double sell_sl = rd.rangeHigh + sl_additional_pips * _Point;

   double buy_tp = 0.0; // پیش‌فرض بدون تی‌پی (برای پله‌ای).
   double sell_tp = 0.0;

   //--- اگر پله‌ای خاموش باشد، تی‌پی ثابت محاسبه کن برای خروج کامل.
   if(!InpEnablePartialClose)
     {
      buy_tp = buy_stop_price + (buy_stop_price - buy_sl) * InpTakeProfitRatio_Stage1; // TP برای خرید.
      sell_tp = sell_stop_price - (sell_sl - sell_stop_price) * InpTakeProfitRatio_Stage1; // TP برای فروش.
     }

   //--- تنظیم انقضای سفارشات پندینگ بر اساس زمان انقضای جلسه (بهبود: اضافه شده برای جلوگیری از سفارشات طولانی).
   datetime expiry_time = 0; // پیش‌فرض بدون انقضا، اما می‌توان تنظیم کرد.
   string trade_comment = "Stage1"; // وضعیت اولیه معامله را مشخص می‌کنیم
   //--- اگر فیلتر روند خاموش، هر دو سفارش را ثبت کن.
   if(!is_trend_on)
     {
      trade.BuyStop(lot_size,buy_stop_price,_Symbol,buy_sl,buy_tp,0,expiry_time,IntegerToString(session_magic_base)); // ثبت BuyStop.
      if(InpEnableLogging) Print("سفارش BuyStop قرار گرفت: قیمت=" + DoubleToString(buy_stop_price, _Digits) + ", SL=" + DoubleToString(buy_sl, _Digits) + " (مجیک: " + IntegerToString(session_magic_base) + ")."); // لاگ.
      trade.SellStop(lot_size,sell_stop_price,_Symbol,sell_sl,sell_tp,0,expiry_time,IntegerToString(session_magic_base)); // ثبت SellStop.
      if(InpEnableLogging) Print("سفارش SellStop قرار گرفت: قیمت=" + DoubleToString(sell_stop_price, _Digits) + ", SL=" + DoubleToString(sell_sl, _Digits) + " (مجیک: " + IntegerToString(session_magic_base) + ")."); // لاگ.
     }
   else // اگر روند فعال، فقط در جهت روند ثبت کن.
     {
      if(is_uptrend) 
        {
         trade.BuyStop(lot_size,buy_stop_price,_Symbol,buy_sl,buy_tp,0,expiry_time,IntegerToString(session_magic_base)); // فقط خرید اگر صعودی.
         if(InpEnableLogging) Print("سفارش BuyStop (روند صعودی) قرار گرفت: قیمت=" + DoubleToString(buy_stop_price, _Digits) + " (مجیک: " + IntegerToString(session_magic_base) + ")."); // لاگ.
        }
      else 
        {
         trade.SellStop(lot_size,sell_stop_price,_Symbol,sell_sl,sell_tp,0,expiry_time,IntegerToString(session_magic_base)); // فقط فروش اگر نزولی.
         if(InpEnableLogging) Print("سفارش SellStop (روند نزولی) قرار گرفت: قیمت=" + DoubleToString(sell_stop_price, _Digits) + " (مجیک: " + IntegerToString(session_magic_base) + ")."); // لاگ.
        }
     }
  }

//+------------------------------------------------------------------+
//| Function for Session CleanUp                                     |
//+------------------------------------------------------------------+
//--- این تابع تمام پوزیشن‌ها و سفارشات جلسه را در انقضا پاک می‌کند. این برای مدیریت ریسک زمانی استفاده می‌شود.
void SessionCleanUp(int session_magic_base)
  {
   //--- حلقه روی پوزیشن‌های باز از آخر به اول.
   for(int i=PositionsTotal()-1; i>=0; i--)
     {
      ulong pos_ticket = PositionGetTicket(i); // تیکت پوزیشن.
      if(pos_ticket > 0 && PositionSelectByTicket(pos_ticket)) // اگر معتبر و انتخاب شود.
        {
         long magic = PositionGetInteger(POSITION_MAGIC); // مجیک پوزیشن.
         if(magic == session_magic_base) // اگر مطابقت.
           {
            trade.PositionClose(pos_ticket); // بستن پوزیشن.
            if(InpEnableLogging) Print("پوزیشن با تیکت " + IntegerToString(pos_ticket) + " بسته شد (انقضا جلسه، مجیک: " + IntegerToString(session_magic_base) + ")."); // لاگ.
           }
        }
     }

   //--- حلقه روی سفارشات پندینگ از آخر به اول.
   for(int i=OrdersTotal()-1; i>=0; i--)
     {
      ulong ord_ticket = OrderGetTicket(i); // تیکت سفارش.
      if(ord_ticket > 0 && OrderSelect(ord_ticket)) // اگر معتبر.
        {
         if(OrderGetInteger(ORDER_MAGIC) == session_magic_base) // اگر مطابقت.
           {
            trade.OrderDelete(ord_ticket); // حذف سفارش.
            if(InpEnableLogging) Print("سفارش پندینگ با تیکت " + IntegerToString(ord_ticket) + " حذف شد (انقضا جلسه، مجیک: " + IntegerToString(session_magic_base) + ")."); // لاگ.
           }
        }
     }
  }

#endif //TRADEMANAGER_MQH







//+------------------------------------------------------------------+
//|                                             SessionTrader.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل.
#property link      "https://..." // لینک مرتبط.

//--- این گارد از include شدن چندباره فایل در پروژه جلوگیری می‌کند و کد را ایمن نگه می‌دارد.
#ifndef SESSIONTRADER_MQH // چک گارد.
#define SESSIONTRADER_MQH // تعریف گارد.

#include "Settings.mqh"     // کتابخانه تنظیمات ورودی کاربر.
#include "RangeLib.mqh"     // کتابخانه توابع کمکی برای تحلیل محدوده.
#include "TradeManager.mqh" // کتابخانه مدیریت معاملات و ریسک.

//+------------------------------------------------------------------+
//| Class CSessionTrader                                             |
//+------------------------------------------------------------------+
//--- این کلاس، منطق کامل یک جلسه معاملاتی را کپسوله می‌کند تا سیستم ماژولار و بدون تداخل باشد. هر نمونه از این کلاس یک جلسه مستقل را مدیریت می‌کند و اجازه scale را می‌دهد.
class CSessionTrader
  {
private:
   // --- متغیرهای پیکربندی ---
   bool              m_is_active; // وضعیت فعال بودن جلسه (true اگر فعال باشد) برای کنترل جلسات.
   int               m_magic_number; // مجیک نامبر منحصر به فرد برای شناسایی معاملات این جلسه.
   ENUM_TIMEFRAMES   m_timeframe; // تایم فریم مخصوص این جلسه برای تحلیل محدوده.
   int               m_start_hour, m_start_min; // ساعت و دقیقه شروع بازه تحلیل.
   int               m_end_hour, m_end_min; // ساعت و دقیقه پایان بازه تحلیل.
   int               m_expiry_hour, m_expiry_min; // ساعت و دقیقه انقضای جلسه (برای پاکسازی).

   // --- هندل‌های اندیکاتور ---
   int               m_ichimoku_handle; // هندل اندیکاتور ایچیموکو برای فیلتر تعادل بازار.
   int               m_placement_atr_handle; // هندل ATR برای محاسبه بافر دینامیک سفارشات.
   int               m_range_atr_handle; // هندل ATR برای اعتبارسنجی اندازه محدوده.
   int               m_ema_handle; // هندل EMA برای فیلتر روند.
   int               m_trail_atr_handle; // هندل ATR برای ترلینگ استاپ.

   // --- متغیرهای وضعیت ---
   datetime          m_last_analysis_date; // تاریخ آخرین تحلیل موفق برای جلوگیری از تکرار روزانه.

public:
   //--- سازنده کلاس: تمام متغیرها را با مقادیر پیش‌فرض مقداردهی می‌کند تا از خطاهای زمان اجرا جلوگیری شود و کلاس ایمن باشد.
                     CSessionTrader(void) : m_is_active(false), m_magic_number(0), m_timeframe(PERIOD_M15),
                     m_start_hour(0),m_start_min(0), m_end_hour(0),m_end_min(0), m_expiry_hour(0),m_expiry_min(0),
                     m_ichimoku_handle(INVALID_HANDLE), m_placement_atr_handle(INVALID_HANDLE), m_range_atr_handle(INVALID_HANDLE),
                     m_ema_handle(INVALID_HANDLE), m_trail_atr_handle(INVALID_HANDLE), m_last_analysis_date(0) {} // اولیه‌سازی صریح همه متغیرها برای ایمنی و جلوگیری از undefined behavior.

   //--- این تابع برای مقداردهی اولیه کلاس با پارامترهای ورودی یک جلسه استفاده می‌شود. هندل‌های اندیکاتورها را ایجاد می‌کند و در صورت خطا لاگ می‌زند.
   void              Init(bool is_active,ENUM_TIMEFRAMES timeframe,int start_h,int start_m,int end_h,int end_m,int expiry_h,int expiry_m,int magic)
     {
      m_is_active = is_active; // تنظیم وضعیت فعال بودن جلسه.
      m_timeframe = timeframe; // تنظیم تایم فریم تحلیل جلسه.
      m_start_hour = start_h; // تنظیم ساعت شروع بازه.
      m_start_min = start_m; // تنظیم دقیقه شروع بازه.
      m_end_hour = end_h; // تنظیم ساعت پایان بازه.
      m_end_min = end_m; // تنظیم دقیقه پایان بازه.
      m_expiry_hour = expiry_h; // تنظیم ساعت انقضا.
      m_expiry_min = expiry_m; // تنظیم دقیقه انقضا.
      m_magic_number = magic; // تنظیم مجیک نامبر منحصر به فرد.

      if(!m_is_active) return; // اگر جلسه غیرفعال است، هندل‌ها را ایجاد نکن تا منابع هدر نرود و سیستم بهینه بماند.

      // ایجاد هندل ایچیموکو با پارامترهای ورودی کاربر و تایم فریم جلسه.
      m_ichimoku_handle = iIchimoku(_Symbol,m_timeframe,InpIchimoku_Tenkan,InpIchimoku_Kijun,InpIchimoku_Senkou);
      if(m_ichimoku_handle == INVALID_HANDLE) 
        {
         if(InpEnableLogging) Print("خطا در ایجاد هندل ایچیموکو برای جلسه " + IntegerToString(magic) + "."); // لاگ خطا.
        }

      // ایجاد هندل ATR برای بافر قرارگیری سفارشات، با تایم فریم جلسه.
      m_placement_atr_handle = iATR(_Symbol,m_timeframe,InRangeATR_Period);
      if(m_placement_atr_handle == INVALID_HANDLE) 
        {
         if(InpEnableLogging) Print("خطا در ایجاد هندل ATR قرارگیری برای جلسه " + IntegerToString(magic) + "."); // لاگ.
        }

      // ایجاد هندل ATR برای اعتبارسنجی محدوده.
      m_range_atr_handle = iATR(_Symbol,InRangeATR_TimeFrame,InRangeATR_Period);
      if(m_range_atr_handle == INVALID_HANDLE) 
        {
         if(InpEnableLogging) Print("خطا در ایجاد هندل ATR اعتبارسنجی برای جلسه " + IntegerToString(magic) + "."); // لاگ.
        }

      // ایجاد هندل EMA برای فیلتر روند.
      m_ema_handle = iMA(_Symbol,InpTrendEMATimeFrame,InpTrendEMAPeriod,0,MODE_EMA,InpTrendEMAAppliedPrice);
      if(m_ema_handle == INVALID_HANDLE) 
        {
         if(InpEnableLogging) Print("خطا در ایجاد هندل EMA برای جلسه " + IntegerToString(magic) + "."); // لاگ.
        }

      // ایجاد هندل ATR برای ترلینگ استاپ.
      m_trail_atr_handle = iATR(_Symbol,InpTrailingStopATRTimeFrame,InpTrailingStopATRPeriod);
      if(m_trail_atr_handle == INVALID_HANDLE) 
        {
         if(InpEnableLogging) Print("خطا در ایجاد هندل ATR ترلینگ برای جلسه " + IntegerToString(magic) + "."); // لاگ.
        }

      if(InpEnableLogging) Print("جلسه " + IntegerToString(magic) + " اولیه‌سازی شد."); // لاگ موفقیت.
     }

   //--- این تابع برای آزادسازی منابع (هندل‌ها و اشیاء گرافیکی) در زمان حذف اکسپرت استفاده می‌شود تا حافظه آزاد شود و سیستم پایدار بماند.
   void              Deinit(void)
     {
      if(m_ichimoku_handle != INVALID_HANDLE) IndicatorRelease(m_ichimoku_handle); // آزادسازی هندل ایچیموکو اگر معتبر باشد.
      if(m_placement_atr_handle != INVALID_HANDLE) IndicatorRelease(m_placement_atr_handle); // آزادسازی هندل ATR قرارگیری.
      if(m_range_atr_handle != INVALID_HANDLE) IndicatorRelease(m_range_atr_handle); // آزادسازی هندل ATR اعتبارسنجی.
      if(m_ema_handle != INVALID_HANDLE) IndicatorRelease(m_ema_handle); // آزادسازی هندل EMA.
      if(m_trail_atr_handle != INVALID_HANDLE) IndicatorRelease(m_trail_atr_handle); // آزادسازی هندل ATR ترلینگ.
      ObjectsDeleteAll(0,"Range_"+IntegerToString(m_magic_number)+"_"); // حذف تمام اشیاء گرافیکی مربوط به این جلسه با پیشوند خاص برای تمیز کردن چارت.

      if(InpEnableLogging) Print("جلسه " + IntegerToString(m_magic_number) + " خاتمه یافت."); // لاگ خاتمه.
     }

   //--- این تابع هر ۶۰ ثانیه فراخوانی می‌شود و منطق تحلیل و پاکسازی جلسه را مدیریت می‌کند. این روش بهینه است زیرا بار OnTick را کاهش می‌دهد و فقط عملیات دوره‌ای را انجام می‌دهد.
   void              OnTimerUpdate(void)
     {
      if(!m_is_active) return; // اگر جلسه غیرفعال است، از تابع خارج شو تا پردازش بیهوده انجام نشود.

      datetime now = TimeCurrent(); // گرفتن زمان فعلی سرور برای چک زمان‌ها.
      MqlDateTime now_struct; // ساختار برای شکستن زمان به اجزا (ساعت، دقیقه و غیره).
      TimeToStruct(now,now_struct); // تبدیل زمان به ساختار.

      if(now_struct.hour == m_expiry_hour && now_struct.min == m_expiry_min) // چک اگر زمان انقضا رسیده باشد.
        {
         SessionCleanUp(m_magic_number); // فراخوانی تابع پاکسازی برای بستن پوزیشن‌ها و حذف سفارشات.
         if(InpEnableLogging) Print("انقضای جلسه " + IntegerToString(m_magic_number) + " رسید و پاکسازی انجام شد."); // لاگ انقضا.
         return; // خروج از تابع پس از پاکسازی.
        }

      MqlDateTime end_struct = now_struct; // ساختار برای زمان پایان بازه.
      end_struct.hour = m_end_hour; // تنظیم ساعت پایان.
      end_struct.min = m_end_min; // تنظیم دقیقه پایان - تحلیل دقیقا در دقیقه پایان انجام می‌شود تا کندل کامل شود.
      end_struct.sec = 0; // ثانیه صفر برای دقت زمانی.
      datetime analysis_time = StructToTime(end_struct); // تبدیل ساختار به datetime.

      if(now >= analysis_time && !IsSameDay(m_last_analysis_date,now)) // اگر زمان تحلیل رسیده و امروز تحلیل نشده.
        {
         AnalyzeAndPlaceOrders(); // فراخوانی تابع تحلیل و قرارگیری سفارشات.
         m_last_analysis_date = now; // آپدیت تاریخ آخرین تحلیل برای جلوگیری از تکرار و بهینه‌سازی.
         if(InpEnableLogging) Print("تحلیل جلسه " + IntegerToString(m_magic_number) + " در زمان " + TimeToString(now) + " انجام شد."); // لاگ تحلیل.
        }
     }

   //--- این تابع مجیک نامبر جلسه را برمی‌گرداند تا در OnTick برای پیدا کردن نمونه کلاس استفاده شود.
   int               GetMagicNumber(void) { return m_magic_number; } // بازگشت ساده مجیک نامبر برای شناسایی.

   //--- این تابع مدیریت معاملات فعال (خروج پله‌ای و ترلینگ استاپ) را انجام می‌دهد. حالا داخل کلاس است تا به هندل ATR دسترسی داشته باشد و مستقل باشد.
  //--- این تابع مدیریت معاملات فعال (خروج پله‌ای و ترلینگ استاپ) را با جزئیات کامل لاگ انجام می‌دهد.
bool ManageActiveTrade(ulong ticket)
{
    // ========================================================================================
    // بخش ۱: مقداردهی اولیه و جمع‌آوری اطلاعات پایه
    // ========================================================================================
    PrintFormat("--- ManageActiveTrade START for Ticket: %s ---", (string)ticket);

    if (!PositionSelectByTicket(ticket))
    {
        PrintFormat("[ERROR] Ticket %s: Could not select the position. Exiting.", (string)ticket);
        return false;
    }
    PrintFormat("[INFO] Ticket %s: Position selected successfully.", (string)ticket);

    long current_magic = PositionGetInteger(POSITION_MAGIC);
    if (current_magic != m_magic_number)
    {
        // این لاگ معمولاً نباید دیده بشه چون در OnTick فیلتر شده، ولی برای اطمینان هست
        PrintFormat("[DEBUG] Ticket %s: Magic number %d does not match session magic %d. Skipping.", (string)ticket, current_magic, m_magic_number);
        return false;
    }

    // --- جمع‌آوری تمام داده‌های مورد نیاز از پوزیشن
    double entry_price = PositionGetDouble(POSITION_PRICE_OPEN);
    double current_sl = PositionGetDouble(POSITION_SL);
    double current_tp = PositionGetDouble(POSITION_TP);
    double volume = PositionGetDouble(POSITION_VOLUME);
    ENUM_POSITION_TYPE pos_type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    string s_pos_type = (pos_type == POSITION_TYPE_BUY ? "BUY" : "SELL");

    PrintFormat("[DATA] Ticket %s: Type=%s, Volume=%.2f, Entry=%.5f, SL=%.5f, TP=%.5f",
                (string)ticket, s_pos_type, volume, entry_price, current_sl, current_tp);

    bool action_taken = false; // پرچمی برای اینکه بفهمیم آیا در این تیک کاری انجام دادیم یا نه

    // ========================================================================================
    // بخش ۲: تشخیص وضعیت فعلی معامله (State Detection)
    // ========================================================================================
    
    // --- چک می‌کنیم آیا معامله در وضعیت اولیه (Initial) قرار دارد یا به نقطه سر به سر (Breakeven) رسیده ---
    // برای تشخیص دقیق، از یک بافر کوچک (2 * _Point) استفاده می‌کنیم تا خطاهای اعشاری را پوشش دهیم
    bool is_initial_stage = (pos_type == POSITION_TYPE_BUY) ? (current_sl < entry_price - 2 * _Point) : (current_sl > entry_price + 2 * _Point);
    bool is_breakeven_stage = MathAbs(current_sl - entry_price) < 2 * _Point;

    PrintFormat("[STATE] Ticket %s: Is in Initial Stage? -> %s. Is in Breakeven Stage? -> %s.",
                (string)ticket, (is_initial_stage ? "YES" : "NO"), (is_breakeven_stage ? "YES" : "NO"));


    // ========================================================================================
    // بخش ۳: منطق خروج پله‌ای (فقط در وضعیت اولیه اجرا می‌شود)
    // ========================================================================================
    if (InpEnablePartialClose && is_initial_stage)
    {
        PrintFormat("[LOGIC] Ticket %s: Partial close is enabled and position is in initial stage. Checking for TP1 target...", (string)ticket);

        double sl_distance_price = MathAbs(entry_price - current_sl);
        PrintFormat("[CALC] Ticket %s: SL Distance in price = %.5f", (string)ticket, sl_distance_price);

        double target_price = (pos_type == POSITION_TYPE_BUY) ? (entry_price + sl_distance_price * InpTakeProfitRatio_Stage1) : (entry_price - sl_distance_price * InpTakeProfitRatio_Stage1);
        PrintFormat("[CALC] Ticket %s: Calculated TP1 Target Price = %.5f", (string)ticket, target_price);

        double current_market_price = (pos_type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
        PrintFormat("[DATA] Ticket %s: Current Market Price for check = %.5f", (string)ticket, current_market_price);

        bool target_hit = (pos_type == POSITION_TYPE_BUY && current_market_price >= target_price) ||
                          (pos_type == POSITION_TYPE_SELL && current_market_price <= target_price);

        if (target_hit)
        {
            PrintFormat("[ACTION] Ticket %s: TP1 TARGET HIT! Preparing for partial close and move to BE.", (string)ticket);

            double lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
            double min_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
            double volume_to_close_raw = volume * (InpPartialClosePercentage / 100.0);
            double close_volume = MathRound(volume_to_close_raw / lot_step) * lot_step;
            PrintFormat("[CALC] Ticket %s: Volume to close: Raw=%.4f, Rounded=%.2f (LotStep=%.2f)", (string)ticket, volume_to_close_raw, close_volume, lot_step);

            // اگر حجم باقی‌مانده کمتر از حداقل لات مجاز بود، کل پوزیشن را ببند
            if (volume - close_volume < min_lot && volume > min_lot)
            {
                close_volume = volume;
                PrintFormat("[ADJUST] Ticket %s: Remaining volume is less than min_lot. Adjusting to close full position.", (string)ticket);
            }

            if (close_volume >= min_lot)
            {
                PrintFormat("[TRADE] Ticket %s: Attempting to close %.2f lots...", (string)ticket, close_volume);
                if (trade.PositionClose(ticket, close_volume))
                {
                    PrintFormat("[SUCCESS] Ticket %s: Partial close successful!", (string)ticket);
                    action_taken = true;
                    // چک می‌کنیم آیا هنوز پوزیشنی باقی مانده است یا نه
                    if (PositionSelectByTicket(ticket))
                    {
                        PrintFormat("[TRADE] Ticket %s: Position still open. Attempting to move SL to Breakeven (%.5f)...", (string)ticket, entry_price);
                        if (trade.PositionModify(ticket, entry_price, current_tp)) // TP را تغییر نمی‌دهیم
                        {
                            PrintFormat("[SUCCESS] Ticket %s: SL moved to Breakeven successfully.", (string)ticket);
                        }
                        else
                        {
                            PrintFormat("[ERROR] Ticket %s: Failed to move SL to Breakeven. Error: %d", (string)ticket, trade.ResultRetcode());
                        }
                    }
                    else
                    {
                         PrintFormat("[INFO] Ticket %s: Full position was closed.", (string)ticket);
                    }
                }
                else
                {
                    PrintFormat("[ERROR] Ticket %s: Partial close failed! Error: %d", (string)ticket, trade.ResultRetcode());
                }
            }
            else
            {
                PrintFormat("[WARN] Ticket %s: Calculated close volume (%.2f) is less than min_lot (%.2f). No action taken.", (string)ticket, close_volume, min_lot);
            }
        }
        else
        {
             PrintFormat("[DEBUG] Ticket %s: TP1 target not yet hit. No partial close action.", (string)ticket);
        }
    }
    
    // ========================================================================================
    // بخش ۴: منطق تریلینگ استاپ (پس از خروج پله‌ای یا در صورت سودده بودن اجرا می‌شود)
    // ========================================================================================
    
    // اگر در این تیک، خروج پله‌ای انجام شده باشد، دیگر تریلینگ را چک نمی‌کنیم تا تیک بعدی
    if (action_taken)
    {
        PrintFormat("--- ManageActiveTrade END for Ticket: %s (Action was taken) ---", (string)ticket);
        return true;
    }

    // شرط شروع تریلینگ: یا باید در مرحله سر به سر باشیم، یا معامله در سود باشد
    bool profitable_enough_to_trail = (pos_type == POSITION_TYPE_BUY && SymbolInfoDouble(_Symbol, SYMBOL_BID) > entry_price) ||
                                      (pos_type == POSITION_TYPE_SELL && SymbolInfoDouble(_Symbol, SYMBOL_ASK) < entry_price);

    if (is_breakeven_stage || profitable_enough_to_trail)
    {
        PrintFormat("[LOGIC] Ticket %s: Position is ready for trailing. (IsBE: %s, IsProfitable: %s). Reading ATR...", 
                    (string)ticket, (is_breakeven_stage ? "Y" : "N"), (profitable_enough_to_trail ? "Y" : "N"));

        double atr_buffer[1];
        if (CopyBuffer(m_trail_atr_handle, 0, 1, 1, atr_buffer) == 1 && m_trail_atr_handle != INVALID_HANDLE)
        {
            double atr_value = atr_buffer[0];
            PrintFormat("[DATA] Ticket %s: ATR value read = %.5f", (string)ticket, atr_value);

            double trail_offset = atr_value * InpTrailingStopATRMultiplier;
            PrintFormat("[CALC] Ticket %s: Trail Offset = %.5f (ATR %.5f * Multiplier %.2f)", (string)ticket, trail_offset, atr_value, InpTrailingStopATRMultiplier);
            
            double new_sl = 0.0;
            if (pos_type == POSITION_TYPE_BUY)
            {
                new_sl = SymbolInfoDouble(_Symbol, SYMBOL_BID) - trail_offset;
            }
            else // SELL
            {
                new_sl = SymbolInfoDouble(_Symbol, SYMBOL_ASK) + trail_offset;
            }
            PrintFormat("[CALC] Ticket %s: New potential SL = %.5f", (string)ticket, new_sl);

            // شرط آپدیت استاپ لاس: استاپ جدید باید بهتر از استاپ فعلی باشد
            bool should_modify_sl = (pos_type == POSITION_TYPE_BUY && new_sl > current_sl) ||
                                    (pos_type == POSITION_TYPE_SELL && new_sl < current_sl && new_sl > 0);

            if (should_modify_sl)
            {
                PrintFormat("[ACTION] Ticket %s: New SL (%.5f) is better than Current SL (%.5f). Attempting to modify...", (string)ticket, new_sl, current_sl);
                if (trade.PositionModify(ticket, new_sl, current_tp))
                {
                    PrintFormat("[SUCCESS] Ticket %s: Trailing stop updated successfully.", (string)ticket);
                    action_taken = true;
                }
                else
                {
                    PrintFormat("[ERROR] Ticket %s: Failed to update trailing stop. Error: %d", (string)ticket, trade.ResultRetcode());
                }
            }
            else
            {
                PrintFormat("[DEBUG] Ticket %s: New SL is not better than current SL. No trailing action.", (string)ticket);
            }
        }
        else
        {
            PrintFormat("[ERROR] Ticket %s: Could not copy ATR buffer for trailing stop. Handle valid: %s.", (string)ticket, (m_trail_atr_handle != INVALID_HANDLE ? "Yes" : "No"));
        }
    }
    else
    {
        PrintFormat("[DEBUG] Ticket %s: Position is not yet profitable or at BE. No trailing logic executed.", (string)ticket);
    }
    
    PrintFormat("--- ManageActiveTrade END for Ticket: %s (Action taken: %s) ---", (string)ticket, (action_taken ? "YES" : "NO"));
    return action_taken;
}
private:
   //--- این تابع محدوده معتبر را شناسایی و اعتبارسنجی می‌کند. اگر ایچیموکو روشن باشد، از فیلتر پیشرفته استفاده می‌کند. این تابع پایه استراتژی است.
   bool              IdentifyValidRange(RangeData &rd)
     {
      rd.isValid = false; // پیش‌فرض نامعتبر تا چک کامل.

      datetime now = TimeCurrent(); // زمان فعلی سرور.
      MqlDateTime now_struct; // ساختار زمان.
      TimeToStruct(now,now_struct); // تبدیل به ساختار.

      MqlDateTime end_dt_struct = now_struct; // ساختار پایان.
      end_dt_struct.hour = m_end_hour; // تنظیم ساعت پایان.
      end_dt_struct.min = m_end_min; // تنظیم دقیقه پایان.
      end_dt_struct.sec = 0; // ثانیه صفر.
      datetime end_time = StructToTime(end_dt_struct); // تبدیل به datetime.

      MqlDateTime start_dt_struct = now_struct; // ساختار شروع.
      start_dt_struct.hour = m_start_hour; // تنظیم ساعت شروع.
      start_dt_struct.min = m_start_min; // تنظیم دقیقه شروع.
      start_dt_struct.sec = 0; // ثانیه صفر.
      datetime start_time = StructToTime(start_dt_struct); // تبدیل به datetime.

      if(m_start_hour > m_end_hour) // مدیریت جلسات شبانه (overnight) برای بازارهای ۲۴ ساعته.
        {
         if(now_struct.hour < m_end_hour) start_time -= 86400; // شروع به دیروز اگر شبانه.
         else end_time += 86400; // پایان به فردا.
        }
      
      rd.startTime = start_time; // ذخیره شروع برای ترسیم.
      rd.endTime = end_time; // ذخیره پایان.

      int start_bar_idx = iBarShift(_Symbol,m_timeframe,start_time,true); // ایندکس شروع (قدیمی‌ترین) با strict=true برای دقت.
      int end_bar_idx = iBarShift(_Symbol,m_timeframe,end_time,true); // ایندکس پایان (جدیدترین).

      if(start_bar_idx < 0 || end_bar_idx < 0) // اگر ایندکس نامعتبر (مثل داده ناکافی).
        {
         if(InpEnableLogging) Print("خطا در ایندکس بارها: شروع=" + IntegerToString(start_bar_idx) + ", پایان=" + IntegerToString(end_bar_idx) + " (جلسه " + IntegerToString(m_magic_number) + ")."); // لاگ.
         return false;
        }

      int bars_to_check = start_bar_idx - end_bar_idx + 1; // تعداد کندل‌ها در بازه.
      if(bars_to_check <= 0) // اگر تعداد نامعتبر (مثل زمان اشتباه).
        {
         if(InpEnableLogging) Print("خطا: تعداد بارها نامعتبر (" + IntegerToString(bars_to_check) + ") در جلسه " + IntegerToString(m_magic_number) + "."); // لاگ.
         return false;
        }

      if(InpUseIchimokuFilter) // اگر ایچیموکو فعال برای فیلتر پیشرفته.
        {
         int max_sequence = 0; // حداکثر سکانس متوالی تعادل.
         int current_sequence = 0; // سکانس فعلی.
         int sequence_start_idx = -1; // شروع سکانس فعلی.
         int best_start_idx = -1; // بهترین شروع برای طولانی‌ترین سکانس.

         for(int i = start_bar_idx; i >= end_bar_idx; i--) // حلقه از قدیمی به جدید برای پیدا کردن سکانس‌ها.
           {
            if(IsCandleInKumo(m_ichimoku_handle, i, m_timeframe) && IsKijunFlat(m_ichimoku_handle, i, m_timeframe)) // چک شرایط تعادل (داخل کومو و کیجون صاف).
              {
               if(current_sequence == 0) sequence_start_idx = i; // شروع جدید سکانس.
               current_sequence++; // افزایش سکانس.
              }
            else
              {
               if(current_sequence > max_sequence) // آپدیت اگر بهتر.
                 {
                  max_sequence = current_sequence;
                  best_start_idx = sequence_start_idx;
                 }
               current_sequence = 0; // ریست سکانس.
              }
           }
           
           if(current_sequence > max_sequence) // چک نهایی برای سکانس آخر اگر طولانی‌تر باشد.
             {
              max_sequence = current_sequence;
              best_start_idx = sequence_start_idx;
             }

           if(max_sequence >= InpMinConsecutiveCandles) // اگر سکانس معتبر (حداقل متوالی).
             {
              int high_bar_idx = iHighest(_Symbol,m_timeframe,MODE_HIGH,max_sequence,best_start_idx); // ایندکس High در سکانس.
              int low_bar_idx = iLowest(_Symbol,m_timeframe,MODE_LOW,max_sequence,best_start_idx); // ایندکس Low.
              
              if(high_bar_idx != -1 && low_bar_idx != -1) // اگر ایندکس معتبر.
                {
                 rd.rangeHigh = iHigh(_Symbol,m_timeframe,high_bar_idx); // High محدوده.
                 rd.rangeLow = iLow(_Symbol,m_timeframe,low_bar_idx); // Low محدوده.
                 rd.rangeSizePips = (rd.rangeHigh - rd.rangeLow) / _Point; // اندازه به پیپ.
                 rd.isValid = true; // معتبر کردن.
                 if(InpEnableLogging) Print("محدوده معتبر (ایچیموکو): High=" + DoubleToString(rd.rangeHigh, _Digits) + ", Low=" + DoubleToString(rd.rangeLow, _Digits) + ", اندازه=" + DoubleToString(rd.rangeSizePips, 2) + " (جلسه " + IntegerToString(m_magic_number) + ")."); // لاگ موفقیت.
                }
             }
        }
      else // منطق بدون ایچیموکو (ساده‌تر).
        {
         int high_bar_idx = iHighest(_Symbol,m_timeframe,MODE_HIGH,bars_to_check,end_bar_idx); // High کل بازه.
         int low_bar_idx = iLowest(_Symbol,m_timeframe,MODE_LOW,bars_to_check,end_bar_idx); // Low کل بازه.
         
         if(high_bar_idx != -1 && low_bar_idx != -1) // اگر معتبر.
           {
            rd.rangeHigh = iHigh(_Symbol,m_timeframe,high_bar_idx); // High.
            rd.rangeLow = iLow(_Symbol,m_timeframe,low_bar_idx); // Low.
            rd.rangeSizePips = (rd.rangeHigh - rd.rangeLow) / _Point; // اندازه.

            if(InpRangeFilterMode == MODE_POINTS) // حالت پوینت ثابت.
              {
               if(rd.rangeSizePips >= InpMinRangePoints && rd.rangeSizePips <= InpMaxRangePoints) rd.isValid = true; // چک اندازه.
              }
            else // حالت ATR دینامیک.
              {
               double atr_buffer[1]; // بافر ATR.
               if(CopyBuffer(m_range_atr_handle,0,1,1,atr_buffer) == 1) // خواندن ATR فعلی.
                 {
                  double atr_value = atr_buffer[0]; // مقدار ATR.
                  if(atr_value > 0) // اگر مثبت.
                    {
                     double min_allowed = (atr_value * InRangeATR_MinMultiplier) / _Point; // حداقل مجاز.
                     double max_allowed = (atr_value * InRangeATR_MaxMultiplier) / _Point; // حداکثر مجاز.
                     if(rd.rangeSizePips >= min_allowed && rd.rangeSizePips <= max_allowed) rd.isValid = true; // چک.
                    }
                 }
               else 
                {
                 if(InpEnableLogging) Print("خطا در کپی بافر ATR اعتبارسنجی (جلسه " + IntegerToString(m_magic_number) + ")."); // لاگ.
                }
              }

            if(rd.isValid && InpEnableLogging) Print("محدوده معتبر (غیرایچیموکو): High=" + DoubleToString(rd.rangeHigh, _Digits) + ", Low=" + DoubleToString(rd.rangeLow, _Digits) + ", اندازه=" + DoubleToString(rd.rangeSizePips, 2) + " (جلسه " + IntegerToString(m_magic_number) + ")."); // لاگ.
           }
        }
      return rd.isValid; // بازگشت وضعیت اعتبار برای ادامه فرآیند.
     }

   //--- این تابع تحلیل محدوده را انجام داده و در صورت معتبر بودن، سفارشات را قرار می‌دهد. این تابع هسته جلسه است.
   void              AnalyzeAndPlaceOrders(void)
     {
      RangeData rd; // ساختار محدوده برای نگهداری داده‌ها.
      if(!IdentifyValidRange(rd)) // اگر نامعتبر.
        {
         if(InpEnableLogging) Print("محدوده نامعتبر در جلسه " + IntegerToString(m_magic_number) + ". تحلیل متوقف شد."); // لاگ.
         return; // خارج.
        }

      DrawRangeOnChart(rd,m_magic_number); // ترسیم محدوده روی چارت برای visualization.

      bool is_trend_on = InpTrendFilterIsOn; // وضعیت روند از تنظیمات.
      bool is_uptrend = false; // جهت روند پیش‌فرض.

      if(is_trend_on) // اگر فعال.
        {
         double ema_buffer[1]; // بافر EMA.
         if(CopyBuffer(m_ema_handle,0,1,1,ema_buffer) == 1) // خواندن EMA فعلی.
           {
            double current_price = SymbolInfoDouble(_Symbol,SYMBOL_BID); // قیمت فعلی Bid.
            is_uptrend = current_price > ema_buffer[0]; // چک جهت (بالای EMA صعودی).
            if(InpEnableLogging) Print("فیلتر روند: " + (is_uptrend ? "صعودی" : "نزولی") + " (قیمت=" + DoubleToString(current_price, _Digits) + ", EMA=" + DoubleToString(ema_buffer[0], _Digits) + ") در جلسه " + IntegerToString(m_magic_number) + "."); // لاگ.
           }
         else 
          {
           if(InpEnableLogging) Print("خطا در کپی بافر EMA در جلسه " + IntegerToString(m_magic_number) + "."); // لاگ.
          }
        }

      double atr_buffer[1]; // بافر ATR قرارگیری.
      if(CopyBuffer(m_placement_atr_handle,0,1,1,atr_buffer) != 1) // خواندن ATR.
        {
         if(InpEnableLogging) Print("خطا در کپی بافر ATR قرارگیری در جلسه " + IntegerToString(m_magic_number) + "."); // لاگ.
         return;
        }
      double atr_value = atr_buffer[0]; // مقدار ATR.
      double buffer = atr_value * InpAtrMultiplier_Placement; // بافر دینامیک برای جلوگیری از فعال شدن زودرس.

      double buy_stop_price = rd.rangeHigh + buffer; // قیمت BuyStop.
      double sell_stop_price = rd.rangeLow - buffer; // قیمت SellStop.

      double current_bid = SymbolInfoDouble(_Symbol,SYMBOL_BID); // Bid فعلی.
      double current_ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK); // Ask فعلی.
      if((is_trend_on && is_uptrend && current_ask >= buy_stop_price) ||  // Safety check برای خرید (اگر قبلاً عبور کرده).
         (is_trend_on && !is_uptrend && current_bid <= sell_stop_price) || // برای فروش.
         (!is_trend_on && (current_ask >= buy_stop_price || current_bid <= sell_stop_price))) // بدون روند.
         {
          if(InpEnableLogging) Print("Safety check: قیمت قبلاً از محدوده عبور کرده - سفارش قرار نمی‌گیرد (جلسه " + IntegerToString(m_magic_number) + ")."); // لاگ.
          return; // اگر عبور کرده، سفارش نگذار تا false breakout جلوگیری شود.
         }

      PlacePendingOrders(m_magic_number,is_trend_on,is_uptrend,rd,buy_stop_price,sell_stop_price); // قرارگیری سفارشات.
     }

   //--- این تابع چک می‌کند آیا دو تاریخ در یک روز هستند. برای جلوگیری از تحلیل تکراری روزانه استفاده می‌شود و سیستم را بهینه نگه می‌دارد.
   bool              IsSameDay(datetime d1,datetime d2)
     {
      MqlDateTime s1,s2; // ساختارها برای شکستن زمان.
      TimeToStruct(d1,s1); // تبدیل d1 به ساختار (سال، ماه، روز و غیره).
      TimeToStruct(d2,s2); // تبدیل d2 به ساختار.
      return (s1.year == s2.year && s1.mon == s2.mon && s1.day == s2.day); // مقایسه سال، ماه و روز برای تعیین یکسان بودن روز.
     }
  };

#endif //SESSIONTRADER_MQH











