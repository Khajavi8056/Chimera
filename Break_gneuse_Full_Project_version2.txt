//+------------------------------------------------------------------+
//|                                             SessionTrader.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy"
#property link      "https://..."

//--- این گارد از include شدن چندباره فایل در پروژه جلوگیری می‌کند و کد را ایمن نگه می‌دارد.
#ifndef SESSIONTRADER_MQH 
#define SESSIONTRADER_MQH 

#include "Settings.mqh"     // کتابخانه تنظیمات ورودی کاربر.
#include "RangeLib.mqh"     // کتابخانه توابع کمکی برای تحلیل محدوده.
#include "TradeManager.mqh" // کتابخانه مدیریت معاملات و ریسک.
#include <Trade\PositionInfo.mqh> // برای اطلاعات پوزیشن‌ها مانند قیمت، حجم و استاپ لاس.
#include <Trade\TerminalInfo.mqh> // برای اطلاعات ترمینال و مدیریت خطاها.
#include <Arrays\ArrayObj.mqh> // برای مدیریت پوزیشن‌ها در یک آرایه.

//+------------------------------------------------------------------+
//| ENUM برای مدیریت مراحل معامله                                      |
//+------------------------------------------------------------------+
enum ENUM_TRADE_STAGE
{
   STAGE_ONE,   // معامله تازه باز شده و منتظر تارگت اول است.
   STAGE_TWO,   // مرحله اول انجام شده و SL به Breakeven منتقل شده.
   STAGE_THREE  // مرحله Breakeven انجام شده و اکنون در حالت ترلینگ استاپ است.
};

//+------------------------------------------------------------------+
//| STRUCT برای نگهداری وضعیت هر پوزیشن                                |
//+------------------------------------------------------------------+
struct PositionState
{
   ulong             ticket;      // تیکت منحصر به فرد پوزیشن.
   ENUM_TRADE_STAGE  stage;       // مرحله فعلی مدیریت پوزیشن.
   double            initial_sl;  // قیمت استاپ لاس اولیه برای محاسبه تارگت اول.
};

//+------------------------------------------------------------------+
//| Class CSessionTrader                                             |
//+------------------------------------------------------------------+
//--- این کلاس، منطق کامل یک جلسه معاملاتی را کپسوله می‌کند.
class CSessionTrader
  {
private:
   // --- متغیرهای پیکربندی ---
   bool              m_is_active;
   int               m_magic_number;
   ENUM_TIMEFRAMES   m_timeframe;
   int               m_start_hour, m_start_min;
   int               m_end_hour, m_end_min;
   int               m_expiry_hour, m_expiry_min;
   
   // --- هندل‌های اندیکاتور ---
   int               m_ichimoku_handle;
   int               m_placement_atr_handle;
   int               m_range_atr_handle;
   int               m_ema_handle;
   int               m_trail_atr_handle;

   // --- متغیرهای وضعیت ---
   datetime          m_last_analysis_date;
   CArrayObj         m_active_positions; // آرایه برای نگهداری پوزیشن‌های فعال این جلسه.
   
public:
   //--- سازنده کلاس.
                     CSessionTrader(void) : m_is_active(false), m_magic_number(0), m_timeframe(PERIOD_M15),
                     m_start_hour(0),m_start_min(0), m_end_hour(0),m_end_min(0), m_expiry_hour(0),m_expiry_min(0),
                     m_ichimoku_handle(INVALID_HANDLE), m_placement_atr_handle(INVALID_HANDLE), m_range_atr_handle(INVALID_HANDLE),
                     m_ema_handle(INVALID_HANDLE), m_trail_atr_handle(INVALID_HANDLE), m_last_analysis_date(0) {}

   //--- تابع Init: برای مقداردهی اولیه کلاس با پارامترهای ورودی.
   void              Init(bool is_active,ENUM_TIMEFRAMES timeframe,int start_h,int start_m,int end_h,int end_m,int expiry_h,int expiry_m,int magic)
     {
      m_is_active = is_active;
      m_timeframe = timeframe;
      m_start_hour = start_h;
      m_start_min = start_m;
      m_end_hour = end_h;
      m_end_min = end_m;
      m_expiry_hour = expiry_h;
      m_expiry_min = expiry_m;
      m_magic_number = magic;
      
      if(!m_is_active) return;

      m_ichimoku_handle = iIchimoku(_Symbol,m_timeframe,InpIchimoku_Tenkan,InpIchimoku_Kijun,InpIchimoku_Senkou);
      if(m_ichimoku_handle == INVALID_HANDLE) if(InpEnableLogging) Print("خطا در ایجاد هندل ایچیموکو برای جلسه " + IntegerToString(magic) + ".");

      m_placement_atr_handle = iATR(_Symbol,m_timeframe,InRangeATR_Period);
      if(m_placement_atr_handle == INVALID_HANDLE) if(InpEnableLogging) Print("خطا در ایجاد هندل ATR قرارگیری برای جلسه " + IntegerToString(magic) + ".");

      m_range_atr_handle = iATR(_Symbol,InRangeATR_TimeFrame,InRangeATR_Period);
      if(m_range_atr_handle == INVALID_HANDLE) if(InpEnableLogging) Print("خطا در ایجاد هندل ATR اعتبارسنجی برای جلسه " + IntegerToString(magic) + ".");

      m_ema_handle = iMA(_Symbol,InpTrendEMATimeFrame,InpTrendEMAPeriod,0,MODE_EMA,InpTrendEMAAppliedPrice);
      if(m_ema_handle == INVALID_HANDLE) if(InpEnableLogging) Print("خطا در ایجاد هندل EMA برای جلسه " + IntegerToString(magic) + ".");

      m_trail_atr_handle = iATR(_Symbol,InpTrailingStopATRTimeFrame,InpTrailingStopATRPeriod);
      if(m_trail_atr_handle == INVALID_HANDLE) if(InpEnableLogging) Print("خطا در ایجاد هندل ATR ترلینگ برای جلسه " + IntegerToString(magic) + ".");

      if(InpEnableLogging) Print("جلسه " + IntegerToString(magic) + " اولیه‌سازی شد.");
     }

   //--- تابع Deinit: برای آزادسازی منابع در زمان حذف اکسپرت.
   void              Deinit(void)
     {
      if(m_ichimoku_handle != INVALID_HANDLE) IndicatorRelease(m_ichimoku_handle);
      if(m_placement_atr_handle != INVALID_HANDLE) IndicatorRelease(m_placement_atr_handle);
      if(m_range_atr_handle != INVALID_HANDLE) IndicatorRelease(m_range_atr_handle);
      if(m_ema_handle != INVALID_HANDLE) IndicatorRelease(m_ema_handle);
      if(m_trail_atr_handle != INVALID_HANDLE) IndicatorRelease(m_trail_atr_handle);
      ObjectsDeleteAll(0,"Range_"+IntegerToString(m_magic_number)+"_");
      m_active_positions.Clear(); // پاک کردن آرایه پوزیشن‌های فعال.

      if(InpEnableLogging) Print("جلسه " + IntegerToString(m_magic_number) + " خاتمه یافت.");
     }

   //--- تابع OnTimerUpdate: هر ۶۰ ثانیه فراخوانی می‌شود برای تحلیل و پاکسازی.
   void              OnTimerUpdate(void)
     {
      if(!m_is_active) return;

      datetime now = TimeCurrent();
      MqlDateTime now_struct;
      TimeToStruct(now,now_struct);

      //--- چک زمان انقضا برای پاکسازی پوزیشن‌ها و سفارشات.
      if(now_struct.hour == m_expiry_hour && now_struct.min == m_expiry_min)
        {
         SessionCleanUp(m_magic_number);
         if(InpEnableLogging) Print("انقضای جلسه " + IntegerToString(m_magic_number) + " رسید و پاکسازی انجام شد.");
         return;
        }

      MqlDateTime end_dt_struct = now_struct;
      end_dt_struct.hour = m_end_hour;
      end_dt_struct.min = m_end_min;
      end_dt_struct.sec = 0;
      datetime analysis_time = StructToTime(end_dt_struct);

      //--- چک زمان تحلیل و جلوگیری از تکرار در یک روز.
      if(now >= analysis_time && !IsSameDay(m_last_analysis_date,now))
        {
         AnalyzeAndPlaceOrders();
         m_last_analysis_date = now;
         if(InpEnableLogging) Print("تحلیل جلسه " + IntegerToString(m_magic_number) + " در زمان " + TimeToString(now) + " انجام شد.");
        }
     }

   //--- تابع GetMagicNumber: مجیک نامبر جلسه را برمی‌گرداند.
   int               GetMagicNumber(void) { return m_magic_number; }

   //--- تابع OnNewTrade: اضافه کردن پوزیشن جدید به لیست مدیریت.
   void              OnNewTrade(ulong ticket, double initial_sl)
     {
      PositionState *state = new PositionState();
      state.ticket = ticket;
      state.stage = STAGE_ONE;
      state.initial_sl = initial_sl;
      if (m_active_positions.Add(state))
         if(InpEnableLogging) Print("پوزیشن جدید با تیکت " + IntegerToString(ticket) + " به لیست مدیریت اضافه شد.");
     }

   //--- تابع ManageActiveTrade: مدیریت مراحل مختلف یک پوزیشن.
   bool              ManageActiveTrade(ulong ticket)
     {
      //--- پیدا کردن وضعیت پوزیشن در آرایه.
      PositionState *state = FindPositionState(ticket);
      if(state == NULL) return false;

      //--- انتخاب پوزیشن برای دسترسی به اطلاعات.
      if(!PositionSelectByTicket(ticket)) return false;

      //--- خواندن اطلاعات پوزیشن.
      ENUM_POSITION_TYPE pos_type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      double entry_price = PositionGetDouble(POSITION_PRICE_OPEN);
      double current_sl = PositionGetDouble(POSITION_SL);
      double volume = PositionGetDouble(POSITION_VOLUME);
      double current_price = (pos_type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      
      //--- منطق مدیریت پوزیشن بر اساس مرحله فعلی.
      switch(state.stage)
      {
         case STAGE_ONE:
         {
            if(!InpEnablePartialClose) return false; // اگر خروج پله‌ای غیرفعال است، از این مرحله عبور کن.

            //--- محاسبه قیمت هدف برای خروج پله‌ای.
            double sl_initial_pips = (pos_type == POSITION_TYPE_BUY) ? (entry_price - state.initial_sl) / _Point : (state.initial_sl - entry_price) / _Point;
            double tp_target_pips = sl_initial_pips * InpTakeProfitRatio_Stage1;
            double tp_target_price = (pos_type == POSITION_TYPE_BUY) ? entry_price + tp_target_pips * _Point : entry_price - tp_target_pips * _Point;

            //--- چک رسیدن به تارگت اول.
            if ((pos_type == POSITION_TYPE_BUY && current_price >= tp_target_price) || (pos_type == POSITION_TYPE_SELL && current_price <= tp_target_price))
            {
               //--- بستن پله‌ای.
               double lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
               double min_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
               double volume_to_close_raw = volume * (InpPartialClosePercentage / 100.0);
               double close_volume = MathRound(volume_to_close_raw / lot_step) * lot_step;
               if (volume - close_volume < min_lot) close_volume = volume;

               if (trade.PositionClose(ticket, close_volume))
               {
                  if(InpEnableLogging) Print("خروج پله‌ای موفق: تیکت=" + IntegerToString(ticket) + ", حجم بسته‌شده=" + DoubleToString(close_volume, 2) + ".");
                  state.stage = STAGE_TWO; // تغییر مرحله به Breakeven.
                  return true;
               }
            }
            break;
         }
         case STAGE_TWO:
         {
            //--- انتقال استاپ به نقطه ورود (Breakeven).
            if((pos_type == POSITION_TYPE_BUY && current_sl < entry_price) || (pos_type == POSITION_TYPE_SELL && current_sl > entry_price))
            {
               if(trade.PositionModify(ticket, entry_price, 0.0))
               {
                  if(InpEnableLogging) Print("استاپ به breakeven منتقل شد: تیکت=" + IntegerToString(ticket) + ".");
                  state.stage = STAGE_THREE; // تغییر مرحله به ترلینگ.
                  return true;
               }
            } else {
               state.stage = STAGE_THREE; // اگر از قبل روی Breakeven بود، به مرحله بعد برو.
               return true;
            }
            break;
         }
         case STAGE_THREE:
         {
            //--- اجرای ترلینگ استاپ.
            double atr_buffer[1];
            if(CopyBuffer(m_trail_atr_handle, 0, 1, 1, atr_buffer) != 1) return false;
            double trail_offset = atr_buffer[0] * InpTrailingStopATRMultiplier;
            double new_sl = (pos_type == POSITION_TYPE_BUY) ? current_price - trail_offset : current_price + trail_offset;
            
            //--- اطمینان از اینکه استاپ جدید بهتر از فعلی است.
            if ((pos_type == POSITION_TYPE_BUY && new_sl > current_sl) || (pos_type == POSITION_TYPE_SELL && new_sl < current_sl))
            {
               if(trade.PositionModify(ticket, new_sl, 0.0))
               {
                  if(InpEnableLogging) Print("ترلینگ استاپ بروزرسانی شد: SL جدید=" + DoubleToString(new_sl, _Digits) + ", تیکت=" + IntegerToString(ticket) + ".");
                  return true;
               }
            }
            break;
         }
      }

      return false;
     }

   //--- تابع RemoveClosedPosition: حذف پوزیشن بسته شده از لیست.
   void              RemoveClosedPosition(ulong ticket)
     {
      for(int i = m_active_positions.Total() - 1; i >= 0; i--)
      {
         PositionState *state = (PositionState*)m_active_positions.At(i);
         if(state != NULL && state.ticket == ticket)
         {
            m_active_positions.Delete(i);
            delete state;
            if(InpEnableLogging) Print("پوزیشن با تیکت " + IntegerToString(ticket) + " از لیست مدیریت حذف شد.");
            return;
         }
      }
     }

private:
   //--- تابع کمکی برای پیدا کردن وضعیت پوزیشن در آرایه.
   PositionState* FindPositionState(ulong ticket)
     {
      for(int i = 0; i < m_active_positions.Total(); i++)
      {
         PositionState *state = (PositionState*)m_active_positions.At(i);
         if(state != NULL && state.ticket == ticket) return state;
      }
      return NULL;
     }

   //--- تابع IdentifyValidRange: محدوده معتبر را شناسایی و اعتبارسنجی می‌کند.
   bool              IdentifyValidRange(RangeData &rd)
     {
      rd.isValid = false;
      
      datetime now = TimeCurrent();
      MqlDateTime now_struct;
      TimeToStruct(now,now_struct);

      MqlDateTime end_dt_struct = now_struct;
      end_dt_struct.hour = m_end_hour;
      end_dt_struct.min = m_end_min;
      end_dt_struct.sec = 0;
      datetime end_time = StructToTime(end_dt_struct);

      MqlDateTime start_dt_struct = now_struct;
      start_dt_struct.hour = m_start_hour;
      start_dt_struct.min = m_start_min;
      start_dt_struct.sec = 0;
      datetime start_time = StructToTime(start_dt_struct);

      if(m_start_hour > m_end_hour)
        {
         if(now_struct.hour < m_end_hour) start_time -= 86400;
         else end_time += 86400;
        }
      
      rd.startTime = start_time;
      rd.endTime = end_time;

      int start_bar_idx = iBarShift(_Symbol,m_timeframe,start_time,true);
      int end_bar_idx = iBarShift(_Symbol,m_timeframe,end_time,true);

      if(start_bar_idx < 0 || end_bar_idx < 0) return false;

      int bars_to_check = start_bar_idx - end_bar_idx + 1;
      if(bars_to_check <= 0) return false;

      if(InpUseIchimokuFilter)
        {
         int max_sequence = 0;
         int current_sequence = 0;
         int sequence_start_idx = -1;
         int best_start_idx = -1;

         for(int i = start_bar_idx; i >= end_bar_idx; i--)
           {
            if(IsCandleInKumo(m_ichimoku_handle, i, m_timeframe) && IsKijunFlat(m_ichimoku_handle, i, m_timeframe))
              {
               if(current_sequence == 0) sequence_start_idx = i;
               current_sequence++;
              }
            else
              {
               if(current_sequence > max_sequence)
                 {
                  max_sequence = current_sequence;
                  best_start_idx = sequence_start_idx;
                 }
               current_sequence = 0;
              }
           }
           
           if(current_sequence > max_sequence)
             {
              max_sequence = current_sequence;
              best_start_idx = sequence_start_idx;
             }
           
           if(max_sequence >= InpMinConsecutiveCandles)
             {
              int high_bar_idx = iHighest(_Symbol,m_timeframe,MODE_HIGH,max_sequence,best_start_idx);
              int low_bar_idx = iLowest(_Symbol,m_timeframe,MODE_LOW,max_sequence,best_start_idx);
              
              if(high_bar_idx != -1 && low_bar_idx != -1)
                {
                 rd.rangeHigh = iHigh(_Symbol,m_timeframe,high_bar_idx);
                 rd.rangeLow = iLow(_Symbol,m_timeframe,low_bar_idx);
                 rd.rangeSizePips = (rd.rangeHigh - rd.rangeLow) / _Point;
                 if (IsRangeSizeValid(rd.rangeSizePips)) rd.isValid = true;
                }
             }
        }
      else
        {
         int high_bar_idx = iHighest(_Symbol,m_timeframe,MODE_HIGH,bars_to_check,end_bar_idx);
         int low_bar_idx = iLowest(_Symbol,m_timeframe,MODE_LOW,bars_to_check,end_bar_idx);
         
         if(high_bar_idx != -1 && low_bar_idx != -1)
           {
            rd.rangeHigh = iHigh(_Symbol,m_timeframe,high_bar_idx);
            rd.rangeLow = iLow(_Symbol,m_timeframe,low_bar_idx);
            rd.rangeSizePips = (rd.rangeHigh - rd.rangeLow) / _Point;
            if (IsRangeSizeValid(rd.rangeSizePips)) rd.isValid = true;
           }
        }
      return rd.isValid;
     }

   //--- تابع AnalyzeAndPlaceOrders: محدوده را تحلیل و سفارشات را قرار می‌دهد.
   void              AnalyzeAndPlaceOrders(void)
     {
      RangeData rd;
      if(!IdentifyValidRange(rd))
        {
         if(InpEnableLogging) Print("محدوده نامعتبر در جلسه " + IntegerToString(m_magic_number) + ". تحلیل متوقف شد.");
         return;
        }

      DrawRangeOnChart(rd,m_magic_number);

      bool is_trend_on = InpTrendFilterIsOn;
      bool is_uptrend = false;

      if(is_trend_on)
        {
         double ema_buffer[1];
         if(CopyBuffer(m_ema_handle,0,1,1,ema_buffer) == 1)
           {
            double current_price = SymbolInfoDouble(_Symbol,SYMBOL_BID);
            is_uptrend = (current_price > ema_buffer[0]); // استفاده از پرانتز برای وضوح
            if(InpEnableLogging) Print("فیلتر روند: " + (is_uptrend ? "صعودی" : "نزولی") + " (قیمت=" + DoubleToString(current_price, _Digits) + ", EMA=" + DoubleToString(ema_buffer[0], _Digits) + ") در جلسه " + IntegerToString(m_magic_number) + ".");
           }
         else
          {
           if(InpEnableLogging) Print("خطا در کپی بافر EMA در جلسه " + IntegerToString(m_magic_number) + ".");
          }
        }

      double atr_buffer[1];
      if(CopyBuffer(m_placement_atr_handle,0,1,1,atr_buffer) != 1)
        {
         if(InpEnableLogging) Print("خطا در کپی بافر ATR قرارگیری در جلسه " + IntegerToString(m_magic_number) + ".");
         return;
        }
      double atr_value = atr_buffer[0];
      double buffer = atr_value * InpAtrMultiplier_Placement;

      double buy_stop_price = rd.rangeHigh + buffer;
      double sell_stop_price = rd.rangeLow - buffer;

      double current_bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
      double current_ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
      if((is_trend_on && is_uptrend && current_ask >= buy_stop_price) ||
         (is_trend_on && !is_uptrend && current_bid <= sell_stop_price) ||
         (!is_trend_on && (current_ask >= buy_stop_price || current_bid <= sell_stop_price)))
         {
          if(InpEnableLogging) Print("Safety check: قیمت قبلاً از محدوده عبور کرده - سفارش قرار نمی‌گیرد (جلسه " + IntegerToString(m_magic_number) + ").");
          return;
         }

      PlacePendingOrders(m_magic_number,is_trend_on,is_uptrend,rd,buy_stop_price,sell_stop_price);
     }

   //--- تابع IsSameDay: چک می‌کند آیا دو تاریخ در یک روز هستند.
   bool              IsSameDay(datetime d1,datetime d2)
     {
      MqlDateTime s1,s2;
      TimeToStruct(d1,s1);
      TimeToStruct(d2,s2);
      return (s1.year == s2.year && s1.mon == s2.mon && s1.day == s2.day);
     }

   //--- تابع کمکی برای چک اعتبار اندازه محدوده.
   bool IsRangeSizeValid(double range_size_pips)
     {
      if (InpRangeFilterMode == MODE_POINTS)
      {
         return (range_size_pips >= InpMinRangePoints && range_size_pips <= InpMaxRangePoints);
      }
      else if (InpRangeFilterMode == MODE_ATR)
      {
         double atr_buffer[1];
         if (CopyBuffer(m_range_atr_handle, 0, 1, 1, atr_buffer) == 1)
         {
            double atr_value = atr_buffer[0];
            if (atr_value > 0)
            {
               double min_allowed = (atr_value * InRangeATR_MinMultiplier) / _Point;
               double max_allowed = (atr_value * InRangeATR_MaxMultiplier) / _Point;
               return (range_size_pips >= min_allowed && range_size_pips <= max_allowed);
            }
         }
      }
      return false;
     }
  };

#endif //SESSIONTRADER_MQH
