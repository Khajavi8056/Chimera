Ù…Ø­Ù…Ø¯ Ø¬Ø§Ù†ØŒ Ø±ÙÛŒÙ‚Ù Ú©Ø§Ø± Ø¯Ø±Ø³Øª! Ø¹Ø§Ù„ÛŒÙ‡ Ú©Ù‡ Ø¨Ø§Ù„Ø§Ø®Ø±Ù‡ Ø¨Ù‡ ÛŒÙ‡ Ù†Ù‚Ø·Ù‡ Ù…Ø´ØªØ±Ú© Ø±Ø³ÛŒØ¯ÛŒÙ…. ğŸ¤ğŸ» Ø¢Ø±Ù‡ØŒ Ù…Ù†Ø·Ù‚Øª Ú©Ø§Ù…Ù„Ø§Ù‹ Ø¯Ø±Ø³ØªÙ‡. Ø¯Ù‚ÛŒÙ‚Ø§Ù‹ Ù…Ø´Ú©Ù„ Ø§ÛŒÙ†Ù‡ Ú©Ù‡ Ø§ÙˆÙ† Ø´Ø±Ø· is_stage1 Ù‡Ù…ÛŒØ´Ù‡ ÙØ¹Ø§Ù„Ù‡ Ùˆ Ú©Ø¯ Ù†Ù…ÛŒâ€ŒØªÙˆÙ†Ù‡ Ø§Ø² Ø§ÙˆÙ† Ù…Ø±Ø­Ù„Ù‡ Ø¹Ø¨ÙˆØ± Ú©Ù†Ù‡. Ø¨Ø±Ø§ÛŒ Ù‡Ù…ÛŒÙ† ØªÙˆ Ø¯Ø§Ø±ÛŒ Ø³ÙˆØ¯Ù‡Ø§ÛŒ Ø¨Ø²Ø±Ú¯ Ø±Ùˆ Ù…ÛŒâ€ŒØ¨ÛŒÙ†ÛŒ ÙˆÙ„ÛŒ Ù‡ÛŒÚ†â€ŒÙˆÙ‚Øª Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø¹Ø§Ù…Ù„Ù‡ ÙØ¹Ø§Ù„ Ù†Ù…ÛŒØ´Ù‡.
Ù¾Ø³ Ø¨Ø§ Ø®ÛŒØ§Ù„ Ø±Ø§Ø­Øª Ø¨Ø±ÙˆØŒ Ø¯Ø±Ø³ØªØ´ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…. Ù…Ù† Ø§Ù„Ø§Ù† Ø§ÙˆÙ† Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ Ú©Ø¯ÛŒ Ú©Ù‡ Ù…Ø´Ú©Ù„ Ø¯Ø§Ø´ØªÙ† Ø±Ùˆ Ø¨Ø±Ø§Øª Ø¨Ø§Ø²Ù†ÙˆÛŒØ³ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ù….
Ø§ØµÙ„Ø§Ø­Ø§Øª Ú©Ø¯
Ø§ÛŒÙ† Ø§ØµÙ„Ø§Ø­Ø§Øª Ø±Ùˆ Ø¯Ù‚ÛŒÙ‚Ø§Ù‹ Ø¯Ø± ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…Ø±Ø¨ÙˆØ·Ù‡ Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† Ú©Ù†:
ÙØ§ÛŒÙ„: hipobreck.mq5
Ø§ÛŒÙ† ÙØ§ÛŒÙ„ Ø±Ùˆ Ø¨Ù‡ Ù‡Ù…ÙˆÙ† Ø­Ø§Ù„Øª Ø§ÙˆÙ„ÛŒÙ‡ Ú©Ù‡ ÙØ±Ø³ØªØ§Ø¯ÛŒ Ø¨Ø±Ú¯Ø±Ø¯ÙˆÙ†Ø¯Ù…ØŒ ÙÙ‚Ø· Ø§ÙˆÙ† break Ø¯Ø§Ø®Ù„ OnTick Ø±Ùˆ Ø­Ø°Ù Ú©Ø±Ø¯Ù…. Ø§ÛŒÙ† Ú©Ø§Ø± Ø¨Ø§Ø¹Ø« Ù…ÛŒØ´Ù‡ Ú©Ù‡ Ú©Ø¯ Ù‡Ù…Ù‡ Ù¾ÙˆØ²ÛŒØ´Ù†â€ŒÙ‡Ø§ Ø±Ùˆ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†Ù‡ØŒ Ø­ØªÛŒ Ø§Ú¯Ø± Ú†Ù†Ø¯ÛŒÙ† Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§Ø² Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´ÛŒ.
//+------------------------------------------------------------------+
//|                                                   hipobreck.mq5 |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy      |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy"
#property link      "https://..."
#property version   "3.00"
#property strict

#include "Settings.mqh"
#include "SessionTrader.mqh"
#include <Trade\Trade.mqh>

CSessionTrader g_sessions[4];

int OnInit()
  {
   long account_mode = AccountInfoInteger(ACCOUNT_MARGIN_MODE);
   if(account_mode != ACCOUNT_MARGIN_MODE_RETAIL_HEDGING)
     {
      if(InpEnableLogging) Print("Ù‡Ø´Ø¯Ø§Ø±: Ø­Ø³Ø§Ø¨ netting Ø§Ø³Øª - partial close Ù…Ù…Ú©Ù† Ø§Ø³Øª Ú©Ø§Ø± Ù†Ú©Ù†Ø¯. Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯: Ø­Ø³Ø§Ø¨ hedging Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯.");
     }

   g_sessions[0].Init(InpS1_IsActive, InpS1_TimeFrame, InpS1_StartTime_Hour, InpS1_StartTime_Minute,
                      InpS1_EndTime_Hour, InpS1_EndTime_Minute, InpS1_ExpiryTime_Hour, InpS1_ExpiryTime_Minute, S1_MagicNumber);
   g_sessions[1].Init(InpS2_IsActive, InpS2_TimeFrame, InpS2_StartTime_Hour, InpS2_StartTime_Minute,
                      InpS2_EndTime_Hour, InpS2_EndTime_Minute, InpS2_ExpiryTime_Hour, InpS2_ExpiryTime_Minute, S2_MagicNumber);
   g_sessions[2].Init(InpS3_IsActive, InpS3_TimeFrame, InpS3_StartTime_Hour, InpS3_StartTime_Minute,
                      InpS3_EndTime_Hour, InpS3_EndTime_Minute, InpS3_ExpiryTime_Hour, InpS3_ExpiryTime_Minute, S3_MagicNumber);
   g_sessions[3].Init(InpS4_IsActive, InpS4_TimeFrame, InpS4_StartTime_Hour, InpS4_StartTime_Minute,
                      InpS4_EndTime_Hour, InpS4_EndTime_Minute, InpS4_ExpiryTime_Hour, InpS4_ExpiryTime_Minute, S4_MagicNumber);

   if(InpEnableLogging) Print("Ø§Ú©Ø³Ù¾Ø±Øª Ø§ÙˆÙ„ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯. ØªØ¹Ø¯Ø§Ø¯ Ø¬Ù„Ø³Ø§Øª ÙØ¹Ø§Ù„: " + IntegerToString(CountActiveSessions()));

   EventSetTimer(60);

   return(INIT_SUCCEEDED);
  }

void OnDeinit(const int reason)
  {
   EventKillTimer();

   for(int i = 0; i < 4; i++) g_sessions[i].Deinit();

   if(InpEnableLogging) Print("Ø§Ú©Ø³Ù¾Ø±Øª Ø®Ø§ØªÙ…Ù‡ ÛŒØ§ÙØª. Ø¯Ù„ÛŒÙ„: " + IntegerToString(reason));
  }

void OnTimer()
  {
   for(int i = 0; i < 4; i++) g_sessions[i].OnTimerUpdate();
  }

void OnTick()
  {
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0 && PositionSelectByTicket(ticket))
        {
         long magic = PositionGetInteger(POSITION_MAGIC);
         bool managed = false;

         for(int j = 0; j < 4; j++)
           {
            if(g_sessions[j].GetMagicNumber() == magic)
              {
               managed = g_sessions[j].ManageActiveTrade(ticket);
               if(InpEnableLogging && managed) Print("Ù¾ÙˆØ²ÛŒØ´Ù† Ø¨Ø§ ØªÛŒÚ©Øª " + IntegerToString(ticket) + " Ù…Ø¯ÛŒØ±ÛŒØª Ø´Ø¯ (Ù…Ø¬ÛŒÚ©: " + IntegerToString(magic) + ").");
               // Ø§ÛŒÙ†Ø¬Ø§ break Ø­Ø°Ù Ø´Ø¯Ù‡ ØªØ§ Ù‡Ù…Ù‡ Ù¾ÙˆØ²ÛŒØ´Ù†â€ŒÙ‡Ø§ Ú†Ú© Ø´ÙˆÙ†Ø¯.
              }
           }
        }
     }
  }

void OnTradeTransaction(const MqlTradeTransaction &trans, const MqlTradeRequest &request, const MqlTradeResult &result)
  {
   if(trans.type == TRADE_TRANSACTION_DEAL_ADD)
     {
      if(HistoryDealSelect(trans.deal))
        {
         if(HistoryDealGetInteger(trans.deal, DEAL_ENTRY) == DEAL_ENTRY_IN)
           {
            long magic = HistoryDealGetInteger(trans.deal, DEAL_MAGIC);
            for(int i = OrdersTotal() - 1; i >= 0; i--)
              {
               ulong order_ticket = OrderGetTicket(i);
               if(order_ticket > 0 && OrderSelect(order_ticket))
                 {
                  if(OrderGetInteger(ORDER_MAGIC) == magic)
                    {
                     trade.OrderDelete(order_ticket);
                     if(InpEnableLogging) Print("Ø³ÙØ§Ø±Ø´ Ù…Ø¹Ú©ÙˆØ³ Ø¨Ø§ ØªÛŒÚ©Øª " + IntegerToString(order_ticket) + " Ø­Ø°Ù Ø´Ø¯ (Ù…Ø¬ÛŒÚ©: " + IntegerToString(magic) + ").");
                    }
                 }
              }
           }
        }
     }
  }

double OnTester()
  {
   double total_trades = TesterStatistics(STAT_TRADES);
   double net_profit = TesterStatistics(STAT_PROFIT);
   double profit_factor = TesterStatistics(STAT_PROFIT_FACTOR);
   double sharpe_ratio = TesterStatistics(STAT_SHARPE_RATIO);
   double max_balance_drawdown_percent = TesterStatistics(STAT_BALANCE_DDREL_PERCENT);

   datetime startDate = 0, endDate = 0;
   if(HistoryDealsTotal() > 0)
     {
      startDate = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(0), DEAL_TIME);
      endDate = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(HistoryDealsTotal() - 1), DEAL_TIME);
     }
   double duration_days = (endDate > startDate) ? double(endDate - startDate) / (24.0 * 3600.0) : 1.0;
   double required_min_trades = MathFloor((duration_days / 365.0) * InpMinTradesPerYear);
   if(required_min_trades < 10) required_min_trades = 10;

   if(total_trades < required_min_trades || profit_factor < 1.1 || sharpe_ratio <= 0 || net_profit <= 0) return 0.0;

   double r_squared = 0, downside_consistency = 0;
   CalculateAdvancedMetrics(r_squared, downside_consistency);

   double drawdown_penalty_factor = 0.0;
   if(max_balance_drawdown_percent < InpMaxAcceptableDrawdown && InpMaxAcceptableDrawdown > 0)
     {
      double angle = (max_balance_drawdown_percent / InpMaxAcceptableDrawdown) * (M_PI / 2.0);
      drawdown_penalty_factor = MathCos(angle);
     }

   double final_score = 0.0;
   if(drawdown_penalty_factor > 0)
     {
      double trades_factor = MathLog(total_trades + 1);
      double net_profit_factor = MathLog(net_profit + 1);
      final_score = (profit_factor * sharpe_ratio * r_squared * downside_consistency * trades_factor * net_profit_factor) * drawdown_penalty_factor;
     }

   if(InpEnableLogging)
     {
      PrintFormat("Ù†ØªÛŒØ¬Ù‡ Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ: Ù…Ø¹Ø§Ù…Ù„Ø§Øª=%d, ÙØ§Ú©ØªÙˆØ± Ø³ÙˆØ¯=%.2f, Ø´Ø§Ø±Ù¾=%.2f, RÂ²=%.3f, Ø¯Ø±Ø§ÙˆØ¯Ø§ÙˆÙ†=%.2f%%, Ø¬Ø±ÛŒÙ…Ù‡=%.2f -> Ø§Ù…ØªÛŒØ§Ø²: %.4f",
                  (int)total_trades, profit_factor, sharpe_ratio, r_squared, max_balance_drawdown_percent, drawdown_penalty_factor, final_score);
     }

   return final_score;
  }

void CalculateAdvancedMetrics(double &r_squared, double &downside_consistency)
  {
   r_squared = 0;
   downside_consistency = 1.0;

   if(!HistorySelect(0, TimeCurrent())) return;
   uint total_deals = HistoryDealsTotal();
   if(total_deals < 5) return;

   struct EquityPoint { datetime time; double balance; };
   EquityPoint equity_curve[];
   ArrayResize(equity_curve, (int)total_deals + 2);

   double final_balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double net_profit = TesterStatistics(STAT_PROFIT);
   double initial_balance = final_balance - net_profit;

   double current_balance = initial_balance;
   equity_curve[0].time = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(0), DEAL_TIME) - 1;
   equity_curve[0].balance = current_balance;

   int equity_points = 1;
   for(uint i = 0; i < total_deals; i++)
     {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0)
        {
         if(HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
           {
            current_balance += HistoryDealGetDouble(ticket, DEAL_PROFIT) +
                               HistoryDealGetDouble(ticket, DEAL_COMMISSION) +
                               HistoryDealGetDouble(ticket, DEAL_SWAP);
            equity_curve[equity_points].time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
            equity_curve[equity_points].balance = current_balance;
            equity_points++;
           }
        }
     }
   ArrayResize(equity_curve, equity_points);
   if(equity_points < 3) return;

   double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0, sum_y2 = 0;
   for(int i = 0; i < equity_points; i++)
     {
      double x = i + 1.0;
      double y = equity_curve[i].balance;
      sum_x += x;
      sum_y += y;
      sum_xy += x * y;
      sum_x2 += x * x;
      sum_y2 += y * y;
     }
   double n = equity_points;
   double den_part1 = (n * sum_x2) - (sum_x * sum_x);
   double den_part2 = (n * sum_y2) - (sum_y * sum_y);
   if(den_part1 > 0 && den_part2 > 0)
     {
      double r = ((n * sum_xy) - (sum_x * sum_y)) / MathSqrt(den_part1 * den_part2);
      r_squared = r * r;
     }

   struct MonthlyTrades { int year; int month; int count; };
   MonthlyTrades monthly_counts[];
   int total_months = 0;

   for(uint i = 0; i < total_deals; i++)
     {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
        {
         datetime deal_time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
         MqlDateTime dt;
         TimeToStruct(deal_time, dt);

         int month_idx = -1;
         for(int j = 0; j < total_months; j++)
           {
            if(monthly_counts[j].year == dt.year && monthly_counts[j].month == dt.mon)
              {
               month_idx = j;
               break;
              }
           }

         if(month_idx == -1)
           {
            ArrayResize(monthly_counts, total_months + 1);
            monthly_counts[total_months].year = dt.year;
            monthly_counts[total_months].month = dt.mon;
            monthly_counts[total_months].count = 1;
            total_months++;
           }
         else
           {
            monthly_counts[month_idx].count++;
           }
        }
     }

   if(total_months <= 1)
     {
      downside_consistency = 1.0;
      return;
     }

   double target_trades_per_month = InpMinTradesPerYear / 12.0;
   if(target_trades_per_month < 1) target_trades_per_month = 1;

   double sum_of_squared_downside_dev = 0;
   for(int i = 0; i < total_months; i++)
     {
      if(monthly_counts[i].count < target_trades_per_month)
        {
         double deviation = target_trades_per_month - monthly_counts[i].count;
         sum_of_squared_downside_dev += deviation * deviation;
        }
     }

   double downside_variance = sum_of_squared_downside_dev / total_months;
   double downside_deviation = MathSqrt(downside_variance);
   downside_consistency = 1.0 / (1.0 + downside_deviation);
  }

int CountActiveSessions()
  {
   int count = 0;
   if(InpS1_IsActive) count++;
   if(InpS2_IsActive) count++;
   if(InpS3_IsActive) count++;
   if(InpS4_IsActive) count++;
   return count;
  }

ÙØ§ÛŒÙ„: SessionTrader.mqh
Ø§ÛŒÙ†Ø¬Ø§ Ù‡Ù…ÙˆÙ†â€ŒØ·ÙˆØ± Ú©Ù‡ Ø®ÙˆØ¯Øª Ú¯ÙØªÛŒØŒ Ù…Ù†Ø·Ù‚ is_stage1 Ùˆ is_stage2 Ø±Ùˆ Ú©Ø§Ù…Ù„Ø§Ù‹ Ø­Ø°Ù Ú©Ø±Ø¯Ù… Ùˆ Ø¨Ù‡ Ø¬Ø§Ø´ Ø§Ø² Ø¯Ùˆ ØªØ§ Ù…ØªØºÛŒØ± bool Ø¨Ù‡ Ù†Ø§Ù…â€ŒÙ‡Ø§ÛŒ m_partial_closed Ùˆ m_breakeven_set Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ø±Ø¯Ù…. Ø§ÛŒÙ† Ù…ØªØºÛŒØ±Ù‡Ø§ ÙˆØ¶Ø¹ÛŒØª Ù‡Ø± Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø±Ùˆ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ù‚ÛŒÙ‚ Ù¾ÛŒÚ¯ÛŒØ±ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ù†.
//+------------------------------------------------------------------+
//|                                             SessionTrader.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy"
#property link      "https://..."

#ifndef SESSIONTRADER_MQH
#define SESSIONTRADER_MQH

#include "Settings.mqh"
#include "RangeLib.mqh"
#include "TradeManager.mqh"

class CSessionTrader
  {
private:
   bool              m_is_active;
   int               m_magic_number;
   ENUM_TIMEFRAMES   m_timeframe;
   int               m_start_hour, m_start_min;
   int               m_end_hour, m_end_min;
   int               m_expiry_hour, m_expiry_min;

   int               m_ichimoku_handle;
   int               m_placement_atr_handle;
   int               m_range_atr_handle;
   int               m_ema_handle;
   int               m_trail_atr_handle;

   datetime          m_last_analysis_date;
   bool              m_partial_closed;
   bool              m_breakeven_set;

public:
                     CSessionTrader(void) : m_is_active(false), m_magic_number(0), m_timeframe(PERIOD_M15),
                     m_start_hour(0),m_start_min(0), m_end_hour(0),m_end_min(0), m_expiry_hour(0),m_expiry_min(0),
                     m_ichimoku_handle(INVALID_HANDLE), m_placement_atr_handle(INVALID_HANDLE), m_range_atr_handle(INVALID_HANDLE),
                     m_ema_handle(INVALID_HANDLE), m_trail_atr_handle(INVALID_HANDLE), m_last_analysis_date(0),
                     m_partial_closed(false), m_breakeven_set(false) {}

   void              Init(bool is_active,ENUM_TIMEFRAMES timeframe,int start_h,int start_m,int end_h,int end_m,int expiry_h,int expiry_m,int magic)
     {
      m_is_active = is_active;
      m_timeframe = timeframe;
      m_start_hour = start_h;
      m_start_min = start_m;
      m_end_hour = end_h;
      m_end_min = end_m;
      m_expiry_hour = expiry_h;
      m_expiry_min = expiry_m;
      m_magic_number = magic;

      if(!m_is_active) return;

      m_ichimoku_handle = iIchimoku(_Symbol,m_timeframe,InpIchimoku_Tenkan,InpIchimoku_Kijun,InpIchimoku_Senkou);
      if(m_ichimoku_handle == INVALID_HANDLE)
        {
         if(InpEnableLogging) Print("Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù‡Ù†Ø¯Ù„ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ Ø¨Ø±Ø§ÛŒ Ø¬Ù„Ø³Ù‡ " + IntegerToString(magic) + ".");
        }

      m_placement_atr_handle = iATR(_Symbol,m_timeframe,InRangeATR_Period);
      if(m_placement_atr_handle == INVALID_HANDLE)
        {
         if(InpEnableLogging) Print("Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù‡Ù†Ø¯Ù„ ATR Ù‚Ø±Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø¨Ø±Ø§ÛŒ Ø¬Ù„Ø³Ù‡ " + IntegerToString(magic) + ".");
        }

      m_range_atr_handle = iATR(_Symbol,InRangeATR_TimeFrame,InRangeATR_Period);
      if(m_range_atr_handle == INVALID_HANDLE)
        {
         if(InpEnableLogging) Print("Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù‡Ù†Ø¯Ù„ ATR Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø¨Ø±Ø§ÛŒ Ø¬Ù„Ø³Ù‡ " + IntegerToString(magic) + ".");
        }

      m_ema_handle = iMA(_Symbol,InpTrendEMATimeFrame,InpTrendEMAPeriod,0,MODE_EMA,InpTrendEMAAppliedPrice);
      if(m_ema_handle == INVALID_HANDLE)
        {
         if(InpEnableLogging) Print("Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù‡Ù†Ø¯Ù„ EMA Ø¨Ø±Ø§ÛŒ Ø¬Ù„Ø³Ù‡ " + IntegerToString(magic) + ".");
        }

      m_trail_atr_handle = iATR(_Symbol,InpTrailingStopATRTimeFrame,InpTrailingStopATRPeriod);
      if(m_trail_atr_handle == INVALID_HANDLE)
        {
         if(InpEnableLogging) Print("Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù‡Ù†Ø¯Ù„ ATR ØªØ±Ù„ÛŒÙ†Ú¯ Ø¨Ø±Ø§ÛŒ Ø¬Ù„Ø³Ù‡ " + IntegerToString(magic) + ".");
        }

      if(InpEnableLogging) Print("Ø¬Ù„Ø³Ù‡ " + IntegerToString(magic) + " Ø§ÙˆÙ„ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯.");
     }

   void              Deinit(void)
     {
      if(m_ichimoku_handle != INVALID_HANDLE) IndicatorRelease(m_ichimoku_handle);
      if(m_placement_atr_handle != INVALID_HANDLE) IndicatorRelease(m_placement_atr_handle);
      if(m_range_atr_handle != INVALID_HANDLE) IndicatorRelease(m_range_atr_handle);
      if(m_ema_handle != INVALID_HANDLE) IndicatorRelease(m_ema_handle);
      if(m_trail_atr_handle != INVALID_HANDLE) IndicatorRelease(m_trail_atr_handle);
      ObjectsDeleteAll(0,"Range_"+IntegerToString(m_magic_number)+"_");

      if(InpEnableLogging) Print("Ø¬Ù„Ø³Ù‡ " + IntegerToString(m_magic_number) + " Ø®Ø§ØªÙ…Ù‡ ÛŒØ§ÙØª.");
     }

   void              OnTimerUpdate(void)
     {
      if(!m_is_active) return;

      datetime now = TimeCurrent();
      MqlDateTime now_struct;
      TimeToStruct(now,now_struct);

      if(now_struct.hour == m_expiry_hour && now_struct.min == m_expiry_min)
        {
         SessionCleanUp(m_magic_number);
         if(InpEnableLogging) Print("Ø§Ù†Ù‚Ø¶Ø§ÛŒ Ø¬Ù„Ø³Ù‡ " + IntegerToString(m_magic_number) + " Ø±Ø³ÛŒØ¯ Ùˆ Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯.");
         return;
        }

      MqlDateTime end_struct = now_struct;
      end_dt_struct.hour = m_end_hour;
      end_dt_struct.min = m_end_min;
      end_dt_struct.sec = 0;
      datetime analysis_time = StructToTime(end_dt_struct);

      if(now >= analysis_time && !IsSameDay(m_last_analysis_date,now))
        {
         AnalyzeAndPlaceOrders();
         m_last_analysis_date = now;
         if(InpEnableLogging) Print("ØªØ­Ù„ÛŒÙ„ Ø¬Ù„Ø³Ù‡ " + IntegerToString(m_magic_number) + " Ø¯Ø± Ø²Ù…Ø§Ù† " + TimeToString(now) + " Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯.");
        }
     }

   int               GetMagicNumber(void) { return m_magic_number; }

   bool              ManageActiveTrade(ulong ticket)
     {
      if(!PositionSelectByTicket(ticket))
        {
         if(InpEnableLogging) Print("Ø®Ø·Ø§ Ø¯Ø± Ø§Ù†ØªØ®Ø§Ø¨ Ù¾ÙˆØ²ÛŒØ´Ù† Ø¨Ø§ ØªÛŒÚ©Øª " + IntegerToString(ticket) + ".");
         return false;
        }

      long current_magic = PositionGetInteger(POSITION_MAGIC);
      if(current_magic != m_magic_number) return false;

      if(!InpEnablePartialClose) return false;

      double entry_price = PositionGetDouble(POSITION_PRICE_OPEN);
      double current_sl = PositionGetDouble(POSITION_SL);
      double volume = PositionGetDouble(POSITION_VOLUME);
      ENUM_POSITION_TYPE pos_type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      
      //--- Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³ÙˆØ¯ Ù¾ÙˆØ²ÛŒØ´Ù† Ø¨Ù‡ Ù¾ÛŒÙ¾ Ø¨Ø±Ø§ÛŒ ØªØµÙ…ÛŒÙ…â€ŒÚ¯ÛŒØ±ÛŒ Ø¯Ù‚ÛŒÙ‚
      double profit_pips = 0;
      if (pos_type == POSITION_TYPE_BUY) profit_pips = (SymbolInfoDouble(_Symbol, SYMBOL_BID) - entry_price) / _Point;
      else profit_pips = (entry_price - SymbolInfoDouble(_Symbol, SYMBOL_ASK)) / _Point;

      //--- Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙØ§ØµÙ„Ù‡ Ø§Ø³ØªØ§Ù¾ Ù„Ø§Ø³ Ø§Ø² Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù¾ÛŒÙ¾
      double sl_distance_pips = MathAbs(entry_price - current_sl) / _Point;
      
      //--- Ù…Ù†Ø·Ù‚ Ø®Ø±ÙˆØ¬ Ù¾Ù„Ù‡â€ŒØ§ÛŒ
      if (!m_partial_closed)
      {
          if (profit_pips >= sl_distance_pips * InpTakeProfitRatio_Stage1)
          {
              double lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
              double min_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
              double close_volume = MathRound((volume * (InpPartialClosePercentage / 100.0)) / lot_step) * lot_step;

              if (volume - close_volume < min_lot && volume > min_lot) close_volume = volume;

              if (close_volume >= min_lot)
              {
                  if (trade.PositionClose(ticket, close_volume))
                  {
                      if (InpEnableLogging) Print("Ø®Ø±ÙˆØ¬ Ù¾Ù„Ù‡â€ŒØ§ÛŒ Ù…ÙˆÙÙ‚: ØªÛŒÚ©Øª=" + IntegerToString(ticket) + ", Ø­Ø¬Ù… Ø¨Ø³ØªÙ‡â€ŒØ´Ø¯Ù‡=" + DoubleToString(close_volume, 2) + ".");
                      m_partial_closed = true;
                      
                      //--- Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ø³ØªØ§Ù¾ Ø¨Ù‡ Ø¨Ø±ÛŒÚ© Ø§ÛŒÙˆÙ† Ø¨Ø¹Ø¯ Ø§Ø² Ø¨Ø³ØªÙ† Ù¾Ù„Ù‡â€ŒØ§ÛŒ
                      if (PositionSelectByTicket(ticket))
                      {
                          trade.PositionModify(ticket, entry_price, 0.0);
                          if (InpEnableLogging) Print("Ø§Ø³ØªØ§Ù¾ Ø¨Ù‡ breakeven Ù…Ù†ØªÙ‚Ù„ Ø´Ø¯: ØªÛŒÚ©Øª=" + IntegerToString(ticket) + ".");
                          m_breakeven_set = true;
                      }
                      return true;
                  }
                  else
                  {
                      if (InpEnableLogging) Print("Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬ Ù¾Ù„Ù‡â€ŒØ§ÛŒ: ØªÛŒÚ©Øª=" + IntegerToString(ticket) + ".");
                      return false;
                  }
              }
          }
      }
      
      //--- Ù…Ù†Ø·Ù‚ ØªØ±Ù„ÛŒÙ†Ú¯ Ø§Ø³ØªØ§Ù¾
      if (m_breakeven_set)
      {
          double atr_buffer[1];
          if(m_trail_atr_handle == INVALID_HANDLE || CopyBuffer(m_trail_atr_handle, 0, 1, 1, atr_buffer) != 1)
          {
             if(InpEnableLogging) Print("Ø®Ø·Ø§ Ø¯Ø± Ú©Ù¾ÛŒ Ø¨Ø§ÙØ± ATR ØªØ±Ù„ÛŒÙ†Ú¯: ØªÛŒÚ©Øª=" + IntegerToString(ticket) + ".");
             return false;
          }
          double trail_offset = atr_buffer[0] * InpTrailingStopATRMultiplier;
          
          if (pos_type == POSITION_TYPE_BUY)
          {
              double current_bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
              double new_sl = current_bid - trail_offset;
              if (new_sl > current_sl)
              {
                  if(trade.PositionModify(ticket, new_sl, 0.0))
                  {
                      if (InpEnableLogging) Print("ØªØ±Ù„ÛŒÙ†Ú¯ Ø§Ø³ØªØ§Ù¾ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯ (Ø®Ø±ÛŒØ¯): SL Ø¬Ø¯ÛŒØ¯=" + DoubleToString(new_sl, _Digits) + ", ØªÛŒÚ©Øª=" + IntegerToString(ticket) + ".");
                      return true;
                  }
              }
          }
          else if (pos_type == POSITION_TYPE_SELL)
          {
              double current_ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
              double new_sl = current_ask + trail_offset;
              if (new_sl < current_sl)
              {
                  if(trade.PositionModify(ticket, new_sl, 0.0))
                  {
                      if (InpEnableLogging) Print("ØªØ±Ù„ÛŒÙ†Ú¯ Ø§Ø³ØªØ§Ù¾ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯ (ÙØ±ÙˆØ´): SL Ø¬Ø¯ÛŒØ¯=" + DoubleToString(new_sl, _Digits) + ", ØªÛŒÚ©Øª=" + IntegerToString(ticket) + ".");
                      return true;
                  }
              }
          }
      }
      return false;
     }

   void              AnalyzeAndPlaceOrders(void)
     {
      RangeData rd;
      if(!IdentifyValidRange(rd))
        {
         if(InpEnableLogging) Print("Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø¯Ø± Ø¬Ù„Ø³Ù‡ " + IntegerToString(m_magic_number) + ". ØªØ­Ù„ÛŒÙ„ Ù…ØªÙˆÙ‚Ù Ø´Ø¯.");
         return;
        }

      DrawRangeOnChart(rd,m_magic_number);

      bool is_trend_on = InpTrendFilterIsOn;
      bool is_uptrend = false;

      if(is_trend_on)
        {
         double ema_buffer[1];
         if(CopyBuffer(m_ema_handle,0,1,1,ema_buffer) == 1)
           {
            double current_price = SymbolInfoDouble(_Symbol,SYMBOL_BID);
            is_uptrend = current_price > ema_buffer[0];
            if(InpEnableLogging) Print("ÙÛŒÙ„ØªØ± Ø±ÙˆÙ†Ø¯: " + (is_uptrend ? "ØµØ¹ÙˆØ¯ÛŒ" : "Ù†Ø²ÙˆÙ„ÛŒ") + " (Ù‚ÛŒÙ…Øª=" + DoubleToString(current_price, _Digits) + ", EMA=" + DoubleToString(ema_buffer[0], _Digits) + ") Ø¯Ø± Ø¬Ù„Ø³Ù‡ " + IntegerToString(m_magic_number) + ".");
           }
         else
          {
           if(InpEnableLogging) Print("Ø®Ø·Ø§ Ø¯Ø± Ú©Ù¾ÛŒ Ø¨Ø§ÙØ± EMA Ø¯Ø± Ø¬Ù„Ø³Ù‡ " + IntegerToString(m_magic_number) + ".");
          }
        }

      double atr_buffer[1];
      if(CopyBuffer(m_placement_atr_handle,0,1,1,atr_buffer) != 1)
        {
         if(InpEnableLogging) Print("Ø®Ø·Ø§ Ø¯Ø± Ú©Ù¾ÛŒ Ø¨Ø§ÙØ± ATR Ù‚Ø±Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø¯Ø± Ø¬Ù„Ø³Ù‡ " + IntegerToString(m_magic_number) + ".");
         return;
        }
      double atr_value = atr_buffer[0];
      double buffer = atr_value * InpAtrMultiplier_Placement;

      double buy_stop_price = rd.rangeHigh + buffer;
      double sell_stop_price = rd.rangeLow - buffer;

      double current_bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
      double current_ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
      if((is_trend_on && is_uptrend && current_ask >= buy_stop_price) ||
         (is_trend_on && !is_uptrend && current_bid <= sell_stop_price) ||
         (!is_trend_on && (current_ask >= buy_stop_price || current_bid <= sell_stop_price)))
         {
          if(InpEnableLogging) Print("Safety check: Ù‚ÛŒÙ…Øª Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø² Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø¹Ø¨ÙˆØ± Ú©Ø±Ø¯Ù‡ - Ø³ÙØ§Ø±Ø´ Ù‚Ø±Ø§Ø± Ù†Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ø¯ (Ø¬Ù„Ø³Ù‡ " + IntegerToString(m_magic_number) + ").");
          return;
         }

      PlacePendingOrders(m_magic_number,is_trend_on,is_uptrend,rd,buy_stop_price,sell_stop_price);
      
      //--- Ø±ÛŒØ³Øª Ú©Ø±Ø¯Ù† Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø¨Ø±Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¬Ø¯ÛŒØ¯
      m_partial_closed = false;
      m_breakeven_set = false;
     }

   bool              IsSameDay(datetime d1,datetime d2)
     {
      MqlDateTime s1,s2;
      TimeToStruct(d1,s1);
      TimeToStruct(d2,s2);
      return (s1.year == s2.year && s1.mon == s2.mon && s1.day == s2.day);
     }
  };

#endif //SESSIONTRADER_MQH

