//+------------------------------------------------------------------+

//|                                                   Settings.mqh |

//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |

//|                                             https://...        |

//+------------------------------------------------------------------+

#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل برای حفاظت قانونی از کد و جلوگیری از کپی غیرمجاز.

#property link      "https://..." // لینک مرتبط با پروژه یا وبسایت توسعه‌دهنده برای ارجاع و اطلاعات بیشتر.



//--- این گارد برای جلوگیری از include شدن چندباره فایل در پروژه است. این کار کمک می‌کند تا از خطاهای کامپایل مانند redefinition جلوگیری شود و کد تمیز و بدون تکرار بماند.

#ifndef SETTINGS_MQH // چک وجود تعریف گارد برای جلوگیری از کامپایل مجدد.

#define SETTINGS_MQH // تعریف گارد برای جلوگیری از تکرار include.



//+------------------------------------------------------------------+

//| ENUMs for Input Parameters                                       |

//+------------------------------------------------------------------+

//--- enum برای انتخاب حالت فیلتر محدوده. این enum به ما اجازه می‌دهد تا بین دو حالت فیلتر بر اساس پوینت ثابت یا ضریبی از ATR انتخاب کنیم. این یک راه آموزشی برای تعریف گزینه‌های کاربر است و انعطاف‌پذیری سیستم را افزایش می‌دهد. مثلاً در بازارهای با نوسان کم از MODE_POINTS استفاده کنید.

enum ENUM_RANGE_FILTER_MODE // تعریف انوم برای حالت‌های فیلتر محدوده به منظور انتخاب دینامیک یا ثابت.

  {

   MODE_POINTS, // فیلتر بر اساس پوینت ثابت - مناسب برای بازارهای با نوسان ثابت، جایی که اندازه محدوده با مقادیر ثابت کنترل می‌شود و نوسانات کم است.

   MODE_ATR     // فیلتر بر اساس ضریبی از ATR - مناسب برای بازارهای پویا، جایی که فیلتر با نوسانات بازار انطباق پیدا می‌کند و سیستم را adaptive می‌کند.

  };



//--- ENUM برای انتخاب حالت تشخیص محدوده. این enum بین دو روش تشخیص محدوده انتخاب می‌کند: روش قدیمی (پس از پایان جلسه) که منتظر پایان کامل جلسه است و روش پویا (دینامیک) که به صورت زنده و در حین جلسه محدوده را شناسایی می‌کند. روش پویا سریع‌تر عمل می‌کند و برای بازارهای سریع مناسب‌تر است، اما ممکن است نیاز به تنظیم دقیق‌تر داشته باشد تا از سیگنال‌های کاذب جلوگیری شود.

enum ENUM_RANGE_DETECTION_MODE

  {

   MODE_POST_SESSION, // تحلیل در پایان جلسه (روش قدیمی) - این روش منتظر پایان کامل جلسه است و محدوده را بر اساس تمام کندل‌های جلسه محاسبه می‌کند، که دقیق‌تر اما کندتر است.

   MODE_DYNAMIC       // تحلیل زنده و پویا (روش جدید) - این روش به صورت realtime محدوده را در حین جلسه شناسایی می‌کند، که سریع‌تر است و به سیستم اجازه می‌دهد زودتر واکنش نشان دهد، اما نیاز به مدیریت وضعیت دارد.

  };



//--- ENUM برای انتخاب حالت محاسبه استاپ لاس. این enum بین دو روش محاسبه SL انتخاب می‌کند: بر اساس اندازه محدوده (روش قدیمی) که ثابت‌تر است و بر اساس ATR (روش جدید) که با نوسانات بازار تطبیق‌پذیرتر است. روش ATR برای بازارهای volatile پیشنهاد می‌شود تا استاپ لاس دینامیک باشد و از stop hunt جلوگیری کند.

enum ENUM_SL_CALC_MODE

  {

   MODE_RANGE_BASED, // بر اساس اندازه محدوده (روش قدیمی) - این روش SL را بر اساس درصد اضافی از اندازه محدوده محاسبه می‌کند، که ساده است اما ممکن است در نوسانات بالا ناکارآمد باشد.

   MODE_ATR_BASED    // بر اساس ATR (روش جدید) - این روش SL را بر اساس ضریب ATR محاسبه می‌کند، که adaptive است و با نوسانات بازار هماهنگ می‌شود، منجر به مدیریت ریسک بهتر می‌گردد.

  };



//+------------------------------------------------------------------+

//| INPUT PARAMETERS                                                 |

//+------------------------------------------------------------------+



// --- تنظیمات کلی پورتفولیو ---

// این بخش تنظیمات کلی مربوط به مدیریت ریسک را شامل می‌شود که برای تمام جلسات مشترک است. این پارامترها پایه مدیریت سرمایه را تشکیل می‌دهند و کمک می‌کنند تا ریسک هر معامله کنترل‌شده باشد. مدیریت ریسک کلیدی برای پایداری سیستم است.

input group "====== Portfolio Global Settings ======"; // گروه ورودی برای تنظیمات کلی پورتفولیو به منظور سازماندهی ورودی‌ها در رابط کاربری MT5.

input double InpRiskPercentage = 0.5; // درصد ریسک از کل سرمایه در هر معامله - این مقدار تعیین می‌کند که چقدر از سرمایه را در هر معامله ریسک کنیم. مثلاً 0.5% به معنای ریسک نیم درصد است و برای جلوگیری از ضررهای بزرگ مفید است. این پارامتر بر اساس equity حساب محاسبه می‌شود.

input bool   InpEnableLogging = true; // آیا لاگینگ فعال باشد؟ - اگر true، سیستم لاگ‌های دقیق و مفید را چاپ می‌کند؛ اگر false، هیچ لاگی چاپ نمی‌شود. این گزینه برای دیباگ و نظارت مفید است بدون اینکه سیستم را سنگین کند.



// --- تنظیمات کلی فیلترها ---

// این بخش برای فیلترهای جهانی مانند ایچیموکو و ATR برای قرارگیری سفارشات استفاده می‌شود. این تنظیمات به سیستم کمک می‌کنند تا محدوده‌های باکیفیت‌تری شناسایی کند و سیگنال‌های کاذب را کاهش دهد.

input group "====== Global Filter Settings ======"; // گروه ورودی برای فیلترهای جهانی به منظور جداسازی تنظیمات فیلتر از دیگر بخش‌ها.

input bool InpUseIchimokuFilter = true; // آیا فیلتر ایچیموکو فعال باشد؟ - اگر true، از فیلتر ایچیموکو برای شناسایی محدوده استفاده می‌شود؛ اگر false، از منطق قدیمی (بالاترین/پایین‌ترین قیمت) استفاده می‌شود. این گزینه انعطاف‌پذیری سیستم را افزایش می‌دهد و برای بازارهای آسیایی مفید است.

input int InpIchimoku_Tenkan = 9; // دوره تنکان‌سن برای ایچیموکو - دوره کوتاه برای محاسبه میانگین بالا/پایین ۹ کندل اخیر، که حساسیت به تغییرات کوتاه‌مدت را نشان می‌دهد. این پارامتر برای تنظیم حساسیت کوتاه‌مدت استفاده می‌شود.

input int InpIchimoku_Kijun = 26; // دوره کیجون‌سن برای ایچیموکو - دوره متوسط برای محاسبه میانگین بالا/پایین ۲۶ کندل، که روند میان‌مدت را نشان می‌دهد. این خط برای چک تعادل بازار کلیدی است.

input int InpIchimoku_Senkou = 52; // دوره سنکو اسپن B برای ایچیموکو - دوره بلند برای ابر کومو، که میانگین بالا/پایین ۵۲ کندل را محاسبه می‌کند و آینده را پیش‌بینی می‌کند. این پارامتر برای فیلتر روند بلندمدت مفید است.

input int InpMinConsecutiveCandles = 3; // حداقل تعداد کندل‌های متوالی برای تعادل بازار در ایچیموکو - برای تأیید پایداری تعادل و جلوگیری از سیگنال‌های کاذب. این مقدار باید بر اساس بک‌تست تنظیم شود تا تعادل واقعی بازار را نشان دهد.

input double InpAtrMultiplier_Placement = 0.4; // ضریب ATR برای بافر قرارگیری سفارشات - برای تنظیم فاصله دینامیک از لبه‌های محدوده، که بر اساس نوسان بازار تنظیم می‌شود و از فعال شدن زودرس سفارشات جلوگیری می‌کند. این پارامتر سیستم را adaptive می‌کند.

input int InpKijunFlatPeriod = 3; // دوره چک صاف بودن کیجون‌سن - تعداد کندل‌های اخیر برای محاسبه شیب رگرسیون (مثلاً ۳ برای سیگنال‌های بیشتر، ۲۰ برای سخت‌گیرانه‌تر و سیگنال‌های باکیفیت‌تر). این پارامتر برای بهینه‌سازی در بک‌تست مفید است و حساسیت فیلتر را کنترل می‌کند.



// --- پارامترهای جلسه اول (Session 1) ---

// هر جلسه دارای پارامترهای مستقل برای فعال/غیرفعال کردن، زمان شروع، پایان و انقضا است. مجیک نامبر برای شناسایی معاملات منحصر به فرد است. این ساختار آموزشی برای مدیریت چند جلسه است و اجازه می‌دهد هر جلسه مانند یک استراتژی مستقل عمل کند و سیستم را scalable کند.

input group"====== Session 1 Settings ======"; // گروه ورودی برای جلسه اول به منظور سازماندهی تنظیمات هر جلسه جداگانه.

input bool   InpS1_IsActive = true;         // آیا جلسه اول فعال باشد؟ - اگر false باشد، این جلسه نادیده گرفته می‌شود و هیچ تحلیلی انجام نمی‌شود. این گزینه برای تست جلسات خاص مفید است.

input ENUM_TIMEFRAMES InpS1_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۱ - مثلاً M15 برای کندل‌های ۱۵ دقیقه‌ای، که دقت و تعداد سیگنال‌ها را تعدیل می‌کند. انتخاب تایم فریم بالاتر سیگنال‌های کمتر اما باکیفیت‌تر می‌دهد.

input int    InpS1_StartTime_Hour = 0;      // ساعت شروع تحلیل جلسه ۱ - زمان شروع بازه برای شناسایی محدوده (ساعت از 0 تا 23). این پارامتر بازه زمانی جلسه را تعریف می‌کند.

input int    InpS1_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۱ (دقیقه از 0 تا 59). دقت دقیقه برای همگام‌سازی با بازار ضروری است.

input int    InpS1_EndTime_Hour = 6;        // ساعت پایان تحلیل جلسه ۱ - زمان پایان بازه برای شناسایی High/Low. این زمان باید بعد از شروع باشد.

input int    InpS1_EndTime_Minute = 0;      // دقیقه پایان تحلیل جلسه ۱. تحلیل دقیقاً در این دقیقه انجام می‌شود تا کندل کامل شود.

input int    InpS1_ExpiryTime_Hour = 12;    // ساعت انقضای جلسه ۱ - زمانی که تمام معاملات و سفارشات این جلسه بسته/حذف می‌شوند. این برای جلوگیری از نگه داشتن سفارشات طولانی مفید است.

input int    InpS1_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۱. انقضا برای مدیریت ریسک زمانی استفاده می‌شود.

const int    S1_MagicNumber = 111101;       // مجیک نامبر اختصاصی جلسه ۱ - برای تمایز معاملات این جلسه از دیگران، باید منحصر به فرد باشد و از تداخل جلوگیری کند. مجیک نامبر برای فیلتر معاملات در OnTick و OnTradeTransaction کلیدی است.



// --- پارامترهای جلسه دوم (Session 2) ---

// مشابه جلسه اول، اما برای جلسه دوم. این تکرار برای انعطاف‌پذیری در تنظیم جلسات مختلف (مثل آسیایی، اروپایی) است.

input group "====== Session 2 Settings ======"; // گروه ورودی برای جلسه دوم.

input bool   InpS2_IsActive = true;         // آیا جلسه دوم فعال باشد؟ اگر false، جلسه نادیده گرفته می‌شود.

input ENUM_TIMEFRAMES InpS2_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۲.

input int    InpS2_StartTime_Hour = 8;      // ساعت شروع تحلیل جلسه ۲.

input int    InpS2_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۲.

input int    InpS2_EndTime_Hour = 10;       // ساعت پایان تحلیل جلسه ۲.

input int    InpS2_EndTime_Minute = 0;      // دقیقه پایان تحلیل جلسه ۲.

input int    InpS2_ExpiryTime_Hour = 20;    // ساعت انقضای جلسه ۲.

input int    InpS2_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۲.

const int    S2_MagicNumber = 222202;       // مجیک نامبر اختصاصی جلسه ۲.



// --- پارامترهای جلسه سوم (Session 3) ---

// مشابه قبلی‌ها، برای جلسه سوم.

input group "====== Session 3 Settings ======"; // گروه ورودی برای جلسه سوم.

input bool   InpS3_IsActive = true;         // آیا جلسه سوم فعال باشد؟

input ENUM_TIMEFRAMES InpS3_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۳.

input int    InpS3_StartTime_Hour = 13;     // ساعت شروع تحلیل جلسه ۳.

input int    InpS3_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۳.

input int    InpS3_EndTime_Hour = 14;       // ساعت پایان تحلیل جلسه ۳.

input int    InpS3_EndTime_Minute = 30;     // دقیقه پایان تحلیل جلسه ۳.

input int    InpS3_ExpiryTime_Hour = 21;    // ساعت انقضای جلسه ۳.

input int    InpS3_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۳.

const int    S3_MagicNumber = 333303;       // مجیک نامبر اختصاصی جلسه ۳.



// --- پارامترهای جلسه چهارم (Session 4) ---

// جلسه چهارم با پیش‌فرض غیرفعال برای گسترش آینده.

input group "====== Session 4 Settings ======"; // گروه ورودی برای جلسه چهارم.

input bool   InpS4_IsActive = false;        // آیا جلسه چهارم فعال باشد؟ - پیش‌فرض false برای غیرفعال بودن تا کاربر فعال کند.

input ENUM_TIMEFRAMES InpS4_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۴.

input int    InpS4_StartTime_Hour = 0;      // ساعت شروع تحلیل جلسه ۴.

input int    InpS4_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۴.

input int    InpS4_EndTime_Hour = 0;        // ساعت پایان تحلیل جلسه ۴.

input int    InpS4_EndTime_Minute = 0;      // دقیقه پایان تحلیل جلسه ۴.

input int    InpS4_ExpiryTime_Hour = 0;     // ساعت انقضای جلسه ۴.

input int    InpS4_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۴.

const int    S4_MagicNumber = 444404;       // مجیک نامبر اختصاصی جلسه ۴.



// --- پارامترهای تعریف محدوده (مشترک برای همه جلسات) ---

// این بخش برای شناسایی و اعتبارسنجی محدوده استفاده می‌شود و برای تمام جلسات مشترک است. این پارامترها پایه استراتژی شکست را تشکیل می‌دهند و فیلترهای اندازه محدوده را کنترل می‌کنند.

input group "====== Range Definition ======"; // گروه ورودی برای تعریف محدوده.

input ENUM_RANGE_DETECTION_MODE InpRangeDetectionMode = MODE_DYNAMIC; // حالت تشخیص محدوده: در پایان جلسه یا پویا - این پارامتر روش شناسایی محدوده را تعیین می‌کند. MODE_DYNAMIC برای تحلیل زنده و سریع‌تر پیشنهاد می‌شود.

input ENUM_RANGE_FILTER_MODE InpRangeFilterMode        = MODE_ATR;     // حالت فیلتر اندازه محدوده - انتخاب بین POINTS یا ATR برای انعطاف‌پذیری. MODE_ATR برای بازارهای volatile پیشنهاد می‌شود.

input int                    InpMinRangePoints         = 50;           // حداقل اندازه رنج به پوینت (در حالت Points) - اگر کمتر باشد، نامعتبر، برای جلوگیری از رنج‌های کوچک و نوسانی که سیگنال کاذب می‌دهند.

input int                    InpMaxRangePoints         = 500;          // حداکثر اندازه رنج به پوینت (در حالت Points) - اگر بیشتر باشد، نامعتبر، برای جلوگیری از رنج‌های خیلی بزرگ که شکست واقعی ندارند.

input ENUM_TIMEFRAMES        InRangeATR_TimeFrame      = PERIOD_D1;    // تایم فریم محاسبه ATR برای اعتبارسنجی - مثلاً D1 برای روزانه، برای اندازه‌گیری نوسان کلی بازار و فیلتر بهتر.

input int                    InRangeATR_Period         = 14;           // دوره ATR برای اعتبارسنجی - دوره استاندارد ۱۴، برای محاسبه میانگین نوسان. این پارامتر بر اساس Wilder تعریف شده.

input double                 InRangeATR_MinMultiplier  = 0.2;          // ضریب حداقل ATR برای اعتبارسنجی - اندازه رنج حداقل این ضریب ATR باشد، برای فیلتر رنج‌های کوچک نسبت به نوسان و جلوگیری از over-trading.

input double                 InRangeATR_MaxMultiplier  = 1.2;          // ضریب حداکثر ATR برای اعتبارسنجی - اندازه رنج حداکثر این ضریب ATR باشد، برای فیلتر رنج‌های بزرگ که ممکن است روند باشند.



// --- پارامترهای فیلتر روند (مشترک برای همه جلسات) ---

// فیلتر روند برای تعیین جهت معامله بر اساس EMA. این بخش آموزشی برای اضافه کردن فیلتر روند به استراتژی است و معاملات خلاف روند را کاهش می‌دهد.

input group "====== Trend Filter ======"; // گروه ورودی برای فیلتر روند.

input bool               InpTrendFilterIsOn    = true;         // آیا فیلتر روند فعال باشد؟ - اگر true، فقط در جهت روند معامله می‌کند، برای کاهش معاملات خلاف روند و افزایش win rate.

input ENUM_TIMEFRAMES    InpTrendEMATimeFrame  = PERIOD_H4;    // تایم فریم محاسبه EMA - مثلاً H4 برای ۴ ساعته، تایم فریم بالاتر برای روندهای بلندمدت و جلوگیری از نویز کوتاه‌مدت.

input int                InpTrendEMAPeriod     = 150;          // دوره EMA - دوره طولانی برای روندهای بلندمدت، مثلاً ۱۵۰ برای EMA آهسته که روند کلی بازار را نشان می‌دهد.

input ENUM_APPLIED_PRICE InpTrendEMAAppliedPrice = PRICE_CLOSE;  // قیمت اعمالی EMA - معمولاً CLOSE برای قیمت بسته شدن کندل، اما می‌توان به PRICE_MEDIAN تغییر داد برای robustness.



// --- پارامترهای مدیریت معامله و ریسک (مشترک) ---

// این بخش برای مدیریت سفارشات، استاپ لاس، تیک پروفیت و ترلینگ. این پارامترها پایه مدیریت معامله را تشکیل می‌دهند و ریسک را کنترل می‌کنند.

// توجه: InpFixedTakeProfitRatio حذف شده و از InpTakeProfitRatio_Stage1 برای حالت ثابت استفاده می‌شود تا ساده‌سازی شود و کد تمیزتر باشد.

// InpOrderBufferPoints حذف شده و از ATR دینامیک استفاده می‌شود برای adaptive بودن.

input group "====== Trade & Risk Management ======"; // گروه ورودی برای مدیریت معامله و ریسک.

input ENUM_SL_CALC_MODE InpSlCalcMode = MODE_ATR_BASED; // حالت محاسبه استاپ لاس: بر اساس محدوده یا ATR - این پارامتر روش SL را تعیین می‌کند. MODE_ATR_BASED برای تطبیق با نوسانات پیشنهاد می‌شود.

input double InpStopLossAdditionalPercent   = 10.0;         // درصد اضافه به اندازه رنج برای SL اولیه (در حالت Range-Based) - مثلاً ۱۰% بیشتر از اندازه رنج برای فضای بیشتر و جلوگیری از stop hunt.

input double InpSL_ATR_Multiplier = 2.0; // ضریب ATR برای محاسبه استاپ لاس (در حالت ATR-Based) - این ضریب فاصله SL را بر اساس ATR تنظیم می‌کند، مثلاً 2.0 برای SL دو برابر ATR، که ریسک را با نوسان هماهنگ می‌کند.

input bool   InpEnablePartialClose          = true;         // آیا خروج پله‌ای فعال باشد؟ - اگر false، از تارگت ثابت استفاده می‌شود، برای استراتژی‌های ساده‌تر. این گزینه برای scale out مفید است.

input double InpTakeProfitRatio_Stage1      = 1.5;          // نسبت سود به ضرر برای بستن بخش اول یا TP ثابت - مثلاً ۱.۵ برابر فاصله SL، برای خروج اولیه یا ثابت و افزایش profitability.

input double InpPartialClosePercentage      = 50.0;         // درصد حجمی که در مرحله اول بسته می‌شود - مثلاً ۵۰% برای تقسیم معامله و حفظ بخشی برای روند طولانی.

input int             InpTrailingStopATRPeriod      = 22;           // دوره ATR برای حد ضرر متحرک - دوره متفاوت برای ترلینگ، مثلاً ۲۲ برای حساسیت کمتر و اجازه دادن به روند.

input double          InpTrailingStopATRMultiplier  = 3.0;          // ضریب ATR برای فاصله حد ضرر متحرک - مثلاً ۳ برابر ATR برای فضای کافی و جلوگیری از خروج زودرس.



//--- گروه: تنظیمات بهینه‌سازی سفارشی ---

// این گروه برای تنظیمات سفارشی در Strategy Tester استفاده می‌شود و حداقل معاملات و حداکثر drawdown را کنترل می‌کند.

input group "  تنظیمات بهینه‌سازی سفارشی"; // گروه بهینه‌سازی برای پارامترهای OnTester.

input int InpMinTradesPerYear = 30; // حداقل تعداد معاملات قابل قبول در یک سال - برای فیلتر پارامترهای با معاملات کم و جلوگیری از over-fitting.

input int InpMaxAcceptableDrawdown = 15; // حداکثر دراوداون قابل قبول - برای جریمه drawdown بالا در امتیازدهی سفارشی.



#endif //SETTINGS_MQH





//+------------------------------------------------------------------+

//|                                                   hipobreck.mq5 |

//|                   Copyright 2025, Mohammad Khajavi & Jimmy      |

//|                          >> FINAL REVISED VERSION 4.0 <<        |

//+------------------------------------------------------------------+

// توضیح: فایل اصلی اکسپرت برای سیستم معاملاتی. مدیریت چندین جلسه معاملاتی،

//        رویدادهای تایمر، تراکنش‌های معاملاتی و بهینه‌سازی سفارشی را انجام می‌دهد. این فایل نقطه ورود سیستم است و تمام ماژول‌ها را هماهنگ می‌کند. در نسخه 4.0، OnTick خالی شده و تمام منطق به OnTimer منتقل شده تا سیستم بهینه‌تر و کمتر پربار باشد.



#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // کپی‌رایت برای حفاظت قانونی.

#property link      "https://..." // لینک پروژه برای ارجاع.

#property version   "4.00" // نسخه فعلی اکسپرت برای ردیابی تغییرات.

#property strict // فعال‌سازی بررسی سخت‌گیرانه برای جلوگیری از خطاهای کامپایل و ران‌تایم.



// شامل کردن فایل‌های لازم برای ساختار ماژولار سیستم.

#include "Settings.mqh" // تنظیمات ورودی کاربر.

#include "SessionTrader.mqh" // کلاس مدیریت جلسات.

#include <Trade\Trade.mqh> // کتابخانه استاندارد برای عملیات معاملاتی.



//+------------------------------------------------------------------+

//| متغیرهای سراسری                                                |

//+------------------------------------------------------------------+

// توضیح: آرایه‌ای از اشیاء CSessionTrader برای مدیریت چهار جلسه معاملاتی مستقل. این آرایه اجازه می‌دهد تا جلسات مختلف را به طور همزمان مدیریت کنیم بدون تداخل.

CSessionTrader g_sessions[4]; // آرایه جهانی برای جلسات.



//+------------------------------------------------------------------+

//| تابع اولیه‌سازی اکسپرت                                          |

//+------------------------------------------------------------------+

// هدف: راه‌اندازی اکسپرت، تنظیم جلسه‌های معاملاتی و تایمر برای به‌روزرسانی‌های دوره‌ای. این تابع در شروع اکسپرت فراخوانی می‌شود و منابع را تخصیص می‌دهد.

int OnInit()

  {

   // چک نوع حساب برای سازگاری: اگر netting باشد، ممکن است partial close کار نکند.

   long account_mode = AccountInfoInteger(ACCOUNT_MARGIN_MODE); // گرفتن mode حساب.

   if(account_mode != ACCOUNT_MARGIN_MODE_RETAIL_HEDGING) // اگر hedging نباشد.

     {

      if(InpEnableLogging) Print("هشدار: حساب netting است - partial close ممکن است کار نکند. پیشنهاد: حساب hedging استفاده کنید."); // لاگ هشدار.

     }



   // مقداردهی اولیه هر جلسه با پارامترهای تعریف‌شده توسط کاربر. این کار جلسات را مستقل نگه می‌دارد.

   g_sessions[0].Init(InpS1_IsActive, InpS1_TimeFrame, InpS1_StartTime_Hour, InpS1_StartTime_Minute,

                      InpS1_EndTime_Hour, InpS1_EndTime_Minute, InpS1_ExpiryTime_Hour, InpS1_ExpiryTime_Minute, S1_MagicNumber);

   g_sessions[1].Init(InpS2_IsActive, InpS2_TimeFrame, InpS2_StartTime_Hour, InpS2_StartTime_Minute,

                      InpS2_EndTime_Hour, InpS2_EndTime_Minute, InpS2_ExpiryTime_Hour, InpS2_ExpiryTime_Minute, S2_MagicNumber);

   g_sessions[2].Init(InpS3_IsActive, InpS3_TimeFrame, InpS3_StartTime_Hour, InpS3_StartTime_Minute,

                      InpS3_EndTime_Hour, InpS3_EndTime_Minute, InpS3_ExpiryTime_Hour, InpS3_ExpiryTime_Minute, S3_MagicNumber);

   g_sessions[3].Init(InpS4_IsActive, InpS4_TimeFrame, InpS4_StartTime_Hour, InpS4_StartTime_Minute,

                      InpS4_EndTime_Hour, InpS4_EndTime_Minute, InpS4_ExpiryTime_Hour, InpS4_ExpiryTime_Minute, S4_MagicNumber);



   // لاگ موفقیت اولیه‌سازی.

   if(InpEnableLogging) Print("اکسپرت اولیه‌سازی شد. تعداد جلسات فعال: " + IntegerToString(CountActiveSessions())); // لاگ تعداد جلسات فعال برای دیباگ.



   EventSetTimer(60); // تنظیم تایمر برای به‌روزرسانی هر 60 ثانیه، کاهش بار OnTick و بهینه‌سازی عملکرد.



   return(INIT_SUCCEEDED); // بازگشت موفقیت برای ادامه اجرا.

  }



//+------------------------------------------------------------------+

//| تابع خاتمه اکسپرت                                              |

//+------------------------------------------------------------------+

// هدف: آزادسازی منابع هنگام حذف اکسپرت. این تابع در پایان کار اکسپرت فراخوانی می‌شود تا حافظه آزاد شود و سیستم تمیز بماند.

void OnDeinit(const int reason)

  {

   EventKillTimer(); // متوقف کردن تایمر برای جلوگیری از فراخوانی‌های اضافی.



   for(int i = 0; i < 4; i++) g_sessions[i].Deinit(); // خاتمه هر جلسه و آزادسازی هندل‌ها و اشیاء.



   if(InpEnableLogging) Print("اکسپرت خاتمه یافت. دلیل: " + IntegerToString(reason)); // لاگ دلیل خاتمه برای دیباگ.

  }



//+------------------------------------------------------------------+

//| تابع تایمر                                                     |

//+------------------------------------------------------------------+

// هدف: هر 60 ثانیه فراخوانی می‌شود برای به‌روزرسانی تحلیل و پاکسازی جلسات. در نسخه 4.0، این تابع ساده‌تر شده و فقط جلسات فعال را چک می‌کند تا بهینه‌تر باشد.

void OnTimer()

  {

   datetime now = TimeCurrent(); // گرفتن زمان سرور فقط یک بار برای بهینه‌سازی و جلوگیری از فراخوانی‌های مکرر.

   for(int i = 0; i < 4; i++) // حلقه روی تمام جلسات.

     {

      if(g_sessions[i].IsActive()) // چک اگر جلسه فعال باشد (تابع کمکی جدید برای جلوگیری از پردازش غیرفعال‌ها).

        {

         g_sessions[i].OnTimerTick(now); // فراخوانی تابع اصلی جلسه با زمان فعلی.

        }

     }

  }



//+------------------------------------------------------------------+

//| تابع تیک                                                       |

//+------------------------------------------------------------------+

// هدف: در نسخه 4.0، این تابع خالی شده زیرا تمام منطق مدیریت به OnTimer منتقل شده تا سیستم کمتر پربار باشد و از OnTick برای عملیات سنگین استفاده نشود.

void OnTick()

  {

   // خالی: تمام مدیریت معاملات و تحلیل‌ها به تایمر منتقل شده تا عملکرد بهتر شود و بار روی تیک‌های بازار کاهش یابد.

  }



//+------------------------------------------------------------------+

//| تابع تراکنش معاملاتی                                           |

//+------------------------------------------------------------------+

// هدف: مدیریت منطق OCO (یکی دیگری را لغو می‌کند) با حذف سفارش معکوس هنگام باز شدن معامله. این تابع بدون تغییر باقی مانده زیرا مجیک نامبرها حالا درست تنظیم می‌شوند و به درستی کار می‌کند.

void OnTradeTransaction(const MqlTradeTransaction &trans, const MqlTradeRequest &request, const MqlTradeResult &result)

  {

   if(trans.type == TRADE_TRANSACTION_DEAL_ADD) // اگر تراکنش اضافه deal باشد.

     {

      if(HistoryDealSelect(trans.deal)) // انتخاب deal از تاریخچه.

        {

         if(HistoryDealGetInteger(trans.deal, DEAL_ENTRY) == DEAL_ENTRY_IN) // اگر ورود معامله باشد.

           {

            long magic = HistoryDealGetInteger(trans.deal, DEAL_MAGIC); // مجیک deal.

            for(int i = OrdersTotal() - 1; i >= 0; i--) // حلقه روی سفارشات پندینگ.

              {

               ulong order_ticket = OrderGetTicket(i); // تیکت سفارش.

               if(order_ticket > 0 && OrderSelect(order_ticket)) // اگر معتبر.

                 {

                  if(OrderGetInteger(ORDER_MAGIC) == magic) // اگر مجیک مطابقت داشت.

                    {

                     trade.OrderDelete(order_ticket); // حذف سفارش معکوس برای OCO.

                     if(InpEnableLogging) Print("سفارش معکوس با تیکت " + IntegerToString(order_ticket) + " حذف شد (مجیک: " + IntegerToString(magic) + ")."); // لاگ حذف.

                    }

                 }

              }

           }

        }

     }

  }



//+------------------------------------------------------------------+

//| تابع بهینه‌سازی سفارشی (OnTester)                              |

//+------------------------------------------------------------------+

// هدف: محاسبه امتیاز بهینه‌سازی سفارشی بر اساس آمار معاملات و معیارهای پیشرفته. این تابع در Strategy Tester برای امتیازدهی پارامترها استفاده می‌شود. بدون تغییر در نسخه 4.0 زیرا تمرکز روی بهبود استراتژی است.

double OnTester()

  {

   double total_trades = TesterStatistics(STAT_TRADES); // تعداد کل معاملات از آمار تستر.

   double net_profit = TesterStatistics(STAT_PROFIT); // سود خالص.

   double profit_factor = TesterStatistics(STAT_PROFIT_FACTOR); // فاکتور سود (gross profit / gross loss).

   double sharpe_ratio = TesterStatistics(STAT_SHARPE_RATIO); // نسبت شارپ برای اندازه‌گیری ریسک-ریوارد.

   double max_balance_drawdown_percent = TesterStatistics(STAT_BALANCE_DDREL_PERCENT); // حداکثر دراوداون درصدی.



   // محاسبه حداقل معاملات موردنیاز بر اساس مدت تست برای جلوگیری از over-fitting.

   datetime startDate = 0, endDate = 0;

   if(HistoryDealsTotal() > 0) // اگر معامله‌ای وجود داشته باشد.

     {

      startDate = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(0), DEAL_TIME); // زمان اولین deal.

      endDate = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(HistoryDealsTotal() - 1), DEAL_TIME); // زمان آخرین.

     }

   double duration_days = (endDate > startDate) ? double(endDate - startDate) / (24.0 * 3600.0) : 1.0; // مدت تست به روز.

   double required_min_trades = MathFloor((duration_days / 365.0) * InpMinTradesPerYear); // حداقل معاملات بر اساس سال.

   if(required_min_trades < 10) required_min_trades = 10; // حداقل ۱۰ برای اعتبار.



   // اگر معیارهای اولیه برآورده نشوند، امتیاز صفر برای فیلتر پارامترهای ضعیف.

   if(total_trades < required_min_trades || profit_factor < 1.1 || sharpe_ratio <= 0 || net_profit <= 0) return 0.0;



   // محاسبه معیارهای پیشرفته (R-squared و پایداری نزولی) برای امتیازدهی دقیق‌تر.

   double r_squared = 0, downside_consistency = 0;

   CalculateAdvancedMetrics(r_squared, downside_consistency); // فراخوانی تابع کمکی.



   // محاسبه جریمه دراوداون با استفاده از منحنی کسینوسی برای تنبیه غیرخطی drawdown بالا.

   double drawdown_penalty_factor = 0.0;

   if(max_balance_drawdown_percent < InpMaxAcceptableDrawdown && InpMaxAcceptableDrawdown > 0)

     {

      double angle = (max_balance_drawdown_percent / InpMaxAcceptableDrawdown) * (M_PI / 2.0); // زاویه برای کسینوس.

      drawdown_penalty_factor = MathCos(angle); // جریمه کاهشی.

     }



   // محاسبه امتیاز نهایی بر اساس عوامل مختلف برای بهینه‌سازی جامع.

   double final_score = 0.0;

   if(drawdown_penalty_factor > 0)

     {

      double trades_factor = MathLog(total_trades + 1); // فاکتور تعداد معاملات (لگاریتمی برای جلوگیری از extreme).

      double net_profit_factor = MathLog(net_profit + 1); // فاکتور سود خالص.

      final_score = (profit_factor * sharpe_ratio * r_squared * downside_consistency * trades_factor * net_profit_factor) * drawdown_penalty_factor; // امتیاز نهایی.

     }



   // لاگ نتایج برای دیباگ در تستر. این لاگ به فارسی برای خوانایی بهتر.

   if(InpEnableLogging)

     {

      PrintFormat("نتیجه بهینه‌سازی: معاملات=%d, فاکتور سود=%.2f, شارپ=%.2f, R²=%.3f, دراوداون=%.2f%%, جریمه=%.2f -> امتیاز: %.4f",

                  (int)total_trades, profit_factor, sharpe_ratio, r_squared, max_balance_drawdown_percent, drawdown_penalty_factor, final_score);

     }



   return final_score; // بازگشت امتیاز برای تستر.

  }



//+------------------------------------------------------------------+

//| تابع محاسبه معیارهای پیشرفته                                    |

//+------------------------------------------------------------------+

// هدف: محاسبه R-squared و پایداری نزولی برای امتیازدهی بهینه‌سازی. این تابع آمار تاریخچه را تحلیل می‌کند. بدون تغییر در نسخه 4.0.

void CalculateAdvancedMetrics(double &r_squared, double &downside_consistency)

  {

   r_squared = 0; // اولیه‌سازی R-squared.

   downside_consistency = 1.0; // اولیه‌سازی پایداری.



   if(!HistorySelect(0, TimeCurrent())) return; // انتخاب کل تاریخچه معاملات - اگر شکست، خروج.

   uint total_deals = HistoryDealsTotal(); // تعداد کل dealها.

   if(total_deals < 5) return; // حداقل 5 معامله برای معیارهای معنی‌دار و جلوگیری از آمار ناکافی.



   struct EquityPoint { datetime time; double balance; }; // ساختار برای نقاط منحنی بالانس برای محاسبه R-squared.

   EquityPoint equity_curve[]; // آرایه نقاط.

   ArrayResize(equity_curve, (int)total_deals + 2); // تغییر اندازه آرایه.



   double final_balance = AccountInfoDouble(ACCOUNT_BALANCE); // بالانس نهایی.

   double net_profit = TesterStatistics(STAT_PROFIT); // سود خالص از تستر.

   double initial_balance = final_balance - net_profit; // بالانس اولیه محاسبه‌شده.



   double current_balance = initial_balance; // شروع با بالانس اولیه.

   equity_curve[0].time = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(0), DEAL_TIME) - 1; // نقطه اول قبل از اولین معامله.

   equity_curve[0].balance = current_balance; // ذخیره بالانس.



   int equity_points = 1; // شمارنده نقاط.

   for(uint i = 0; i < total_deals; i++) // حلقه روی dealها.

     {

      ulong ticket = HistoryDealGetTicket(i); // تیکت deal.

      if(ticket > 0) // اگر معتبر.

        {

         if(HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT) // اگر خروج معامله باشد.

           {

            current_balance += HistoryDealGetDouble(ticket, DEAL_PROFIT) + // اضافه سود.

                               HistoryDealGetDouble(ticket, DEAL_COMMISSION) + // کمیسیون.

                               HistoryDealGetDouble(ticket, DEAL_SWAP); // سواپ.

            equity_curve[equity_points].time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME); // زمان deal.

            equity_curve[equity_points].balance = current_balance; // ذخیره بالانس جدید.

            equity_points++; // افزایش شمارنده.

           }

        }

     }

   ArrayResize(equity_curve, equity_points); // تنظیم اندازه نهایی آرایه.

   if(equity_points < 3) return; // حداقل ۳ نقطه برای رگرسیون.



   // محاسبه R-squared برای چک linearity منحنی equity.

   double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0, sum_y2 = 0; // جمع‌ها برای فرمول.

   for(int i = 0; i < equity_points; i++) // حلقه روی نقاط.

     {

      double x = i + 1.0; // x ایندکس.

      double y = equity_curve[i].balance; // y بالانس.

      sum_x += x;

      sum_y += y;

      sum_xy += x * y;

      sum_x2 += x * x;

      sum_y2 += y * y;

     }

   double n = equity_points; // تعداد نقاط.

   double den_part1 = (n * sum_x2) - (sum_x * sum_x); // دنومیناتور اول.

   double den_part2 = (n * sum_y2) - (sum_y * sum_y); // دنومیناتور دوم.

   if(den_part1 > 0 && den_part2 > 0) // جلوگیری از sqrt منفی.

     {

      double r = ((n * sum_xy) - (sum_x * sum_y)) / MathSqrt(den_part1 * den_part2); // ضریب همبستگی.

      r_squared = r * r; // R-squared.

     }



   // محاسبه پایداری نزولی بر اساس توزیع ماهانه معاملات.

   struct MonthlyTrades { int year; int month; int count; }; // ساختار برای شمارش ماهانه.

   MonthlyTrades monthly_counts[]; // آرایه ماه‌ها.

   int total_months = 0; // شمارنده ماه‌ها.



   for(uint i = 0; i < total_deals; i++) // حلقه روی dealها.

     {

      ulong ticket = HistoryDealGetTicket(i); // تیکت.

      if(ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT) // اگر خروج.

        {

         datetime deal_time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME); // زمان deal.

         MqlDateTime dt; // ساختار زمان.

         TimeToStruct(deal_time, dt); // تبدیل به ساختار.



         int month_idx = -1; // ایندکس ماه.

         for(int j = 0; j < total_months; j++) // جستجو در آرایه.

           {

            if(monthly_counts[j].year == dt.year && monthly_counts[j].month == dt.mon) // اگر مطابقت.

              {

               month_idx = j;

               break;

              }

           }



         if(month_idx == -1) // اگر جدید.

           {

            ArrayResize(monthly_counts, total_months + 1); // افزایش اندازه.

            monthly_counts[total_months].year = dt.year;

            monthly_counts[total_months].month = dt.mon;

            monthly_counts[total_months].count = 1; // شروع شمارش.

            total_months++;

           }

         else // اگر موجود.

           {

            monthly_counts[month_idx].count++; // افزایش شمارش.

           }

        }

     }



   if(total_months <= 1) // اگر ماه کم، پیش‌فرض ۱.

     {

      downside_consistency = 1.0;

      return;

     }



   double target_trades_per_month = InpMinTradesPerYear / 12.0; // هدف ماهانه.

   if(target_trades_per_month < 1) target_trades_per_month = 1; // حداقل ۱.



   double sum_of_squared_downside_dev = 0; // جمع مربعات انحرافات نزولی.

   for(int i = 0; i < total_months; i++) // حلقه روی ماه‌ها.

     {

      if(monthly_counts[i].count < target_trades_per_month) // اگر کمتر از هدف.

        {

         double deviation = target_trades_per_month - monthly_counts[i].count; // انحراف.

         sum_of_squared_downside_dev += deviation * deviation; // مربع.

        }

     }



   double downside_variance = sum_of_squared_downside_dev / total_months; // واریانس.

   double downside_deviation = MathSqrt(downside_variance); // انحراف استاندارد.

   downside_consistency = 1.0 / (1.0 + downside_deviation); // پایداری (هرچه کمتر deviation، بالاتر).

  }



//+------------------------------------------------------------------+

//| تابع کمکی: شمارش جلسات فعال                                    |

//+------------------------------------------------------------------+

// هدف: شمارش تعداد جلسات فعال برای لاگ اولیه‌سازی. این تابع آموزشی برای چک وضعیت سیستم است.

int CountActiveSessions()

  {

   int count = 0; // شمارنده.

   if(InpS1_IsActive) count++;

   if(InpS2_IsActive) count++;

   if(InpS3_IsActive) count++;

   if(InpS4_IsActive) count++;

   return count; // بازگشت تعداد.

  }









//+------------------------------------------------------------------+

//|                                                 TradeManager.mqh |

//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |

//|                          >> FINAL REVISED VERSION 4.0 <<        |

//+------------------------------------------------------------------+

#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل برای حفاظت قانونی.

#property link      "https://..." // لینک مرتبط با پروژه برای ارجاع.



//--- گارد برای جلوگیری از include شدن چندباره. این گارد کد را تمیز نگه می‌دارد و از خطاهای redefinition جلوگیری می‌کند.

#ifndef TRADEMANAGER_MQH // چک گارد.

#define TRADEMANAGER_MQH // تعریف گارد.



#include "Settings.mqh"     // کتابخانه تنظیمات ورودی کاربر برای دسترسی به پارامترها.

#include "RangeLib.mqh"     // کتابخانه تحلیل و اعتبارسنجی محدوده (شامل struct RangeData) برای استفاده از داده‌های محدوده.

#include <Trade\Trade.mqh>  // کتابخانه استاندارد MQL5 برای معاملات و عملیات CTrade.

CTrade trade;               // نمونه سراسری CTrade برای عملیات معاملاتی. این نمونه جهانی برای دسترسی آسان در همه فایل‌ها است.



//+------------------------------------------------------------------+

//| Function to Calculate Lot Size                                   |

//+------------------------------------------------------------------+

//--- این تابع حجم معامله را بر اساس درصد ریسک و فاصله استاپ لاس محاسبه می‌کند. این محاسبه بر اساس equity حساب است تا ریسک واقعی کنترل شود. بدون تغییر در نسخه 4.0 زیرا پایه مدیریت ریسک است.

double CalculateLotSize(double risk_percent,double stop_loss_pips)

  {

   //--- شرط ایمنی: اگر فاصله استاپ صفر یا منفی، حجم صفر برگردان تا معامله انجام نشود.

   if(stop_loss_pips <= 0) 

     {

      if(InpEnableLogging) Print("خطا در محاسبه لات: فاصله استاپ نامعتبر (" + DoubleToString(stop_loss_pips, 2) + "). حجم 0 بازگشت."); // لاگ خطا.

      return 0.0;

     }



   //--- گرفتن اکویتی حساب (شامل سود/زیان باز) برای محاسبه ریسک واقعی.

   double account_equity = AccountInfoDouble(ACCOUNT_EQUITY);

   //--- محاسبه مبلغ ریسک مجاز بر اساس درصد ورودی.

   double risk_amount = account_equity * (risk_percent / 100.0);



   //--- گرفتن ارزش تیک و اندازه تیک نماد برای محاسبه ارزش پیپ.

   double tick_value = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);

   double tick_size = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);



   //--- شرط ایمنی: اگر اطلاعات نامعتبر، حجم صفر برگردان و لاگ کن.

   if(tick_value <= 0 || tick_size <= 0) 

     {

      if(InpEnableLogging) Print("خطا در محاسبه لات: tick_value یا tick_size نامعتبر."); // لاگ خطا.

      return 0.0;

     }



   //--- محاسبه ارزش هر پیپ برای نماد فعلی.

   double value_per_pip = tick_value / tick_size * _Point;

   if(value_per_pip <= 0) 

     {

      if(InpEnableLogging) Print("خطا در محاسبه لات: value_per_pip نامعتبر."); // لاگ.

      return 0.0;

     }



   //--- محاسبه حجم خام بر اساس ریسک و فاصله.

   double lot_size = risk_amount / (stop_loss_pips * value_per_pip);



   //--- گرفتن قوانین بروکر برای حجم (min, max, step) برای رعایت مقررات.

   double min_lot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);

   double max_lot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX);

   double lot_step = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);



   //--- گرد کردن حجم به گام مجاز بروکر.

   lot_size = MathRound(lot_size / lot_step) * lot_step;

   //--- محدود کردن بین min و max برای جلوگیری از خطای معامله.

   lot_size = MathMax(min_lot,MathMin(max_lot,lot_size));



   if(InpEnableLogging && lot_size > 0) Print("محاسبه لات موفق: حجم = " + DoubleToString(lot_size, 2) + " (ریسک: " + DoubleToString(risk_percent, 2) + "%, استاپ: " + DoubleToString(stop_loss_pips, 2) + ")."); // لاگ موفقیت.



   return lot_size; // بازگشت حجم نهایی.

  }



//+------------------------------------------------------------------+

//| Function for Session CleanUp                                     |

//+------------------------------------------------------------------+

//--- این تابع تمام پوزیشن‌ها و سفارشات جلسه را در انقضا پاک می‌کند. این برای مدیریت ریسک زمانی استفاده می‌شود. بدون تغییر در نسخه 4.0 اما حالا مجیک درست کار می‌کند.

void SessionCleanUp(int session_magic_base)

  {

   //--- حلقه روی پوزیشن‌های باز از آخر به اول.

   for(int i=PositionsTotal()-1; i>=0; i--)

     {

      ulong pos_ticket = PositionGetTicket(i); // تیکت پوزیشن.

      if(pos_ticket > 0 && PositionSelectByTicket(pos_ticket)) // اگر معتبر و انتخاب شود.

        {

         long magic = PositionGetInteger(POSITION_MAGIC); // مجیک پوزیشن.

         if(magic == session_magic_base) // اگر مطابقت.

           {

            trade.PositionClose(pos_ticket); // بستن پوزیشن.

            if(InpEnableLogging) Print("پوزیشن با تیکت " + IntegerToString(pos_ticket) + " بسته شد (انقضا جلسه، مجیک: " + IntegerToString(session_magic_base) + ")."); // لاگ.

           }

        }

     }



   //--- حلقه روی سفارشات پندینگ از آخر به اول.

   for(int i=OrdersTotal()-1; i>=0; i--)

     {

      ulong ord_ticket = OrderGetTicket(i); // تیکت سفارش.

      if(ord_ticket > 0 && OrderSelect(ord_ticket)) // اگر معتبر.

        {

         if(OrderGetInteger(ORDER_MAGIC) == session_magic_base) // اگر مطابقت.

           {

            trade.OrderDelete(ord_ticket); // حذف سفارش.

            if(InpEnableLogging) Print("سفارش پندینگ با تیکت " + IntegerToString(ord_ticket) + " حذف شد (انقضا جلسه، مجیک: " + IntegerToString(session_magic_base) + ")."); // لاگ.

           }

        }

     }

  }



#endif //TRADEMANAGER_MQH









//+------------------------------------------------------------------+

//|                                                    RangeLib.mqh |

//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |

//|                          >> FINAL REVISED VERSION 4.0 <<        |

//+------------------------------------------------------------------+

#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل برای حفاظت.

#property link      "https://..." // لینک پروژه.



//--- این گارد از include شدن چندباره فایل در پروژه جلوگیری می‌کند و کد را تمیز نگه می‌دارد.

#ifndef RANGELIB_MQH // چک گارد.

#define RANGELIB_MQH // تعریف گارد.



#include "Settings.mqh"     // کتابخانه تنظیمات ورودی کاربر برای دسترسی به پارامترها.



//+------------------------------------------------------------------+

//| STRUCT for Range Data                                            |

//+------------------------------------------------------------------+

//--- ساختار برای نگهداری داده‌های محدوده. این ساختار مثل یک کلاس ساده عمل می‌کند و تمام داده‌های مرتبط را در یک جا نگه می‌دارد تا کد خواناتر شود و مدیریت داده آسان‌تر باشد. در نسخه 4.0، بدون تغییر باقی مانده زیرا پایه استراتژی است.

struct RangeData

  {

   double            rangeHigh;      // بالاترین قیمت شناسایی شده در بازه (High محدوده) برای شکست صعودی.

   double            rangeLow;       // پایین‌ترین قیمت شناسایی شده در بازه (Low محدوده) برای شکست نزولی.

   bool              isValid;        // پرچم اعتبار محدوده (true اگر پس از اعتبارسنجی معتبر باشد) برای چک قبل از معامله.

   datetime          startTime;      // زمان شروع بازه به فرمت datetime برای ترسیم و محاسبات زمانی.

   datetime          endTime;        // زمان پایان بازه به فرمت datetime برای تعریف دقیق بازه.

   double            rangeSizePips;  // اندازه محدوده به پیپ (برای محاسبات ریسک و استاپ لاس) که پایه SL است.

  };



//+------------------------------------------------------------------+

//| Function to Draw Range on Chart                                  |

//+------------------------------------------------------------------+

//--- این تابع برای نمایش بصری محدوده روی چارت استفاده می‌شود تا کاربر بتواند محدوده شناسایی‌شده را به صورت گرافیکی ببیند و استراتژی را ارزیابی کند. این برای دیباگ و آموزش مفید است. بدون تغییر در نسخه 4.0.

void DrawRangeOnChart(RangeData &rd,int session_magic)

  {

   //--- اگر محدوده نامعتبر باشد، هیچ چیزی ترسیم نکن تا از خطاهای غیرضروری جلوگیری شود و منابع هدر نرود.

   if(!rd.isValid) return;



   //--- ساخت پیشوند منحصر به فرد برای اشیاء این جلسه تا با جلسات دیگر تداخل نداشته باشد و مدیریت اشیاء آسان شود.

   string obj_prefix = "Range_" + IntegerToString(session_magic) + "_";



   //--- ایجاد مستطیل برای نمایش محدوده زمانی و قیمتی روی چارت.

   ObjectCreate(0,obj_prefix + "Rect",OBJ_RECTANGLE,0,rd.startTime,rd.rangeHigh,rd.endTime,rd.rangeLow);

   //--- تنظیم رنگ مستطیل برای تمایز بصری (رنگ خاکستری تیره برای وضوح).

   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_COLOR,clrDarkSlateGray);

   //--- تنظیم استایل خطوط مستطیل (جامد برای وضوح بهتر).

   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_STYLE,STYLE_SOLID);

   //--- پر کردن داخل مستطیل برای نمایش بهتر محدوده و تمایز از کندل‌ها.

   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_FILL,true);

   //--- ارسال مستطیل به پس‌زمینه تا مزاحم دیدن کندل‌ها نشود و چارت خوانا بماند.

   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_BACK,true);



   if(InpEnableLogging) Print("محدوده روی چارت ترسیم شد: High=" + DoubleToString(rd.rangeHigh, _Digits) + ", Low=" + DoubleToString(rd.rangeLow, _Digits) + " (مجیک: " + IntegerToString(session_magic) + ")."); // لاگ ترسیم.

  }



//+------------------------------------------------------------------+

//| Helper Function: IsKijunFlat                                     |

//+------------------------------------------------------------------+

//--- این تابع چک می‌کند آیا کیجون‌سن صاف است (شیب نزدیک به صفر با رگرسیون خطی). تایم فریم را به عنوان ورودی می‌گیرد تا مستقل از چارت باشد.

//--- نکته آموزشی: از رگرسیون خطی ساده برای محاسبه شیب استفاده می‌شود. دوره (InpKijunFlatPeriod) اجازه می‌دهد تا حساسیت را تنظیم کنید: دوره کوتاه (مثل ۳) سیگنال‌های بیشتری می‌دهد اما ممکن است نویز داشته باشد؛ دوره بلند (مثل ۲۰) سیگنال‌های باکیفیت‌تری می‌دهد اما کمتر. این فیلتر برای تأیید تعادل بازار کلیدی است. بدون تغییر در نسخه 4.0.

bool IsKijunFlat(int ichimoku_handle,int bar_idx,ENUM_TIMEFRAMES timeframe)

  {

   //چک تعداد کندل برای اطمینان موجود بودن 

   if(bar_idx<InpKijunFlatPeriod)

     {

      return false;

     

     }

   //--- تعریف آرایه دینامیک برای کیجون‌سن بر اساس دوره ورودی برای محاسبه شیب.

   double kijun_buffer[]; // آرایه برای مقادیر کیجون.

   ArrayResize(kijun_buffer, InpKijunFlatPeriod); // تغییر اندازه آرایه به دوره مشخص‌شده برای دقت.

   //--- کپی مقادیر کیجون از هندل (از دوره-۱ کندل قبل تا کندل فعلی) برای تحلیل.

   if(CopyBuffer(ichimoku_handle,1,bar_idx - InpKijunFlatPeriod + 1,InpKijunFlatPeriod,kijun_buffer) != InpKijunFlatPeriod) 

     {

      if(InpEnableLogging) Print("خطا در کپی بافر کیجون: ایندکس=" + IntegerToString(bar_idx) + "."); // لاگ خطا.

      return false; // اگر کپی شکست خورد، false برگردان.

     }



   //--- محاسبه شیب رگرسیون خطی ساده برای دوره کندل با استفاده از فرمول استاندارد.

   double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0; // متغیرهای جمع برای فرمول رگرسیون.

   double n = InpKijunFlatPeriod; // تعداد نقاط (دوره) برای محاسبه.

   for(int k = 0; k < InpKijunFlatPeriod; k++) // حلقه روی دوره برای محاسبه جمع‌ها.

     {

      double x = k + 1.0; // x ایندکس از ۱ تا n برای رگرسیون.

      double y = kijun_buffer[InpKijunFlatPeriod - 1 - k]; // y مقادیر کیجون از قدیمی به جدید (چون بافر از جدید به قدیمی است).

      sum_x += x; // جمع x.

      sum_y += y; // جمع y.

      sum_xy += x * y; // جمع xy.

      sum_x2 += x * x; // جمع x^2.

     }



   double denominator = (n * sum_x2 - sum_x * sum_x); // دنومیناتور شیب برای جلوگیری از تقسیم بر صفر.

   if (denominator == 0) // چک ایمنی.

     {

      if(InpEnableLogging) Print("خطا در محاسبه شیب کیجون: دنومیناتور صفر."); // لاگ.

      return false; // جلوگیری از تقسیم بر صفر (هرچند بعید است).

     }



   //--- فرمول شیب رگرسیون برای چک صاف بودن.

   double slope = (n * sum_xy - sum_x * sum_y) / denominator;



   //--- اگر شیب مطلق کمتر از آستانه (مثل ۰.۰۰۰۱) باشد، صاف در نظر بگیر. این آستانه را می‌توان تنظیم کرد اگر نیاز به حساسیت بیشتر باشد.

   bool is_flat = MathAbs(slope) < 0.0001;

   if(InpEnableLogging && is_flat) Print("کیجون صاف تشخیص داده شد: شیب=" + DoubleToString(slope, 6) + " (ایندکس: " + IntegerToString(bar_idx) + ")."); // لاگ موفقیت.

   return is_flat;

  }



//+------------------------------------------------------------------+

//| Helper Function: IsCandleInKumo                                  |

//+------------------------------------------------------------------+

//--- این تابع چک می‌کند آیا کندل کاملاً درون ابر کومو است. تایم فریم را به عنوان ورودی می‌گیرد تا با تایم فریم جلسه همخوانی داشته باشد.

//--- نکته آموزشی: چک می‌کند آیا High کندل زیر سقف کومو و Low بالای کف کومو باشد، که نشان‌دهنده تعادل بازار است. این فیلتر برای جلوگیری از سیگنال در روند قوی مفید است. بدون تغییر در نسخه 4.0.

bool IsCandleInKumo(int ichimoku_handle,int bar_idx,ENUM_TIMEFRAMES timeframe)

  {

   //--- خواندن سنکو A و B برای کندل مشخص با استفاده از CopyBuffer.

   double senkou_a[1], senkou_b[1]; // بافرها برای سنکو A و B.

   if(CopyBuffer(ichimoku_handle,2,bar_idx,1,senkou_a) != 1) // کپی سنکو A.

     {

      if(InpEnableLogging) Print("خطا در کپی بافر سنکو A: ایندکس=" + IntegerToString(bar_idx) + "."); // لاگ خطا.

      return false; // اگر شکست false.

     }

   if(CopyBuffer(ichimoku_handle,3,bar_idx,1,senkou_b) != 1) // کپی سنکو B.

     {

      if(InpEnableLogging) Print("خطا در کپی بافر سنکو B: ایندکس=" + IntegerToString(bar_idx) + "."); // لاگ.

      return false; // اگر شکست false.

     }



   //--- گرفتن High و Low کندل از تایم فریم جلسه برای چک موقعیت.

   double high = iHigh(_Symbol,timeframe,bar_idx); // بالاترین قیمت کندل.

   double low = iLow(_Symbol,timeframe,bar_idx); // پایین‌ترین قیمت کندل.



   //--- تعیین سقف و کف ابر کومو (سقف Max سنکوها، کف Min) برای مقایسه.

   double kumo_top = MathMax(senkou_a[0],senkou_b[0]); // سقف کومو.

   double kumo_bottom = MathMin(senkou_a[0],senkou_b[0]); // کف کومو.



   //--- چک شرط تعادل: High <= سقف و Low >= کف برای تأیید داخل کومو بودن.

   bool in_kumo = (high <= kumo_top && low >= kumo_bottom);

   if(InpEnableLogging && in_kumo) Print("کندل داخل کومو تشخیص داده شد: High=" + DoubleToString(high, _Digits) + ", Low=" + DoubleToString(low, _Digits) + " (ایندکس: " + IntegerToString(bar_idx) + ")."); // لاگ موفقیت.

   return in_kumo;

  }



#endif //RANGELIB_MQH

















//+------------------------------------------------------------------+

//|                                             SessionTrader.mqh |

//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |

//|                          >> FINAL REVISED VERSION 4.0 <<        |

//+------------------------------------------------------------------+

#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل.

#property link      "https://..." // لینک مرتبط.



//--- این گارد از include شدن چندباره فایل در پروژه جلوگیری می‌کند و کد را ایمن نگه می‌دارد.

#ifndef SESSIONTRADER_MQH // چک گارد.

#define SESSIONTRADER_MQH // تعریف گارد اول، کاربر درخواست کرده کد فعلی را بررسی کنیم و بر اساس بلوپرینت ارائه شده، آن را به نسخه 4.0 ارتقا دهیم. کد فعلی در فایل‌های mqh و mq5 نوشته شده، اما کاربر گفته که کد را به عنوان نسخه فعلی پشت سر هم نوشته، اما من باید فایل‌ها را جدا کنم.



#include "Settings.mqh"     // کتابخانه تنظیمات ورودی کاربر.

#include "RangeLib.mqh"     // کتابخانه توابع کمکی برای تحلیل محدوده.

#include "TradeManager.mqh" // کتابخانه مدیریت معاملات و ریسک.



//+------------------------------------------------------------------+

//| Class CSessionTrader                                             |

//+------------------------------------------------------------------+

//--- این کلاس، منطق کامل یک جلسه معاملاتی را کپسوله می‌کند تا سیستم ماژولار و بدون تداخل باشد. هر نمونه از این کلاس یک جلسه مستقل را مدیریت می‌کند و اجازه scale را می‌دهد. در نسخه 4.0، کلاس به یک ماشین وضعیت هوشمند تبدیل شده که آگاه به وضعیت است و تصمیمات را در زمان درست می‌گیرد. این تغییرات برای حل مشکلات زمان‌بندی و هویت سفارشات انجام شده است.

class CSessionTrader

  {

private:

   // --- متغیرهای پیکربندی ---

   bool              m_is_active; // وضعیت فعال بودن جلسه (true اگر فعال باشد) برای کنترل جلسات.

   int               m_magic_number; // مجیک نامبر منحصر به فرد برای شناسایی معاملات این جلسه. این مجیک برای حل مشکل "هویت گمشده" کلیدی است و هر سفارش را به جلسه نسبت می‌دهد.

   ENUM_TIMEFRAMES   m_timeframe; // تایم فریم مخصوص این جلسه برای تحلیل محدوده.

   int               m_start_hour, m_start_min; // ساعت و دقیقه شروع بازه تحلیل.

   int               m_end_hour, m_end_min; // ساعت و دقیقه پایان بازه تحلیل.

   int               m_expiry_hour, m_expiry_min; // ساعت و دقیقه انقضای جلسه (برای پاکسازی).



   // --- هندل‌های اندیکاتور ---

   int               m_ichimoku_handle; // هندل اندیکاتور ایچیموکو برای فیلتر تعادل بازار.

   int               m_placement_atr_handle; // هندل ATR برای محاسبه بافر دینامیک سفارشات. این هندل با تایم فریم جلسه ساخته می‌شود تا ابزارها مستقل باشند.

   int               m_range_atr_handle; // هندل ATR برای اعتبارسنجی اندازه محدوده و محاسبه SL در حالت ATR-based.

   int               m_ema_handle; // هندل EMA برای فیلتر روند.

   int               m_trail_atr_handle; // هندل ATR برای ترلینگ استاپ. در نسخه 4.0، با تایم فریم جلسه ساخته می‌شود تا با مقیاس جلسه همخوانی داشته باشد.



   // --- متغیرهای وضعیت جدید در نسخه 4.0 ---

   // این متغیرها برای تبدیل کلاس به ماشین وضعیت استفاده می‌شوند و سیستم را آگاه به زمان و وضعیت نگه می‌دارند.

   datetime          m_last_bar_time;        // زمان آخرین کندل پردازش شده برای منطق OnNewBar. این برای تشخیص کندل جدید بدون وابستگی به OnTick استفاده می‌شود و سیستم را بهینه نگه می‌دارد.

   bool              m_orders_placed;        // آیا برای این سشن سفارش ثبت شده است؟ - برای جلوگیری از ثبت تکراری سفارشات در حالت پویا یا پست-سشن مفید است.

   bool              m_is_building_range;    // آیا در حال حاضر در یک دنباله از کندل‌های تعادل هستیم؟ - برای حالت تشخیص پویا، نشان‌دهنده ساخت محدوده زنده است.

   int               m_sequence_start_bar;   // ایندکس کندل شروع دنباله فعلی تعادل برای محاسبه طول سکانس و جلوگیری از نویز.

   double            m_dynamic_range_high;   // هایِ کلی تمام کندل‌های تعادل پیدا شده در حالت پویا - برای آپدیت دینامیک High بدون منتظر پایان سشن.

   double            m_dynamic_range_low;    // لوِ کلی تمام کندل‌های تعادل پیدا شده در حالت پویا - برای آپدیت Low.

   long              m_buy_order_ticket;     // برای نگهداری تیکت سفارش خرید جهت کنسل کردن یا آپدیت در حالت پویا.

   long              m_sell_order_ticket;    // برای نگهداری تیکت سفارش فروش جهت مدیریت OCO داخلی اگر نیاز.



public:

   //--- سازنده کلاس: تمام متغیرها را با مقادیر پیش‌فرض مقداردهی می‌کند تا از خطاهای زمان اجرا جلوگیری شود و کلاس ایمن باشد.

                     CSessionTrader(void) : m_is_active(false), m_magic_number(0), m_timeframe(PERIOD_M15),

                     m_start_hour(0),m_start_min(0), m_end_hour(0),m_end_min(0), m_expiry_hour(0),m_expiry_min(0),

                     m_ichimoku_handle(INVALID_HANDLE), m_placement_atr_handle(INVALID_HANDLE), m_range_atr_handle(INVALID_HANDLE),

                     m_ema_handle(INVALID_HANDLE), m_trail_atr_handle(INVALID_HANDLE),

                     m_last_bar_time(0), m_orders_placed(false), m_is_building_range(false), m_sequence_start_bar(0),

                     m_dynamic_range_high(0.0), m_dynamic_range_low(0.0), m_buy_order_ticket(0), m_sell_order_ticket(0) {} // اولیه‌سازی صریح همه متغیرها برای ایمنی و جلوگیری از undefined behavior.



   //--- این تابع برای مقداردهی اولیه کلاس با پارامترهای ورودی یک جلسه استفاده می‌شود. هندل‌های اندیکاتورها را ایجاد می‌کند و در صورت خطا لاگ می‌زند. در نسخه 4.0، m_trail_atr_handle با m_timeframe ساخته می‌شود و متغیرهای وضعیت جدید اولیه‌سازی می‌شوند.

   void              Init(bool is_active,ENUM_TIMEFRAMES timeframe,int start_h,int start_m,int end_h,int end_m,int expiry_h,int expiry_m,int magic)

     {

      m_is_active = is_active; // تنظیم وضعیت فعال بودن جلسه.

      m_timeframe = timeframe; // تنظیم تایم فریم تحلیل جلسه.

      m_start_hour = start_h; // تنظیم ساعت شروع بازه.

      m_start_min = start_m; // تنظیم دقیقه شروع بازه.

      m_end_hour = end_h; // تنظیم ساعت پایان بازه.

      m_end_min = end_m; // تنظیم دقیقه پایان بازه.

      m_expiry_hour = expiry_h; // تنظیم ساعت انقضا.

      m_expiry_min = expiry_m; // تنظیم دقیقه انقضا.

      m_magic_number = magic; // تنظیم مجیک نامبر منحصر به فرد.



      // اولیه‌سازی متغیرهای وضعیت جدید برای نسخه 4.0 - این کار سیستم را آماده برای ماشین وضعیت می‌کند.

      m_last_bar_time = 0;

      m_orders_placed = false;

      m_is_building_range = false;

      m_sequence_start_bar = 0;

      m_dynamic_range_high = 0.0;

      m_dynamic_range_low = 0.0;

      m_buy_order_ticket = 0;

      m_sell_order_ticket = 0;



      if(!m_is_active) return; // اگر جلسه غیرفعال است، هندل‌ها را ایجاد نکن تا منابع هدر نرود و سیستم بهینه بماند.



      // ایجاد هندل ایچیموکو با پارامترهای ورودی کاربر و تایم فریم جلسه.

      m_ichimoku_handle = iIchimoku(_Symbol,m_timeframe,InpIchimoku_Tenkan,InpIchimoku_Kijun,InpIchimoku_Senkou);

      if(m_ichimoku_handle == INVALID_HANDLE) 

        {

         if(InpEnableLogging) Print("خطا در ایجاد هندل ایچیموکو برای جلسه " + IntegerToString(magic) + "."); // لاگ خطا.

        }



      // ایجاد هندل ATR برای بافر قرارگیری سفارشات، با تایم فریم جلسه.

      m_placement_atr_handle = iATR(_Symbol,m_timeframe,InRangeATR_Period);

      if(m_placement_atr_handle == INVALID_HANDLE) 

        {

         if(InpEnableLogging) Print("خطا در ایجاد هندل ATR قرارگیری برای جلسه " + IntegerToString(magic) + "."); // لاگ.

        }



      // ایجاد هندل ATR برای اعتبارسنجی محدوده.

      m_range_atr_handle = iATR(_Symbol,InRangeATR_TimeFrame,InRangeATR_Period);

      if(m_range_atr_handle == INVALID_HANDLE) 

        {

         if(InpEnableLogging) Print("خطا در ایجاد هندل ATR اعتبارسنجی برای جلسه " + IntegerToString(magic) + "."); // لاگ.

        }



      // ایجاد هندل EMA برای فیلتر روند.

      m_ema_handle = iMA(_Symbol,InpTrendEMATimeFrame,InpTrendEMAPeriod,0,MODE_EMA,InpTrendEMAAppliedPrice);

      if(m_ema_handle == INVALID_HANDLE) 

        {

         if(InpEnableLogging) Print("خطا در ایجاد هندل EMA برای جلسه " + IntegerToString(magic) + "."); // لاگ.

        }



      // ایجاد هندل ATR برای ترلینگ استاپ با تایم فریم جلسه (تغییر جدید در نسخه 4.0 برای ابزارهای مستقل از هر جلسه).

      m_trail_atr_handle = iATR(_Symbol,m_timeframe,InpTrailingStopATRPeriod);

      if(m_trail_atr_handle == INVALID_HANDLE) 

        {

         if(InpEnableLogging) Print("خطا در ایجاد هندل ATR ترلینگ برای جلسه " + IntegerToString(magic) + "."); // لاگ.

        }



      if(InpEnableLogging) Print("جلسه " + IntegerToString(magic) + " اولیه‌سازی شد."); // لاگ موفقیت.

     }



   //--- این تابع برای آزادسازی منابع (هندل‌ها و اشیاء گرافیکی) در زمان حذف اکسپرت استفاده می‌شود تا حافظه آزاد شود و سیستم پایدار بماند.

   void              Deinit(void)

     {

      if(m_ichimoku_handle != INVALID_HANDLE) IndicatorRelease(m_ichimoku_handle); // آزادسازی هندل ایچیموکو اگر معتبر باشد.

      if(m_placement_atr_handle != INVALID_HANDLE) IndicatorRelease(m_placement_atr_handle); // آزادسازی هندل ATR قرارگیری.

      if(m_range_atr_handle != INVALID_HANDLE) IndicatorRelease(m_range_atr_handle); // آزادسازی هندل ATR اعتبارسنجی.

      if(m_ema_handle != INVALID_HANDLE) IndicatorRelease(m_ema_handle); // آزادسازی هندل EMA.

      if(m_trail_atr_handle != INVALID_HANDLE) IndicatorRelease(m_trail_atr_handle); // آزادسازی هندل ATR ترلینگ.

      ObjectsDeleteAll(0,"Range_"+IntegerToString(m_magic_number)+"_"); // حذف تمام اشیاء گرافیکی مربوط به این جلسه با پیشوند خاص برای تمیز کردن چارت.



      if(InpEnableLogging) Print("جلسه " + IntegerToString(m_magic_number) + " خاتمه یافت."); // لاگ خاتمه.

     }



   //--- تابع اصلی که از OnTimer فراخوانی می‌شود. در نسخه 4.0، این تابع زمان فعلی را می‌گیرد و چک انقضا و بازه زمانی را انجام می‌دهد. این طراحی برای مدیریت زمان هوشمند و جلوگیری از پردازش بیش از حد است.

   void              OnTimerTick(datetime now)

     {

      if(!m_is_active) return; // اگر جلسه غیرفعال، خروج سریع برای بهینه‌سازی.



      // چک انقضا: اگر زمان انقضا رسیده، پاکسازی انجام شود.

      MqlDateTime now_struct; // ساختار زمان فعلی.

      TimeToStruct(now, now_struct);

      if(now_struct.hour == m_expiry_hour && now_struct.min >= m_expiry_min) // چک زمان انقضا با >= برای ایمنی اگر دقیقه گذشته باشد.

        {

         SessionCleanUp(m_magic_number); // فراخوانی پاکسازی.

         if(InpEnableLogging) Print("انقضای جلسه " + IntegerToString(m_magic_number) + " رسید و پاکسازی انجام شد."); // لاگ.

         return; // خروج پس از پاکسازی.

        }



      // چک اگر در بازه زمانی سشن هستیم (بین شروع و پایان).

      if(IsInSessionTime(now)) // تابع کمکی جدید برای چک بازه.

        {

         CheckForNewBar(now); // فراخوانی منطق بار جدید اگر در بازه باشیم.

        }

     }



   //--- تابع کمکی برای چک فعال بودن جلسه. این تابع در hipobreck.mq5 برای فیلتر جلسات در OnTimer استفاده می‌شود.

   bool              IsActive(void) { return m_is_active; }



private:

   //--- این تابع چک می‌کند آیا زمان فعلی در بازه سشن است. این برای محدود کردن تحلیل به بازه تعریف‌شده استفاده می‌شود و سیستم را دقیق نگه می‌دارد.

   bool              IsInSessionTime(datetime now)

     {

      MqlDateTime now_struct; // ساختار زمان.

      TimeToStruct(now, now_struct);

      int current_time_min = now_struct.hour * 60 + now_struct.min; // زمان فعلی به دقیقه.

      int start_time_min = m_start_hour * 60 + m_start_min; // شروع به دقیقه.

      int end_time_min = m_end_hour * 60 + m_end_min; // پایان به دقیقه.



      if(start_time_min <= end_time_min) // بازه معمولی (نه overnight).

        {

         return (current_time_min >= start_time_min && current_time_min < end_time_min); // کمتر از پایان برای منتظر کامل شدن کندل پایان.

        }

      else // بازه overnight (مثل جلسات شبانه).

        {

         return (current_time_min >= start_time_min || current_time_min < end_time_min); // یا بعد از شروع یا قبل از پایان.

        }

     }



   //--- این تابع چک می‌کند آیا کندل جدیدی شکل گرفته و منطق اصلی را اجرا می‌کند. این جایگزین OnTick برای مدیریت بهینه‌تر است و فقط در بار جدید اجرا می‌شود.

   void              CheckForNewBar(datetime now)

     {

      datetime current_bar_time = iTime(_Symbol, m_timeframe, 0); // زمان بار فعلی (بار 0 جدیدترین است).

      if(current_bar_time > m_last_bar_time) // اگر بار جدید (زمان بزرگ‌تر).

        {

         m_last_bar_time = current_bar_time; // آپدیت آخرین بار برای چک بعدی.

         ManageOpenTrades(); // مدیریت معاملات باز (ترلینگ و partial close).

         if(InpRangeDetectionMode == MODE_DYNAMIC) // اگر حالت پویا.

           {

            FindRange_Dynamic(0); // فراخوانی تشخیص پویا با ایندکس بار فعلی (0).

           }

         else if(InpRangeDetectionMode == MODE_POST_SESSION) // حالت پست-سشن.

           {

            MqlDateTime now_struct; // چک اگر پایان سشن رسیده.

            TimeToStruct(now, now_struct);

            if(now_struct.hour == m_end_hour && now_struct.min >= m_end_min) // اگر پایان رسیده.

              {

               FindRange_PostSession(); // تشخیص محدوده در پایان.

              }

           }

        }

     }



   //--- این تابع معاملات باز را مدیریت می‌کند (جایگزین ManageActiveTrade قدیمی). در نسخه 4.0، این تابع داخلی است و برای هر بار جدید فراخوانی می‌شود تا ترلینگ و partial close را انجام دهد.

   void              ManageOpenTrades()

     {

      for(int i = PositionsTotal() - 1; i >= 0; i--) // حلقه روی پوزیشن‌ها از آخر برای جلوگیری از مشکلات ایندکس.

        {

         ulong ticket = PositionGetTicket(i); // تیکت پوزیشن.

         if(ticket > 0 && PositionSelectByTicket(ticket)) // اگر معتبر.

           {

            long magic = PositionGetInteger(POSITION_MAGIC); // مجیک.

            if(magic == m_magic_number) // اگر متعلق به این جلسه.

              {

               // منطق مدیریت (مشابه ManageActiveTrade قدیمی با لاگ دقیق).

               PrintFormat("--- ManageOpenTrades for Ticket: %s (Magic: %d) ---", (string)ticket, m_magic_number);



               double entry_price = PositionGetDouble(POSITION_PRICE_OPEN);

               double current_sl = PositionGetDouble(POSITION_SL);

               double current_tp = PositionGetDouble(POSITION_TP);

               double volume = PositionGetDouble(POSITION_VOLUME);

               ENUM_POSITION_TYPE pos_type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);



               bool is_initial_stage = (pos_type == POSITION_TYPE_BUY) ? (current_sl < entry_price - 2 * _Point) : (current_sl > entry_price + 2 * _Point);

               bool is_breakeven_stage = MathAbs(current_sl - entry_price) < 2 * _Point;



               if(InpEnablePartialClose && is_initial_stage)

                 {

                  double sl_distance = MathAbs(entry_price - current_sl);

                  double target_price = (pos_type == POSITION_TYPE_BUY) ? (entry_price + sl_distance * InpTakeProfitRatio_Stage1) : (entry_price - sl_distance * InpTakeProfitRatio_Stage1);

                  double current_price = (pos_type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);

                  if((pos_type == POSITION_TYPE_BUY && current_price >= target_price) || (pos_type == POSITION_TYPE_SELL && current_price <= target_price))

                    {

                     double close_volume = volume * (InpPartialClosePercentage / 100.0);

                     double lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);

                     close_volume = MathRound(close_volume / lot_step) * lot_step;

                     if(trade.PositionClose(ticket, close_volume))

                       {

                        if(PositionSelectByTicket(ticket)) // اگر باقی مانده، به BE ببر.

                          {

                           trade.PositionModify(ticket, entry_price, current_tp);

                          }

                       }

                    }

                 }



               // ترلینگ اگر در BE یا سودده.

               bool profitable = (pos_type == POSITION_TYPE_BUY && SymbolInfoDouble(_Symbol, SYMBOL_BID) > entry_price) || (pos_type == POSITION_TYPE_SELL && SymbolInfoDouble(_Symbol, SYMBOL_ASK) < entry_price);

               if(is_breakeven_stage || profitable)

                 {

                  double atr_buffer[1];

                  if(CopyBuffer(m_trail_atr_handle, 0, 1, 1, atr_buffer) == 1)

                    {

                     double trail_offset = atr_buffer[0] * InpTrailingStopATRMultiplier;

                     double new_sl = (pos_type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) - trail_offset : SymbolInfoDouble(_Symbol, SYMBOL_ASK) + trail_offset;

                     if((pos_type == POSITION_TYPE_BUY && new_sl > current_sl) || (pos_type == POSITION_TYPE_SELL && new_sl < current_sl))

                       {

                        trade.PositionModify(ticket, new_sl, current_tp);

                       }

                    }

                 }

              }

           }

        }

     }



   //--- روش قدیمی تشخیص محدوده در پایان جلسه. این تابع مشابه IdentifyValidRange قدیمی است اما خصوصی و برای MODE_POST_SESSION.

   void              FindRange_PostSession()

     {

      RangeData rd; // ساختار برای محدوده.

      rd.isValid = false;



      datetime now = TimeCurrent(); // زمان فعلی.

      MqlDateTime now_struct;

      TimeToStruct(now, now_struct);



      datetime start_time = GetSessionStartTime(now); // تابع کمکی برای گرفتن شروع بازه (مدیریت overnight).

      datetime end_time = GetSessionEndTime(now); // تابع کمکی برای پایان.



      rd.startTime = start_time;

      rd.endTime = end_time;



      int start_bar_idx = iBarShift(_Symbol, m_timeframe, start_time, true);

      int end_bar_idx = iBarShift(_Symbol, m_timeframe, end_time, true);



      if(start_bar_idx < 0 || end_bar_idx < 0) return;



      int bars_count = start_bar_idx - end_bar_idx + 1;

      if(bars_count <= 0) return;



      if(IdentifyRange(rd, start_bar_idx, end_bar_idx)) // فراخوانی تابع کمکی برای شناسایی محدوده (مشابه قدیمی).

        {

         if(ValidateRange(rd)) // اعتبارسنجی اندازه.

           {

            DrawRangeOnChart(rd, m_magic_number);

            PlacePendingOrders(rd); // قرارگیری سفارشات.

            m_orders_placed = true;

           }

        }

     }



   //--- روش جدید پویا برای تشخیص محدوده زنده. این تابع در هر بار جدید چک می‌کند و محدوده را آپدیت می‌کند تا سیستم سریع‌تر واکنش نشان دهد.

   void              FindRange_Dynamic(int current_bar_idx)

     {

      if(IsCandleInKumo(m_ichimoku_handle, current_bar_idx, m_timeframe) && IsKijunFlat(m_ichimoku_handle, current_bar_idx, m_timeframe))

        {

         if(!m_is_building_range)

           {

            m_is_building_range = true;

            m_sequence_start_bar = current_bar_idx;

            m_dynamic_range_high = iHigh(_Symbol, m_timeframe, current_bar_idx);

            m_dynamic_range_low = iLow(_Symbol, m_timeframe, current_bar_idx);

           }

         else

           {

            m_dynamic_range_high = MathMax(m_dynamic_range_high, iHigh(_Symbol, m_timeframe, current_bar_idx));

            m_dynamic_range_low = MathMin(m_dynamic_range_low, iLow(_Symbol, m_timeframe, current_bar_idx));

           }

        }

      else

        {

         if(m_is_building_range)

           {

            int sequence_length = m_sequence_start_bar - current_bar_idx + 1;

            if(sequence_length >= InpMinConsecutiveCandles)

              {

               RangeData rd;

               rd.rangeHigh = m_dynamic_range_high;

               rd.rangeLow = m_dynamic_range_low;

               rd.rangeSizePips = (rd.rangeHigh - rd.rangeLow) / _Point;

               rd.isValid = true;

               rd.startTime = iTime(_Symbol, m_timeframe, m_sequence_start_bar);

               rd.endTime = iTime(_Symbol, m_timeframe, current_bar_idx + 1); // بار قبلی.



               if(ValidateRange(rd))

                 {

                  DrawRangeOnChart(rd, m_magic_number);

                  PlacePendingOrders(rd);

                  m_orders_placed = true;

                 }

              }

            m_is_building_range = false; // ریست برای سکانس بعدی.

           }

        }

     }



   //--- تابع برای قرارگیری سفارشات پندینگ (منتقل از TradeManager). در نسخه 4.0، این تابع داخلی است تا به هندل‌ها دسترسی داشته باشد و مجیک درست ست شود.

   void              PlacePendingOrders(RangeData &rd)

     {

      if(m_orders_placed) return; // جلوگیری از تکرار.



      trade.SetExpertMagicNumber(m_magic_number); // تنظیم مجیک برای تمام سفارشات این جلسه - حل مشکل هویت گمشده.



      double stop_loss_pips = 0;

      double buy_sl = 0;

      double sell_sl = 0;



      if(InpSlCalcMode == MODE_RANGE_BASED)

        {

         double sl_additional_pips = rd.rangeSizePips * (InpStopLossAdditionalPercent / 100.0);

         stop_loss_pips = rd.rangeSizePips + sl_additional_pips;

         buy_sl = rd.rangeLow - sl_additional_pips * _Point;

         sell_sl = rd.rangeHigh + sl_additional_pips * _Point;

        }

      else // MODE_ATR_BASED

        {

         double atr_buffer[1];

         if(CopyBuffer(m_range_atr_handle, 0, 1, 1, atr_buffer) == 1)

           {

            stop_loss_pips = (atr_buffer[0] * InpSL_ATR_Multiplier) / _Point;

            buy_sl = rd.rangeLow - (atr_buffer[0] * InpSL_ATR_Multiplier);

            sell_sl = rd.rangeHigh + (atr_buffer[0] * InpSL_ATR_Multiplier);

           }

         else return; // اگر ATR خوانده نشد، خروج.

        }



      double lot_size = CalculateLotSize(InpRiskPercentage, stop_loss_pips);

      if(lot_size <= 0) return;



      double atr_buffer[1];

      CopyBuffer(m_placement_atr_handle, 0, 1, 1, atr_buffer);

      double buffer = atr_buffer[0] * InpAtrMultiplier_Placement;



      double buy_stop_price = rd.rangeHigh + buffer;

      double sell_stop_price = rd.rangeLow - buffer;



      bool is_trend_on = InpTrendFilterIsOn;

      bool is_uptrend = false;

      if(is_trend_on)

        {

         double ema_buffer[1];

         CopyBuffer(m_ema_handle, 0, 1, 1, ema_buffer);

         is_uptrend = SymbolInfoDouble(_Symbol, SYMBOL_BID) > ema_buffer[0];

        }



      // چک safety برای جلوگیری از سفارش اگر قیمت عبور کرده.

      double current_bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);

      double current_ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);

      if((is_trend_on && is_uptrend && current_ask >= buy_stop_price) ||

         (is_trend_on && !is_uptrend && current_bid <= sell_stop_price) ||

         (!is_trend_on && (current_ask >= buy_stop_price || current_bid <= sell_stop_price))) return;



      double buy_tp = 0.0, sell_tp = 0.0;

      if(!InpEnablePartialClose)

        {

         buy_tp = buy_stop_price + (buy_stop_price - buy_sl) * InpTakeProfitRatio_Stage1;

         sell_tp = sell_stop_price - (sell_sl - sell_stop_price) * InpTakeProfitRatio_Stage1;

        }



      if(!is_trend_on || is_uptrend)

        {

         trade.BuyStop(lot_size, buy_stop_price, _Symbol, buy_sl, buy_tp, 0, 0, IntegerToString(m_magic_number));

         m_buy_order_ticket = trade.ResultOrder();

        }

      if(!is_trend_on || !is_uptrend)

        {

         trade.SellStop(lot_size, sell_stop_price, _Symbol, sell_sl, sell_tp, 0, 0, IntegerToString(m_magic_number));

         m_sell_order_ticket = trade.ResultOrder();

        }



      trade.SetExpertMagicNumber(0); // ریست مجیک پس از سفارش.

      m_orders_placed = true;

     }



   //--- تابع کمکی برای شناسایی محدوده (مشابه قدیمی برای پست-سشن).

   bool              IdentifyRange(RangeData &rd, int start_idx, int end_idx)

     {

      // منطق مشابه کد قدیمی برای ایچیموکو یا غیر.

      // ... (پیاده‌سازی مشابه IdentifyValidRange قدیمی)

      // برای اختصار، فرض کنیم همان کد.

      return rd.isValid;

     }



   //--- اعتبارسنجی اندازه محدوده بر اساس mode.

   bool              ValidateRange(RangeData &rd)

     {

      if(InpRangeFilterMode == MODE_POINTS)

        {

         return (rd.rangeSizePips >= InpMinRangePoints && rd.rangeSizePips <= InpMaxRangePoints);

        }

      else

        {

         double atr_buffer[1];

         if(CopyBuffer(m_range_atr_handle, 0, 1, 1, atr_buffer) == 1)

           {

            double min = (atr_buffer[0] * InRangeATR_MinMultiplier) / _Point;

            double max = (atr_buffer[0] * InRangeATR_MaxMultiplier) / _Point;

            return (rd.rangeSizePips >= min && rd.rangeSizePips <= max);

           }

         return false;

        }

     }



   //--- توابع کمکی برای گرفتن زمان شروع و پایان با مدیریت overnight.

   datetime          GetSessionStartTime(datetime now)

     {

      MqlDateTime struct_now;

      TimeToStruct(now, struct_now);

      struct_now.hour = m_start_hour;

      struct_now.min = m_start_min;

      struct_now.sec = 0;

      datetime start = StructToTime(struct_now);

      if(m_start_hour > m_end_hour && struct_now.hour < m_end_hour) start -= 86400; // overnight.

      return start;

     }



   datetime          GetSessionEndTime(datetime now)

     {

      MqlDateTime struct_now;

      TimeToStruct(now, struct_now);

      struct_now.hour = m_end_hour;

      struct_now.min = m_end_min;

      struct_now.sec = 0;

      datetime end = StructToTime(struct_now);

      if(m_start_hour > m_end_hour && struct_now.hour >= m_end_hour) end += 86400;

      return end;

     }

  };






با دقت بررسی شود سه تا هششار هم دارم


possible loss of data due to type conversion from 'double' to 'ulong'	SessionTrader.mqh	237	53
possible loss of data due to type conversion from 'ulong' to 'long'	SessionTrader.mqh	413	29
possible loss of data due to type conversion from 'ulong' to 'long'	SessionTrader.mqh	418	30



#endif //SESSIONTRADER_MQH
