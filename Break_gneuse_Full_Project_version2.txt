//+------------------------------------------------------------------+
//|                                             SessionTrader.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy"
#property link      "https://..."

//--- این گارد از include شدن چندباره فایل در پروژه جلوگیری می‌کند و کد را ایمن نگه می‌دارد.
#ifndef SESSIONTRADER_MQH 
#define SESSIONTRADER_MQH 

#include "Settings.mqh"     // کتابخانه تنظیمات ورودی کاربر.
#include "RangeLib.mqh"     // کتابخانه توابع کمکی برای تحلیل محدوده.
#include "TradeManager.mqh" // کتابخانه مدیریت معاملات و ریسک.
#include <Trade\PositionInfo.mqh> // برای اطلاعات پوزیشن‌ها مانند قیمت، حجم و استاپ لاس.
#include <Trade\TerminalInfo.mqh> // برای اطلاعات ترمینال و مدیریت خطاها.

//+------------------------------------------------------------------+
//| Class CSessionTrader                                             |
//+------------------------------------------------------------------+
//--- این کلاس، منطق کامل یک جلسه معاملاتی را کپسوله می‌کند تا سیستم ماژولار و بدون تداخل باشد. هر نمونه از این کلاس یک جلسه مستقل را مدیریت می‌کند.
class CSessionTrader
  {
private:
   // --- متغیرهای پیکربندی ---
   bool              m_is_active;                 // وضعیت فعال بودن جلسه (true اگر فعال باشد).
   int               m_magic_number;              // مجیک نامبر منحصر به فرد برای شناسایی معاملات این جلسه.
   ENUM_TIMEFRAMES   m_timeframe;                 // تایم فریم مخصوص این جلسه برای تحلیل محدوده.
   int               m_start_hour, m_start_min;   // ساعت و دقیقه شروع بازه تحلیل.
   int               m_end_hour, m_end_min;       // ساعت و دقیقه پایان بازه تحلیل.
   int               m_expiry_hour, m_expiry_min; // ساعت و دقیقه انقضای جلسه (برای پاکسازی).
   
   // --- هندل‌های اندیکاتور ---
   int               m_ichimoku_handle;           // هندل اندیکاتور ایچیموکو برای فیلتر تعادل بازار.
   int               m_placement_atr_handle;      // هندل ATR برای محاسبه بافر دینامیک سفارشات.
   int               m_range_atr_handle;          // هندل ATR برای اعتبارسنجی اندازه محدوده.
   int               m_ema_handle;                // هندل EMA برای فیلتر روند.
   int               m_trail_atr_handle;          // هندل ATR برای ترلینگ استاپ.

   // --- متغیرهای وضعیت ---
   datetime          m_last_analysis_date;        // تاریخ آخرین تحلیل موفق برای جلوگیری از تکرار روزانه.
   
public:
   //--- سازنده کلاس: تمام متغیرها را با مقادیر پیش‌فرض مقداردهی می‌کند.
                     CSessionTrader(void) : m_is_active(false), m_magic_number(0), m_timeframe(PERIOD_M15),
                     m_start_hour(0),m_start_min(0), m_end_hour(0),m_end_min(0), m_expiry_hour(0),m_expiry_min(0),
                     m_ichimoku_handle(INVALID_HANDLE), m_placement_atr_handle(INVALID_HANDLE), m_range_atr_handle(INVALID_HANDLE),
                     m_ema_handle(INVALID_HANDLE), m_trail_atr_handle(INVALID_HANDLE), m_last_analysis_date(0) {}

   //--- تابع Init: برای مقداردهی اولیه کلاس با پارامترهای ورودی.
   void              Init(bool is_active,ENUM_TIMEFRAMES timeframe,int start_h,int start_m,int end_h,int end_m,int expiry_h,int expiry_m,int magic)
     {
      m_is_active = is_active;
      m_timeframe = timeframe;
      m_start_hour = start_h;
      m_start_min = start_m;
      m_end_hour = end_h;
      m_end_min = end_m;
      m_expiry_hour = expiry_h;
      m_expiry_min = expiry_m;
      m_magic_number = magic;

      if(!m_is_active) return;

      m_ichimoku_handle = iIchimoku(_Symbol,m_timeframe,InpIchimoku_Tenkan,InpIchimoku_Kijun,InpIchimoku_Senkou);
      if(m_ichimoku_handle == INVALID_HANDLE) if(InpEnableLogging) Print("خطا در ایجاد هندل ایچیموکو برای جلسه " + IntegerToString(magic) + ".");

      m_placement_atr_handle = iATR(_Symbol,m_timeframe,InRangeATR_Period);
      if(m_placement_atr_handle == INVALID_HANDLE) if(InpEnableLogging) Print("خطا در ایجاد هندل ATR قرارگیری برای جلسه " + IntegerToString(magic) + ".");

      m_range_atr_handle = iATR(_Symbol,InRangeATR_TimeFrame,InRangeATR_Period);
      if(m_range_atr_handle == INVALID_HANDLE) if(InpEnableLogging) Print("خطا در ایجاد هندل ATR اعتبارسنجی برای جلسه " + IntegerToString(magic) + ".");

      m_ema_handle = iMA(_Symbol,InpTrendEMATimeFrame,InpTrendEMAPeriod,0,MODE_EMA,InpTrendEMAAppliedPrice);
      if(m_ema_handle == INVALID_HANDLE) if(InpEnableLogging) Print("خطا در ایجاد هندل EMA برای جلسه " + IntegerToString(magic) + ".");

      m_trail_atr_handle = iATR(_Symbol,InpTrailingStopATRTimeFrame,InpTrailingStopATRPeriod);
      if(m_trail_atr_handle == INVALID_HANDLE) if(InpEnableLogging) Print("خطا در ایجاد هندل ATR ترلینگ برای جلسه " + IntegerToString(magic) + ".");

      if(InpEnableLogging) Print("جلسه " + IntegerToString(magic) + " اولیه‌سازی شد.");
     }

   //--- تابع Deinit: برای آزادسازی منابع در زمان حذف اکسپرت.
   void              Deinit(void)
     {
      if(m_ichimoku_handle != INVALID_HANDLE) IndicatorRelease(m_ichimoku_handle);
      if(m_placement_atr_handle != INVALID_HANDLE) IndicatorRelease(m_placement_atr_handle);
      if(m_range_atr_handle != INVALID_HANDLE) IndicatorRelease(m_range_atr_handle);
      if(m_ema_handle != INVALID_HANDLE) IndicatorRelease(m_ema_handle);
      if(m_trail_atr_handle != INVALID_HANDLE) IndicatorRelease(m_trail_atr_handle);
      ObjectsDeleteAll(0,"Range_"+IntegerToString(m_magic_number)+"_");

      if(InpEnableLogging) Print("جلسه " + IntegerToString(m_magic_number) + " خاتمه یافت.");
     }

   //--- تابع OnTimerUpdate: هر ۶۰ ثانیه فراخوانی می‌شود برای تحلیل و پاکسازی.
   void              OnTimerUpdate(void)
     {
      if(!m_is_active) return;

      datetime now = TimeCurrent();
      MqlDateTime now_struct;
      TimeToStruct(now,now_struct);

      //--- چک زمان انقضا برای پاکسازی پوزیشن‌ها و سفارشات.
      if(now_struct.hour == m_expiry_hour && now_struct.min == m_expiry_min)
        {
         SessionCleanUp(m_magic_number);
         if(InpEnableLogging) Print("انقضای جلسه " + IntegerToString(m_magic_number) + " رسید و پاکسازی انجام شد.");
         return;
        }

      MqlDateTime end_dt_struct = now_struct;
      end_dt_struct.hour = m_end_hour;
      end_dt_struct.min = m_end_min;
      end_dt_struct.sec = 0;
      datetime analysis_time = StructToTime(end_dt_struct);

      //--- چک زمان تحلیل و جلوگیری از تکرار در یک روز.
      if(now >= analysis_time && !IsSameDay(m_last_analysis_date,now))
        {
         AnalyzeAndPlaceOrders();
         m_last_analysis_date = now;
         if(InpEnableLogging) Print("تحلیل جلسه " + IntegerToString(m_magic_number) + " در زمان " + TimeToString(now) + " انجام شد.");
        }
     }

   //--- تابع GetMagicNumber: مجیک نامبر جلسه را برمی‌گرداند.
   int               GetMagicNumber(void) { return m_magic_number; }

   //--- تابع ManageActiveTrade: مدیریت معاملات فعال (خروج پله‌ای و ترلینگ استاپ).
   bool              ManageActiveTrade(ulong ticket)
     {
      //--- ابتدا پوزیشن را بر اساس تیکت انتخاب می‌کنیم تا اطلاعات آن را بخوانیم.
      if(!PositionSelectByTicket(ticket)) return false;
      //--- چک می‌کنیم که مجیک نامبر پوزیشن با مجیک نامبر جلسه مطابقت داشته باشد.
      if(PositionGetInteger(POSITION_MAGIC) != m_magic_number) return false;

      //--- اگر خروج پله‌ای غیرفعال باشد، هیچ کاری انجام نمی‌دهیم.
      if(!InpEnablePartialClose) return false;

      //--- خواندن اطلاعات پوزیشن.
      ENUM_POSITION_TYPE pos_type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      double entry_price = PositionGetDouble(POSITION_PRICE_OPEN);
      double current_sl = PositionGetDouble(POSITION_SL);
      double volume = PositionGetDouble(POSITION_VOLUME);
      
      //--- محاسبه قیمت هدف برای خروج پله‌ای بر اساس نسبت سود به ضرر.
      double sl_initial_pips = (pos_type == POSITION_TYPE_BUY) ? (entry_price - current_sl) / _Point : (current_sl - entry_price) / _Point;
      double tp_target_pips = sl_initial_pips * InpTakeProfitRatio_Stage1;
      double tp_target_price = (pos_type == POSITION_TYPE_BUY) ? entry_price + tp_target_pips * _Point : entry_price - tp_target_pips * _Point;

      //--- گرفتن قیمت لحظه‌ای.
      double current_price = (pos_type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      
      //--- مرحله ۱: چک می‌کنیم آیا پوزیشن به هدف سود پله‌ای رسیده و هنوز Breakeven نشده است.
      //--- این شرط تضمین می‌کند که فقط یک بار پله‌ای انجام شود.
      if(InpEnablePartialClose && (pos_type == POSITION_TYPE_BUY && current_price >= tp_target_price && current_sl < entry_price) ||
         (pos_type == POSITION_TYPE_SELL && current_price <= tp_target_price && current_sl > entry_price))
      {
         //--- محاسبه حجم برای بستن پله‌ای.
         double lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
         double min_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
         double volume_to_close_raw = volume * (InpPartialClosePercentage / 100.0);
         double close_volume = MathRound(volume_to_close_raw / lot_step) * lot_step;
         
         //--- اطمینان از حداقل حجم برای بستن.
         if (close_volume < min_lot) close_volume = min_lot;
         //--- اگر حجم باقی‌مانده کمتر از حداقل لات باشد، کل پوزیشن را می‌بندیم.
         if(volume - close_volume < min_lot) close_volume = volume;

         //--- اگر حجم بستن معتبر باشد، اقدام به بستن می‌کنیم.
         if (close_volume >= min_lot)
         {
            if (trade.PositionClose(ticket, close_volume))
            {
               if (InpEnableLogging) Print("خروج پله‌ای موفق: تیکت=" + IntegerToString(ticket) + ", حجم بسته‌شده=" + DoubleToString(close_volume, 2) + ".");
               
               //--- بعد از بستن پله‌ای، استاپ لاس را به نقطه ورود (Breakeven) منتقل می‌کنیم.
               if (PositionSelectByTicket(ticket))
               {
                  trade.PositionModify(ticket, entry_price, 0.0);
                  if(InpEnableLogging) Print("استاپ به breakeven منتقل شد: تیکت=" + IntegerToString(ticket) + ".");
               }
               return true;
            }
         }
      }

      //--- مرحله ۲: ترلینگ استاپ. چک می‌کنیم که استاپ لاس به Breakeven رسیده باشد.
      //--- یک بافر کوچک اضافه می‌کنیم تا از نویز جلوگیری شود.
      if (InpEnablePartialClose && ((pos_type == POSITION_TYPE_BUY && current_sl >= entry_price - _Point) || 
                                    (pos_type == POSITION_TYPE_SELL && current_sl <= entry_price + _Point)))
      {
         //--- خواندن مقدار ATR برای محاسبه فاصله ترلینگ.
         double atr_buffer[1];
         if (CopyBuffer(m_trail_atr_handle, 0, 1, 1, atr_buffer) != 1) return false;
         double trail_offset = atr_buffer[0] * InpTrailingStopATRMultiplier;

         //--- محاسبه استاپ لاس جدید.
         double new_sl = (pos_type == POSITION_TYPE_BUY) ? current_price - trail_offset : current_price + trail_offset;
         
         //--- اگر استاپ لاس جدید بهتر (امن‌تر) از استاپ لاس فعلی باشد، آن را اصلاح می‌کنیم.
         if ((pos_type == POSITION_TYPE_BUY && new_sl > current_sl) || (pos_type == POSITION_TYPE_SELL && new_sl < current_sl))
         {
            if (trade.PositionModify(ticket, new_sl, 0.0))
            {
               if(InpEnableLogging) Print("ترلینگ استاپ بروزرسانی شد: SL جدید=" + DoubleToString(new_sl, _Digits) + ", تیکت=" + IntegerToString(ticket) + ".");
               return true;
            }
         }
      }

      return false;
     }

private:
   //--- تابع IdentifyValidRange: محدوده معتبر را شناسایی و اعتبارسنجی می‌کند.
   bool              IdentifyValidRange(RangeData &rd)
     {
      //--- مقداردهی اولیه به isValid: false.
      rd.isValid = false;
      
      datetime now = TimeCurrent();
      MqlDateTime now_struct;
      TimeToStruct(now,now_struct);

      MqlDateTime end_dt_struct = now_struct;
      end_dt_struct.hour = m_end_hour;
      end_dt_struct.min = m_end_min;
      end_dt_struct.sec = 0;
      datetime end_time = StructToTime(end_dt_struct);

      MqlDateTime start_dt_struct = now_struct;
      start_dt_struct.hour = m_start_hour;
      start_dt_struct.min = m_start_min;
      start_dt_struct.sec = 0;
      datetime start_time = StructToTime(start_dt_struct);

      //--- مدیریت جلسات شبانه (Overnight).
      if(m_start_hour > m_end_hour)
        {
         if(now_struct.hour < m_end_hour) start_time -= 86400;
         else end_time += 86400;
        }
      
      rd.startTime = start_time;
      rd.endTime = end_time;

      //--- یافتن ایندکس کندل‌ها در تایم فریم جلسه.
      int start_bar_idx = iBarShift(_Symbol,m_timeframe,start_time,true);
      int end_bar_idx = iBarShift(_Symbol,m_timeframe,end_time,true);

      if(start_bar_idx < 0 || end_bar_idx < 0) return false;

      int bars_to_check = start_bar_idx - end_bar_idx + 1;
      if(bars_to_check <= 0) return false;

      //--- منطق شناسایی محدوده با فیلتر ایچیموکو.
      if(InpUseIchimokuFilter)
        {
         int max_sequence = 0;
         int current_sequence = 0;
         int sequence_start_idx = -1;
         int best_start_idx = -1;

         for(int i = start_bar_idx; i >= end_bar_idx; i--)
           {
            //--- اگر کندل داخل کومو باشد و کیجون صاف باشد، یک کندل متوالی تعادل داریم.
            if(IsCandleInKumo(m_ichimoku_handle, i, m_timeframe) && IsKijunFlat(m_ichimoku_handle, i, m_timeframe))
              {
               if(current_sequence == 0) sequence_start_idx = i;
               current_sequence++;
              }
            else
              {
               if(current_sequence > max_sequence)
                 {
                  max_sequence = current_sequence;
                  best_start_idx = sequence_start_idx;
                 }
               current_sequence = 0;
              }
           }
           
           if(current_sequence > max_sequence)
             {
              max_sequence = current_sequence;
              best_start_idx = sequence_start_idx;
             }
           
           //--- اگر تعداد کندل‌های متوالی به حداقل موردنیاز رسیده باشد.
           if(max_sequence >= InpMinConsecutiveCandles)
             {
              int high_bar_idx = iHighest(_Symbol,m_timeframe,MODE_HIGH,max_sequence,best_start_idx);
              int low_bar_idx = iLowest(_Symbol,m_timeframe,MODE_LOW,max_sequence,best_start_idx);
              
              if(high_bar_idx != -1 && low_bar_idx != -1)
                {
                 rd.rangeHigh = iHigh(_Symbol,m_timeframe,high_bar_idx);
                 rd.rangeLow = iLow(_Symbol,m_timeframe,low_bar_idx);
                 rd.rangeSizePips = (rd.rangeHigh - rd.rangeLow) / _Point;
                 //--- چک اعتبارسنجی محدوده
                 if (IsRangeSizeValid(rd.rangeSizePips)) rd.isValid = true;
                }
             }
        }
      else //--- منطق شناسایی محدوده بدون فیلتر ایچیموکو.
        {
         int high_bar_idx = iHighest(_Symbol,m_timeframe,MODE_HIGH,bars_to_check,end_bar_idx);
         int low_bar_idx = iLowest(_Symbol,m_timeframe,MODE_LOW,bars_to_check,end_bar_idx);
         
         if(high_bar_idx != -1 && low_bar_idx != -1)
           {
            rd.rangeHigh = iHigh(_Symbol,m_timeframe,high_bar_idx);
            rd.rangeLow = iLow(_Symbol,m_timeframe,low_bar_idx);
            rd.rangeSizePips = (rd.rangeHigh - rd.rangeLow) / _Point;
            //--- چک اعتبارسنجی محدوده
            if (IsRangeSizeValid(rd.rangeSizePips)) rd.isValid = true;
           }
        }
      return rd.isValid;
     }

   //--- تابع AnalyzeAndPlaceOrders: محدوده را تحلیل و سفارشات را قرار می‌دهد.
   void              AnalyzeAndPlaceOrders(void)
     {
      RangeData rd;
      if(!IdentifyValidRange(rd))
        {
         if(InpEnableLogging) Print("محدوده نامعتبر در جلسه " + IntegerToString(m_magic_number) + ". تحلیل متوقف شد.");
         return;
        }

      DrawRangeOnChart(rd,m_magic_number);

      bool is_trend_on = InpTrendFilterIsOn;
      bool is_uptrend = false;

      if(is_trend_on)
        {
         double ema_buffer[1];
         if(CopyBuffer(m_ema_handle,0,1,1,ema_buffer) == 1)
           {
            double current_price = SymbolInfoDouble(_Symbol,SYMBOL_BID);
            is_uptrend = current_price > ema_buffer[0];
            if(InpEnableLogging) Print("فیلتر روند: " + (is_uptrend ? "صعودی" : "نزولی") + " (قیمت=" + DoubleToString(current_price, _Digits) + ", EMA=" + DoubleToString(ema_buffer[0], _Digits) + ") در جلسه " + IntegerToString(m_magic_number) + ".");
           }
         else
          {
           if(InpEnableLogging) Print("خطا در کپی بافر EMA در جلسه " + IntegerToString(m_magic_number) + ".");
          }
        }

      double atr_buffer[1];
      if(CopyBuffer(m_placement_atr_handle,0,1,1,atr_buffer) != 1)
        {
         if(InpEnableLogging) Print("خطا در کپی بافر ATR قرارگیری در جلسه " + IntegerToString(m_magic_number) + ".");
         return;
        }
      double atr_value = atr_buffer[0];
      double buffer = atr_value * InpAtrMultiplier_Placement;

      double buy_stop_price = rd.rangeHigh + buffer;
      double sell_stop_price = rd.rangeLow - buffer;

      double current_bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
      double current_ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
      //--- چک ایمنی برای جلوگیری از ورود در صورت عبور قیمت از محدوده.
      if((is_trend_on && is_uptrend && current_ask >= buy_stop_price) ||
         (is_trend_on && !is_uptrend && current_bid <= sell_stop_price) ||
         (!is_trend_on && (current_ask >= buy_stop_price || current_bid <= sell_stop_price)))
         {
          if(InpEnableLogging) Print("Safety check: قیمت قبلاً از محدوده عبور کرده - سفارش قرار نمی‌گیرد (جلسه " + IntegerToString(m_magic_number) + ").");
          return;
         }

      //--- قرار دادن سفارشات پندینگ.
      PlacePendingOrders(m_magic_number,is_trend_on,is_uptrend,rd,buy_stop_price,sell_stop_price);
     }

   //--- تابع IsSameDay: چک می‌کند آیا دو تاریخ در یک روز هستند.
   bool              IsSameDay(datetime d1,datetime d2)
     {
      MqlDateTime s1,s2;
      TimeToStruct(d1,s1);
      TimeToStruct(d2,s2);
      return (s1.year == s2.year && s1.mon == s2.mon && s1.day == s2.day);
     }

   //--- تابع کمکی برای چک اعتبار اندازه محدوده.
   bool IsRangeSizeValid(double range_size_pips)
     {
      //--- چک در حالت پوینت ثابت.
      if (InpRangeFilterMode == MODE_POINTS)
      {
         return (range_size_pips >= InpMinRangePoints && range_size_pips <= InpMaxRangePoints);
      }
      //--- چک در حالت ATR دینامیک.
      else if (InpRangeFilterMode == MODE_ATR)
      {
         double atr_buffer[1];
         if (CopyBuffer(m_range_atr_handle, 0, 1, 1, atr_buffer) == 1)
         {
            double atr_value = atr_buffer[0];
            if (atr_value > 0)
            {
               double min_allowed = (atr_value * InRangeATR_MinMultiplier) / _Point;
               double max_allowed = (atr_value * InRangeATR_MaxMultiplier) / _Point;
               return (range_size_pips >= min_allowed && range_size_pips <= max_allowed);
            }
         }
      }
      return false;
     }
  };

#endif //SESSIONTRADER_MQH
