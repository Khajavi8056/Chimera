محمد جان، رفیقِ کار درست! عالیه که بالاخره به یه نقطه مشترک رسیدیم. 🤝🏻 آره، منطقت کاملاً درسته. دقیقاً مشکل اینه که اون شرط is_stage1 همیشه فعاله و کد نمی‌تونه از اون مرحله عبور کنه. برای همین تو داری سودهای بزرگ رو می‌بینی ولی هیچ‌وقت مدیریت معامله فعال نمیشه.
پس با خیال راحت برو، درستش می‌کنیم. من الان اون بخش‌های کدی که مشکل داشتن رو برات بازنویسی می‌کنم.
اصلاحات کد
این اصلاحات رو دقیقاً در فایل‌های مربوطه جایگزین کن:
فایل: hipobreck.mq5
این فایل رو به همون حالت اولیه که فرستادی برگردوندم، فقط اون break داخل OnTick رو حذف کردم. این کار باعث میشه که کد همه پوزیشن‌ها رو بررسی کنه، حتی اگر چندین معامله باز داشته باشی.
//+------------------------------------------------------------------+
//|                                                   hipobreck.mq5 |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy      |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy"
#property link      "https://..."
#property version   "3.00"
#property strict

#include "Settings.mqh"
#include "SessionTrader.mqh"
#include <Trade\Trade.mqh>

CSessionTrader g_sessions[4];

int OnInit()
  {
   long account_mode = AccountInfoInteger(ACCOUNT_MARGIN_MODE);
   if(account_mode != ACCOUNT_MARGIN_MODE_RETAIL_HEDGING)
     {
      if(InpEnableLogging) Print("هشدار: حساب netting است - partial close ممکن است کار نکند. پیشنهاد: حساب hedging استفاده کنید.");
     }

   g_sessions[0].Init(InpS1_IsActive, InpS1_TimeFrame, InpS1_StartTime_Hour, InpS1_StartTime_Minute,
                      InpS1_EndTime_Hour, InpS1_EndTime_Minute, InpS1_ExpiryTime_Hour, InpS1_ExpiryTime_Minute, S1_MagicNumber);
   g_sessions[1].Init(InpS2_IsActive, InpS2_TimeFrame, InpS2_StartTime_Hour, InpS2_StartTime_Minute,
                      InpS2_EndTime_Hour, InpS2_EndTime_Minute, InpS2_ExpiryTime_Hour, InpS2_ExpiryTime_Minute, S2_MagicNumber);
   g_sessions[2].Init(InpS3_IsActive, InpS3_TimeFrame, InpS3_StartTime_Hour, InpS3_StartTime_Minute,
                      InpS3_EndTime_Hour, InpS3_EndTime_Minute, InpS3_ExpiryTime_Hour, InpS3_ExpiryTime_Minute, S3_MagicNumber);
   g_sessions[3].Init(InpS4_IsActive, InpS4_TimeFrame, InpS4_StartTime_Hour, InpS4_StartTime_Minute,
                      InpS4_EndTime_Hour, InpS4_EndTime_Minute, InpS4_ExpiryTime_Hour, InpS4_ExpiryTime_Minute, S4_MagicNumber);

   if(InpEnableLogging) Print("اکسپرت اولیه‌سازی شد. تعداد جلسات فعال: " + IntegerToString(CountActiveSessions()));

   EventSetTimer(60);

   return(INIT_SUCCEEDED);
  }

void OnDeinit(const int reason)
  {
   EventKillTimer();

   for(int i = 0; i < 4; i++) g_sessions[i].Deinit();

   if(InpEnableLogging) Print("اکسپرت خاتمه یافت. دلیل: " + IntegerToString(reason));
  }

void OnTimer()
  {
   for(int i = 0; i < 4; i++) g_sessions[i].OnTimerUpdate();
  }

void OnTick()
  {
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0 && PositionSelectByTicket(ticket))
        {
         long magic = PositionGetInteger(POSITION_MAGIC);
         bool managed = false;

         for(int j = 0; j < 4; j++)
           {
            if(g_sessions[j].GetMagicNumber() == magic)
              {
               managed = g_sessions[j].ManageActiveTrade(ticket);
               if(InpEnableLogging && managed) Print("پوزیشن با تیکت " + IntegerToString(ticket) + " مدیریت شد (مجیک: " + IntegerToString(magic) + ").");
               // اینجا break حذف شده تا همه پوزیشن‌ها چک شوند.
              }
           }
        }
     }
  }

void OnTradeTransaction(const MqlTradeTransaction &trans, const MqlTradeRequest &request, const MqlTradeResult &result)
  {
   if(trans.type == TRADE_TRANSACTION_DEAL_ADD)
     {
      if(HistoryDealSelect(trans.deal))
        {
         if(HistoryDealGetInteger(trans.deal, DEAL_ENTRY) == DEAL_ENTRY_IN)
           {
            long magic = HistoryDealGetInteger(trans.deal, DEAL_MAGIC);
            for(int i = OrdersTotal() - 1; i >= 0; i--)
              {
               ulong order_ticket = OrderGetTicket(i);
               if(order_ticket > 0 && OrderSelect(order_ticket))
                 {
                  if(OrderGetInteger(ORDER_MAGIC) == magic)
                    {
                     trade.OrderDelete(order_ticket);
                     if(InpEnableLogging) Print("سفارش معکوس با تیکت " + IntegerToString(order_ticket) + " حذف شد (مجیک: " + IntegerToString(magic) + ").");
                    }
                 }
              }
           }
        }
     }
  }

double OnTester()
  {
   double total_trades = TesterStatistics(STAT_TRADES);
   double net_profit = TesterStatistics(STAT_PROFIT);
   double profit_factor = TesterStatistics(STAT_PROFIT_FACTOR);
   double sharpe_ratio = TesterStatistics(STAT_SHARPE_RATIO);
   double max_balance_drawdown_percent = TesterStatistics(STAT_BALANCE_DDREL_PERCENT);

   datetime startDate = 0, endDate = 0;
   if(HistoryDealsTotal() > 0)
     {
      startDate = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(0), DEAL_TIME);
      endDate = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(HistoryDealsTotal() - 1), DEAL_TIME);
     }
   double duration_days = (endDate > startDate) ? double(endDate - startDate) / (24.0 * 3600.0) : 1.0;
   double required_min_trades = MathFloor((duration_days / 365.0) * InpMinTradesPerYear);
   if(required_min_trades < 10) required_min_trades = 10;

   if(total_trades < required_min_trades || profit_factor < 1.1 || sharpe_ratio <= 0 || net_profit <= 0) return 0.0;

   double r_squared = 0, downside_consistency = 0;
   CalculateAdvancedMetrics(r_squared, downside_consistency);

   double drawdown_penalty_factor = 0.0;
   if(max_balance_drawdown_percent < InpMaxAcceptableDrawdown && InpMaxAcceptableDrawdown > 0)
     {
      double angle = (max_balance_drawdown_percent / InpMaxAcceptableDrawdown) * (M_PI / 2.0);
      drawdown_penalty_factor = MathCos(angle);
     }

   double final_score = 0.0;
   if(drawdown_penalty_factor > 0)
     {
      double trades_factor = MathLog(total_trades + 1);
      double net_profit_factor = MathLog(net_profit + 1);
      final_score = (profit_factor * sharpe_ratio * r_squared * downside_consistency * trades_factor * net_profit_factor) * drawdown_penalty_factor;
     }

   if(InpEnableLogging)
     {
      PrintFormat("نتیجه بهینه‌سازی: معاملات=%d, فاکتور سود=%.2f, شارپ=%.2f, R²=%.3f, دراوداون=%.2f%%, جریمه=%.2f -> امتیاز: %.4f",
                  (int)total_trades, profit_factor, sharpe_ratio, r_squared, max_balance_drawdown_percent, drawdown_penalty_factor, final_score);
     }

   return final_score;
  }

void CalculateAdvancedMetrics(double &r_squared, double &downside_consistency)
  {
   r_squared = 0;
   downside_consistency = 1.0;

   if(!HistorySelect(0, TimeCurrent())) return;
   uint total_deals = HistoryDealsTotal();
   if(total_deals < 5) return;

   struct EquityPoint { datetime time; double balance; };
   EquityPoint equity_curve[];
   ArrayResize(equity_curve, (int)total_deals + 2);

   double final_balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double net_profit = TesterStatistics(STAT_PROFIT);
   double initial_balance = final_balance - net_profit;

   double current_balance = initial_balance;
   equity_curve[0].time = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(0), DEAL_TIME) - 1;
   equity_curve[0].balance = current_balance;

   int equity_points = 1;
   for(uint i = 0; i < total_deals; i++)
     {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0)
        {
         if(HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
           {
            current_balance += HistoryDealGetDouble(ticket, DEAL_PROFIT) +
                               HistoryDealGetDouble(ticket, DEAL_COMMISSION) +
                               HistoryDealGetDouble(ticket, DEAL_SWAP);
            equity_curve[equity_points].time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
            equity_curve[equity_points].balance = current_balance;
            equity_points++;
           }
        }
     }
   ArrayResize(equity_curve, equity_points);
   if(equity_points < 3) return;

   double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0, sum_y2 = 0;
   for(int i = 0; i < equity_points; i++)
     {
      double x = i + 1.0;
      double y = equity_curve[i].balance;
      sum_x += x;
      sum_y += y;
      sum_xy += x * y;
      sum_x2 += x * x;
      sum_y2 += y * y;
     }
   double n = equity_points;
   double den_part1 = (n * sum_x2) - (sum_x * sum_x);
   double den_part2 = (n * sum_y2) - (sum_y * sum_y);
   if(den_part1 > 0 && den_part2 > 0)
     {
      double r = ((n * sum_xy) - (sum_x * sum_y)) / MathSqrt(den_part1 * den_part2);
      r_squared = r * r;
     }

   struct MonthlyTrades { int year; int month; int count; };
   MonthlyTrades monthly_counts[];
   int total_months = 0;

   for(uint i = 0; i < total_deals; i++)
     {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
        {
         datetime deal_time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
         MqlDateTime dt;
         TimeToStruct(deal_time, dt);

         int month_idx = -1;
         for(int j = 0; j < total_months; j++)
           {
            if(monthly_counts[j].year == dt.year && monthly_counts[j].month == dt.mon)
              {
               month_idx = j;
               break;
              }
           }

         if(month_idx == -1)
           {
            ArrayResize(monthly_counts, total_months + 1);
            monthly_counts[total_months].year = dt.year;
            monthly_counts[total_months].month = dt.mon;
            monthly_counts[total_months].count = 1;
            total_months++;
           }
         else
           {
            monthly_counts[month_idx].count++;
           }
        }
     }

   if(total_months <= 1)
     {
      downside_consistency = 1.0;
      return;
     }

   double target_trades_per_month = InpMinTradesPerYear / 12.0;
   if(target_trades_per_month < 1) target_trades_per_month = 1;

   double sum_of_squared_downside_dev = 0;
   for(int i = 0; i < total_months; i++)
     {
      if(monthly_counts[i].count < target_trades_per_month)
        {
         double deviation = target_trades_per_month - monthly_counts[i].count;
         sum_of_squared_downside_dev += deviation * deviation;
        }
     }

   double downside_variance = sum_of_squared_downside_dev / total_months;
   double downside_deviation = MathSqrt(downside_variance);
   downside_consistency = 1.0 / (1.0 + downside_deviation);
  }

int CountActiveSessions()
  {
   int count = 0;
   if(InpS1_IsActive) count++;
   if(InpS2_IsActive) count++;
   if(InpS3_IsActive) count++;
   if(InpS4_IsActive) count++;
   return count;
  }

فایل: SessionTrader.mqh
اینجا همون‌طور که خودت گفتی، منطق is_stage1 و is_stage2 رو کاملاً حذف کردم و به جاش از دو تا متغیر bool به نام‌های m_partial_closed و m_breakeven_set استفاده کردم. این متغیرها وضعیت هر معامله رو به صورت دقیق پیگیری می‌کنن.
//+------------------------------------------------------------------+
//|                                             SessionTrader.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy"
#property link      "https://..."

#ifndef SESSIONTRADER_MQH
#define SESSIONTRADER_MQH

#include "Settings.mqh"
#include "RangeLib.mqh"
#include "TradeManager.mqh"

class CSessionTrader
  {
private:
   bool              m_is_active;
   int               m_magic_number;
   ENUM_TIMEFRAMES   m_timeframe;
   int               m_start_hour, m_start_min;
   int               m_end_hour, m_end_min;
   int               m_expiry_hour, m_expiry_min;

   int               m_ichimoku_handle;
   int               m_placement_atr_handle;
   int               m_range_atr_handle;
   int               m_ema_handle;
   int               m_trail_atr_handle;

   datetime          m_last_analysis_date;
   bool              m_partial_closed;
   bool              m_breakeven_set;

public:
                     CSessionTrader(void) : m_is_active(false), m_magic_number(0), m_timeframe(PERIOD_M15),
                     m_start_hour(0),m_start_min(0), m_end_hour(0),m_end_min(0), m_expiry_hour(0),m_expiry_min(0),
                     m_ichimoku_handle(INVALID_HANDLE), m_placement_atr_handle(INVALID_HANDLE), m_range_atr_handle(INVALID_HANDLE),
                     m_ema_handle(INVALID_HANDLE), m_trail_atr_handle(INVALID_HANDLE), m_last_analysis_date(0),
                     m_partial_closed(false), m_breakeven_set(false) {}

   void              Init(bool is_active,ENUM_TIMEFRAMES timeframe,int start_h,int start_m,int end_h,int end_m,int expiry_h,int expiry_m,int magic)
     {
      m_is_active = is_active;
      m_timeframe = timeframe;
      m_start_hour = start_h;
      m_start_min = start_m;
      m_end_hour = end_h;
      m_end_min = end_m;
      m_expiry_hour = expiry_h;
      m_expiry_min = expiry_m;
      m_magic_number = magic;

      if(!m_is_active) return;

      m_ichimoku_handle = iIchimoku(_Symbol,m_timeframe,InpIchimoku_Tenkan,InpIchimoku_Kijun,InpIchimoku_Senkou);
      if(m_ichimoku_handle == INVALID_HANDLE)
        {
         if(InpEnableLogging) Print("خطا در ایجاد هندل ایچیموکو برای جلسه " + IntegerToString(magic) + ".");
        }

      m_placement_atr_handle = iATR(_Symbol,m_timeframe,InRangeATR_Period);
      if(m_placement_atr_handle == INVALID_HANDLE)
        {
         if(InpEnableLogging) Print("خطا در ایجاد هندل ATR قرارگیری برای جلسه " + IntegerToString(magic) + ".");
        }

      m_range_atr_handle = iATR(_Symbol,InRangeATR_TimeFrame,InRangeATR_Period);
      if(m_range_atr_handle == INVALID_HANDLE)
        {
         if(InpEnableLogging) Print("خطا در ایجاد هندل ATR اعتبارسنجی برای جلسه " + IntegerToString(magic) + ".");
        }

      m_ema_handle = iMA(_Symbol,InpTrendEMATimeFrame,InpTrendEMAPeriod,0,MODE_EMA,InpTrendEMAAppliedPrice);
      if(m_ema_handle == INVALID_HANDLE)
        {
         if(InpEnableLogging) Print("خطا در ایجاد هندل EMA برای جلسه " + IntegerToString(magic) + ".");
        }

      m_trail_atr_handle = iATR(_Symbol,InpTrailingStopATRTimeFrame,InpTrailingStopATRPeriod);
      if(m_trail_atr_handle == INVALID_HANDLE)
        {
         if(InpEnableLogging) Print("خطا در ایجاد هندل ATR ترلینگ برای جلسه " + IntegerToString(magic) + ".");
        }

      if(InpEnableLogging) Print("جلسه " + IntegerToString(magic) + " اولیه‌سازی شد.");
     }

   void              Deinit(void)
     {
      if(m_ichimoku_handle != INVALID_HANDLE) IndicatorRelease(m_ichimoku_handle);
      if(m_placement_atr_handle != INVALID_HANDLE) IndicatorRelease(m_placement_atr_handle);
      if(m_range_atr_handle != INVALID_HANDLE) IndicatorRelease(m_range_atr_handle);
      if(m_ema_handle != INVALID_HANDLE) IndicatorRelease(m_ema_handle);
      if(m_trail_atr_handle != INVALID_HANDLE) IndicatorRelease(m_trail_atr_handle);
      ObjectsDeleteAll(0,"Range_"+IntegerToString(m_magic_number)+"_");

      if(InpEnableLogging) Print("جلسه " + IntegerToString(m_magic_number) + " خاتمه یافت.");
     }

   void              OnTimerUpdate(void)
     {
      if(!m_is_active) return;

      datetime now = TimeCurrent();
      MqlDateTime now_struct;
      TimeToStruct(now,now_struct);

      if(now_struct.hour == m_expiry_hour && now_struct.min == m_expiry_min)
        {
         SessionCleanUp(m_magic_number);
         if(InpEnableLogging) Print("انقضای جلسه " + IntegerToString(m_magic_number) + " رسید و پاکسازی انجام شد.");
         return;
        }

      MqlDateTime end_struct = now_struct;
      end_dt_struct.hour = m_end_hour;
      end_dt_struct.min = m_end_min;
      end_dt_struct.sec = 0;
      datetime analysis_time = StructToTime(end_dt_struct);

      if(now >= analysis_time && !IsSameDay(m_last_analysis_date,now))
        {
         AnalyzeAndPlaceOrders();
         m_last_analysis_date = now;
         if(InpEnableLogging) Print("تحلیل جلسه " + IntegerToString(m_magic_number) + " در زمان " + TimeToString(now) + " انجام شد.");
        }
     }

   int               GetMagicNumber(void) { return m_magic_number; }

   bool              ManageActiveTrade(ulong ticket)
     {
      if(!PositionSelectByTicket(ticket))
        {
         if(InpEnableLogging) Print("خطا در انتخاب پوزیشن با تیکت " + IntegerToString(ticket) + ".");
         return false;
        }

      long current_magic = PositionGetInteger(POSITION_MAGIC);
      if(current_magic != m_magic_number) return false;

      if(!InpEnablePartialClose) return false;

      double entry_price = PositionGetDouble(POSITION_PRICE_OPEN);
      double current_sl = PositionGetDouble(POSITION_SL);
      double volume = PositionGetDouble(POSITION_VOLUME);
      ENUM_POSITION_TYPE pos_type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      
      //--- محاسبه سود پوزیشن به پیپ برای تصمیم‌گیری دقیق
      double profit_pips = 0;
      if (pos_type == POSITION_TYPE_BUY) profit_pips = (SymbolInfoDouble(_Symbol, SYMBOL_BID) - entry_price) / _Point;
      else profit_pips = (entry_price - SymbolInfoDouble(_Symbol, SYMBOL_ASK)) / _Point;

      //--- محاسبه فاصله استاپ لاس از قیمت ورود به پیپ
      double sl_distance_pips = MathAbs(entry_price - current_sl) / _Point;
      
      //--- منطق خروج پله‌ای
      if (!m_partial_closed)
      {
          if (profit_pips >= sl_distance_pips * InpTakeProfitRatio_Stage1)
          {
              double lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
              double min_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
              double close_volume = MathRound((volume * (InpPartialClosePercentage / 100.0)) / lot_step) * lot_step;

              if (volume - close_volume < min_lot && volume > min_lot) close_volume = volume;

              if (close_volume >= min_lot)
              {
                  if (trade.PositionClose(ticket, close_volume))
                  {
                      if (InpEnableLogging) Print("خروج پله‌ای موفق: تیکت=" + IntegerToString(ticket) + ", حجم بسته‌شده=" + DoubleToString(close_volume, 2) + ".");
                      m_partial_closed = true;
                      
                      //--- انتقال استاپ به بریک ایون بعد از بستن پله‌ای
                      if (PositionSelectByTicket(ticket))
                      {
                          trade.PositionModify(ticket, entry_price, 0.0);
                          if (InpEnableLogging) Print("استاپ به breakeven منتقل شد: تیکت=" + IntegerToString(ticket) + ".");
                          m_breakeven_set = true;
                      }
                      return true;
                  }
                  else
                  {
                      if (InpEnableLogging) Print("خطا در خروج پله‌ای: تیکت=" + IntegerToString(ticket) + ".");
                      return false;
                  }
              }
          }
      }
      
      //--- منطق ترلینگ استاپ
      if (m_breakeven_set)
      {
          double atr_buffer[1];
          if(m_trail_atr_handle == INVALID_HANDLE || CopyBuffer(m_trail_atr_handle, 0, 1, 1, atr_buffer) != 1)
          {
             if(InpEnableLogging) Print("خطا در کپی بافر ATR ترلینگ: تیکت=" + IntegerToString(ticket) + ".");
             return false;
          }
          double trail_offset = atr_buffer[0] * InpTrailingStopATRMultiplier;
          
          if (pos_type == POSITION_TYPE_BUY)
          {
              double current_bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
              double new_sl = current_bid - trail_offset;
              if (new_sl > current_sl)
              {
                  if(trade.PositionModify(ticket, new_sl, 0.0))
                  {
                      if (InpEnableLogging) Print("ترلینگ استاپ بروزرسانی شد (خرید): SL جدید=" + DoubleToString(new_sl, _Digits) + ", تیکت=" + IntegerToString(ticket) + ".");
                      return true;
                  }
              }
          }
          else if (pos_type == POSITION_TYPE_SELL)
          {
              double current_ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
              double new_sl = current_ask + trail_offset;
              if (new_sl < current_sl)
              {
                  if(trade.PositionModify(ticket, new_sl, 0.0))
                  {
                      if (InpEnableLogging) Print("ترلینگ استاپ بروزرسانی شد (فروش): SL جدید=" + DoubleToString(new_sl, _Digits) + ", تیکت=" + IntegerToString(ticket) + ".");
                      return true;
                  }
              }
          }
      }
      return false;
     }

   void              AnalyzeAndPlaceOrders(void)
     {
      RangeData rd;
      if(!IdentifyValidRange(rd))
        {
         if(InpEnableLogging) Print("محدوده نامعتبر در جلسه " + IntegerToString(m_magic_number) + ". تحلیل متوقف شد.");
         return;
        }

      DrawRangeOnChart(rd,m_magic_number);

      bool is_trend_on = InpTrendFilterIsOn;
      bool is_uptrend = false;

      if(is_trend_on)
        {
         double ema_buffer[1];
         if(CopyBuffer(m_ema_handle,0,1,1,ema_buffer) == 1)
           {
            double current_price = SymbolInfoDouble(_Symbol,SYMBOL_BID);
            is_uptrend = current_price > ema_buffer[0];
            if(InpEnableLogging) Print("فیلتر روند: " + (is_uptrend ? "صعودی" : "نزولی") + " (قیمت=" + DoubleToString(current_price, _Digits) + ", EMA=" + DoubleToString(ema_buffer[0], _Digits) + ") در جلسه " + IntegerToString(m_magic_number) + ".");
           }
         else
          {
           if(InpEnableLogging) Print("خطا در کپی بافر EMA در جلسه " + IntegerToString(m_magic_number) + ".");
          }
        }

      double atr_buffer[1];
      if(CopyBuffer(m_placement_atr_handle,0,1,1,atr_buffer) != 1)
        {
         if(InpEnableLogging) Print("خطا در کپی بافر ATR قرارگیری در جلسه " + IntegerToString(m_magic_number) + ".");
         return;
        }
      double atr_value = atr_buffer[0];
      double buffer = atr_value * InpAtrMultiplier_Placement;

      double buy_stop_price = rd.rangeHigh + buffer;
      double sell_stop_price = rd.rangeLow - buffer;

      double current_bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
      double current_ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
      if((is_trend_on && is_uptrend && current_ask >= buy_stop_price) ||
         (is_trend_on && !is_uptrend && current_bid <= sell_stop_price) ||
         (!is_trend_on && (current_ask >= buy_stop_price || current_bid <= sell_stop_price)))
         {
          if(InpEnableLogging) Print("Safety check: قیمت قبلاً از محدوده عبور کرده - سفارش قرار نمی‌گیرد (جلسه " + IntegerToString(m_magic_number) + ").");
          return;
         }

      PlacePendingOrders(m_magic_number,is_trend_on,is_uptrend,rd,buy_stop_price,sell_stop_price);
      
      //--- ریست کردن متغیرهای وضعیت برای معامله جدید
      m_partial_closed = false;
      m_breakeven_set = false;
     }

   bool              IsSameDay(datetime d1,datetime d2)
     {
      MqlDateTime s1,s2;
      TimeToStruct(d1,s1);
      TimeToStruct(d2,s2);
      return (s1.year == s2.year && s1.mon == s2.mon && s1.day == s2.day);
     }
  };

#endif //SESSIONTRADER_MQH

