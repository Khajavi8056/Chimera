//+------------------------------------------------------------------+
//|                                             SessionTrader.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy"
#property link      "https://..."

#ifndef SESSIONTRADER_MQH
#define SESSIONTRADER_MQH

#include "Settings.mqh"
#include "RangeLib.mqh"
#include "TradeManager.mqh"
#include <Trade\PositionInfo.mqh> // Add this for PositionInfo.
#include <Trade\TerminalInfo.mqh> // Add this for TerminalInfo.

//+------------------------------------------------------------------+
//| Class CSessionTrader                                             |
//+------------------------------------------------------------------+
class CSessionTrader
  {
private:
   bool              m_is_active;
   int               m_magic_number;
   ENUM_TIMEFRAMES   m_timeframe;
   int               m_start_hour, m_start_min;
   int               m_end_hour, m_end_min;
   int               m_expiry_hour, m_expiry_min;

   int               m_ichimoku_handle;
   int               m_placement_atr_handle;
   int               m_range_atr_handle;
   int               m_ema_handle;
   int               m_trail_atr_handle;

   datetime          m_last_analysis_date;

public:
                     CSessionTrader(void) : m_is_active(false), m_magic_number(0), m_timeframe(PERIOD_M15),
                     m_start_hour(0),m_start_min(0), m_end_hour(0),m_end_min(0), m_expiry_hour(0),m_expiry_min(0),
                     m_ichimoku_handle(INVALID_HANDLE), m_placement_atr_handle(INVALID_HANDLE), m_range_atr_handle(INVALID_HANDLE),
                     m_ema_handle(INVALID_HANDLE), m_trail_atr_handle(INVALID_HANDLE), m_last_analysis_date(0) {}

   void              Init(bool is_active,ENUM_TIMEFRAMES timeframe,int start_h,int start_m,int end_h,int end_m,int expiry_h,int expiry_m,int magic)
     {
      m_is_active = is_active;
      m_timeframe = timeframe;
      m_start_hour = start_h;
      m_start_min = start_m;
      m_end_hour = end_h;
      m_end_min = end_m;
      m_expiry_hour = expiry_h;
      m_expiry_min = expiry_m;
      m_magic_number = magic;

      if(!m_is_active) return;

      m_ichimoku_handle = iIchimoku(_Symbol,m_timeframe,InpIchimoku_Tenkan,InpIchimoku_Kijun,InpIchimoku_Senkou);
      if(m_ichimoku_handle == INVALID_HANDLE) Print("خطا در ایجاد هندل ایچیموکو برای جلسه " + IntegerToString(magic) + ".");

      m_placement_atr_handle = iATR(_Symbol,m_timeframe,InRangeATR_Period);
      if(m_placement_atr_handle == INVALID_HANDLE) Print("خطا در ایجاد هندل ATR قرارگیری برای جلسه " + IntegerToString(magic) + ".");

      m_range_atr_handle = iATR(_Symbol,InRangeATR_TimeFrame,InRangeATR_Period);
      if(m_range_atr_handle == INVALID_HANDLE) Print("خطا در ایجاد هندل ATR اعتبارسنجی برای جلسه " + IntegerToString(magic) + ".");

      m_ema_handle = iMA(_Symbol,InpTrendEMATimeFrame,InpTrendEMAPeriod,0,MODE_EMA,InpTrendEMAAppliedPrice);
      if(m_ema_handle == INVALID_HANDLE) Print("خطا در ایجاد هندل EMA برای جلسه " + IntegerToString(magic) + ".");

      m_trail_atr_handle = iATR(_Symbol,InpTrailingStopATRTimeFrame,InpTrailingStopATRPeriod);
      if(m_trail_atr_handle == INVALID_HANDLE) Print("خطا در ایجاد هندل ATR ترلینگ برای جلسه " + IntegerToString(magic) + ".");

      if(InpEnableLogging) Print("جلسه " + IntegerToString(magic) + " اولیه‌سازی شد.");
     }

   void              Deinit(void)
     {
      if(m_ichimoku_handle != INVALID_HANDLE) IndicatorRelease(m_ichimoku_handle);
      if(m_placement_atr_handle != INVALID_HANDLE) IndicatorRelease(m_placement_atr_handle);
      if(m_range_atr_handle != INVALID_HANDLE) IndicatorRelease(m_range_atr_handle);
      if(m_ema_handle != INVALID_HANDLE) IndicatorRelease(m_ema_handle);
      if(m_trail_atr_handle != INVALID_HANDLE) IndicatorRelease(m_trail_atr_handle);
      ObjectsDeleteAll(0,"Range_"+IntegerToString(m_magic_number)+"_");

      if(InpEnableLogging) Print("جلسه " + IntegerToString(m_magic_number) + " خاتمه یافت.");
     }

   void              OnTimerUpdate(void)
     {
      if(!m_is_active) return;

      datetime now = TimeCurrent();
      MqlDateTime now_struct;
      TimeToStruct(now,now_struct);

      if(now_struct.hour == m_expiry_hour && now_struct.min == m_expiry_min)
        {
         SessionCleanUp(m_magic_number);
         if(InpEnableLogging) Print("انقضای جلسه " + IntegerToString(m_magic_number) + " رسید و پاکسازی انجام شد.");
         return;
        }

      MqlDateTime end_dt_struct = now_struct;
      end_dt_struct.hour = m_end_hour;
      end_dt_struct.min = m_end_min;
      end_dt_struct.sec = 0;
      datetime analysis_time = StructToTime(end_dt_struct);

      if(now >= analysis_time && !IsSameDay(m_last_analysis_date,now))
        {
         AnalyzeAndPlaceOrders();
         m_last_analysis_date = now;
         if(InpEnableLogging) Print("تحلیل جلسه " + IntegerToString(m_magic_number) + " در زمان " + TimeToString(now) + " انجام شد.");
        }
     }

   int               GetMagicNumber(void) { return m_magic_number; }

   bool              ManageActiveTrade(ulong ticket)
     {
      if(!PositionSelectByTicket(ticket)) return false;
      if(PositionGetInteger(POSITION_MAGIC) != m_magic_number) return false;

      // Get trade properties
      ENUM_POSITION_TYPE pos_type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      double entry_price = PositionGetDouble(POSITION_PRICE_OPEN);
      double current_sl = PositionGetDouble(POSITION_SL);
      double current_price = (pos_type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double volume = PositionGetDouble(POSITION_VOLUME);
      
      double stop_loss_initial = PositionGetDouble(POSITION_SL);
      string comment = PositionGetString(POSITION_COMMENT);

      // Stage 1: Partial Close and Breakeven
      if (InpEnablePartialClose && StringFind(comment, "Stage1") != -1)
      {
         double sl_distance_price = MathAbs(entry_price - stop_loss_initial);
         double target_price = (pos_type == POSITION_TYPE_BUY) ? entry_price + sl_distance_price * InpTakeProfitRatio_Stage1 :
                                 entry_price - sl_distance_price * InpTakeProfitRatio_Stage1;

         if ((pos_type == POSITION_TYPE_BUY && current_price >= target_price) ||
             (pos_type == POSITION_TYPE_SELL && current_price <= target_price))
         {
            double lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
            double min_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
            double volume_to_close_raw = volume * (InpPartialClosePercentage / 100.0);
            double close_volume = MathRound(volume_to_close_raw / lot_step) * lot_step;
            
            if(close_volume < min_lot) close_volume = min_lot;
            if(volume - close_volume < min_lot) close_volume = volume;

            if (trade.PositionClose(ticket, close_volume))
            {
               if (InpEnableLogging) Print("خروج پله‌ای موفق: تیکت=" + IntegerToString(ticket) + ", حجم بسته‌شده=" + DoubleToString(close_volume, 2) + ".");
               
               // Move SL to breakeven after partial close
               if (PositionSelectByTicket(ticket))
               {
                  trade.PositionModify(ticket, entry_price, 0.0);
                  if(InpEnableLogging) Print("استاپ به breakeven منتقل شد: تیکت=" + IntegerToString(ticket) + ".");
                  trade.PositionSetString(ticket, "Stage2"); // Update comment to mark as Stage 2
               }
               return true;
            }
         }
      }

      // Stage 2: Trailing Stop
      if (StringFind(comment, "Stage2") != -1 || (MathAbs(current_sl - entry_price) < _Point * 10))
      {
         double atr_buffer[1];
         if (CopyBuffer(m_trail_atr_handle, 0, 1, 1, atr_buffer) != 1) return false;
         double trail_offset = atr_buffer[0] * InpTrailingStopATRMultiplier;

         if (pos_type == POSITION_TYPE_BUY)
         {
            double new_sl = current_price - trail_offset;
            if (new_sl > current_sl)
            {
               if (trade.PositionModify(ticket, new_sl, 0.0))
               {
                  if(InpEnableLogging) Print("ترلینگ استاپ بروزرسانی شد (خرید): SL جدید=" + DoubleToString(new_sl, _Digits) + ", تیکت=" + IntegerToString(ticket) + ".");
                  return true;
               }
            }
         }
         else // SELL
         {
            double new_sl = current_price + trail_offset;
            if (new_sl < current_sl)
            {
               if (trade.PositionModify(ticket, new_sl, 0.0))
               {
                  if(InpEnableLogging) Print("ترلینگ استاپ بروزرسانی شد (فروش): SL جدید=" + DoubleToString(new_sl, _Digits) + ", تیکت=" + IntegerToString(ticket) + ".");
                  return true;
               }
            }
         }
      }

      return false;
     }

private:
   bool              IdentifyValidRange(RangeData &rd)
     {
      rd.isValid = false;

      datetime now = TimeCurrent();
      MqlDateTime now_struct;
      TimeToStruct(now,now_struct);

      MqlDateTime end_dt_struct = now_struct;
      end_dt_struct.hour = m_end_hour;
      end_dt_struct.min = m_end_min;
      end_dt_struct.sec = 0;
      datetime end_time = StructToTime(end_dt_struct);

      MqlDateTime start_dt_struct = now_struct;
      start_dt_struct.hour = m_start_hour;
      start_dt_struct.min = m_start_min;
      start_dt_struct.sec = 0;
      datetime start_time = StructToTime(start_dt_struct);

      if(m_start_hour > m_end_hour)
        {
         if(now_struct.hour < m_end_hour) start_time -= 86400;
         else end_time += 86400;
        }
      
      rd.startTime = start_time;
      rd.endTime = end_time;

      int start_bar_idx = iBarShift(_Symbol,m_timeframe,start_time,true);
      int end_bar_idx = iBarShift(_Symbol,m_timeframe,end_time,true);

      if(start_bar_idx < 0 || end_bar_idx < 0) return false;

      int bars_to_check = start_bar_idx - end_bar_idx + 1;
      if(bars_to_check <= 0) return false;

      if(InpUseIchimokuFilter)
        {
         int max_sequence = 0;
         int current_sequence = 0;
         int sequence_start_idx = -1;
         int best_start_idx = -1;

         for(int i = start_bar_idx; i >= end_bar_idx; i--)
           {
            if(IsCandleInKumo(m_ichimoku_handle, i, m_timeframe) && IsKijunFlat(m_ichimoku_handle, i, m_timeframe))
              {
               if(current_sequence == 0) sequence_start_idx = i;
               current_sequence++;
              }
            else
              {
               if(current_sequence > max_sequence)
                 {
                  max_sequence = current_sequence;
                  best_start_idx = sequence_start_idx;
                 }
               current_sequence = 0;
              }
           }
           
           if(current_sequence > max_sequence)
             {
              max_sequence = current_sequence;
              best_start_idx = sequence_start_idx;
             }

           if(max_sequence >= InpMinConsecutiveCandles)
             {
              int high_bar_idx = iHighest(_Symbol,m_timeframe,MODE_HIGH,max_sequence,best_start_idx);
              int low_bar_idx = iLowest(_Symbol,m_timeframe,MODE_LOW,max_sequence,best_start_idx);
              
              if(high_bar_idx != -1 && low_bar_idx != -1)
                {
                 rd.rangeHigh = iHigh(_Symbol,m_timeframe,high_bar_idx);
                 rd.rangeLow = iLow(_Symbol,m_timeframe,low_bar_idx);
                 rd.rangeSizePips = (rd.rangeHigh - rd.rangeLow) / _Point;
                 rd.isValid = true;
                }
             }
        }
      else
        {
         int high_bar_idx = iHighest(_Symbol,m_timeframe,MODE_HIGH,bars_to_check,end_bar_idx);
         int low_bar_idx = iLowest(_Symbol,m_timeframe,MODE_LOW,bars_to_check,end_bar_idx);
         
         if(high_bar_idx != -1 && low_bar_idx != -1)
           {
            rd.rangeHigh = iHigh(_Symbol,m_timeframe,high_bar_idx);
            rd.rangeLow = iLow(_Symbol,m_timeframe,low_bar_idx);
            rd.rangeSizePips = (rd.rangeHigh - rd.rangeLow) / _Point;

            if(InpRangeFilterMode == MODE_POINTS)
              {
               if(rd.rangeSizePips >= InpMinRangePoints && rd.rangeSizePips <= InpMaxRangePoints) rd.isValid = true;
              }
            else
              {
               double atr_buffer[1];
               if(CopyBuffer(m_range_atr_handle,0,1,1,atr_buffer) == 1)
                 {
                  double atr_value = atr_buffer[0];
                  if(atr_value > 0)
                    {
                     double min_allowed = (atr_value * InRangeATR_MinMultiplier) / _Point;
                     double max_allowed = (atr_value * InRangeATR_MaxMultiplier) / _Point;
                     if(rd.rangeSizePips >= min_allowed && rd.rangeSizePips <= max_allowed) rd.isValid = true;
                    }
                 }
              }
           }
        }
      return rd.isValid;
     }

   void              AnalyzeAndPlaceOrders(void)
     {
      RangeData rd;
      if(!IdentifyValidRange(rd)) return;

      DrawRangeOnChart(rd,m_magic_number);

      bool is_trend_on = InpTrendFilterIsOn;
      bool is_uptrend = false;

      if(is_trend_on)
        {
         double ema_buffer[1];
         if(CopyBuffer(m_ema_handle,0,1,1,ema_buffer) == 1)
           {
            double current_price = SymbolInfoDouble(_Symbol,SYMBOL_BID);
            is_uptrend = current_price > ema_buffer[0];
           }
        }

      double atr_buffer[1];
      if(CopyBuffer(m_placement_atr_handle,0,1,1,atr_buffer) != 1) return;
      double atr_value = atr_buffer[0];
      double buffer = atr_value * InpAtrMultiplier_Placement;

      double buy_stop_price = rd.rangeHigh + buffer;
      double sell_stop_price = rd.rangeLow - buffer;

      double current_bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
      double current_ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
      if((is_trend_on && is_uptrend && current_ask >= buy_stop_price) ||
         (is_trend_on && !is_uptrend && current_bid <= sell_stop_price) ||
         (!is_trend_on && (current_ask >= buy_stop_price || current_bid <= sell_stop_price)))
         {
          if(InpEnableLogging) Print("Safety check: قیمت قبلاً از محدوده عبور کرده - سفارش قرار نمی‌گیرد (جلسه " + IntegerToString(m_magic_number) + ").");
          return;
         }

      PlacePendingOrders(m_magic_number,is_trend_on,is_uptrend,rd,buy_stop_price,sell_stop_price);
     }

   bool              IsSameDay(datetime d1,datetime d2)
     {
      MqlDateTime s1,s2;
      TimeToStruct(d1,s1);
      TimeToStruct(d2,s2);
      return (s1.year == s2.year && s1.mon == s2.mon && s1.day == s2.day);
     }
  };

#endif //SESSIONTRADER_MQH
