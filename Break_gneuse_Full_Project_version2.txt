2025.08.27 20:06:35.207	EURUSD,M15: history cache allocated for 116322 bars and contains 24914 bars from 2021.01.04 00:00 to 2021.12.31 23:00
2025.08.27 20:06:35.207	EURUSD,M15: history begins from 2021.01.04 00:00
2025.08.27 20:06:35.285	EURUSD,Daily: history cache allocated for 1212 bars and contains 260 bars from 2021.01.04 00:00 to 2021.12.31 00:00
2025.08.27 20:06:35.285	EURUSD,Daily: history begins from 2021.01.04 00:00
2025.08.27 20:06:35.355	EURUSD,H4: history cache allocated for 7273 bars and contains 1560 bars from 2021.01.04 00:00 to 2021.12.31 20:00
2025.08.27 20:06:35.355	EURUSD,H4: history begins from 2021.01.04 00:00
2025.08.27 20:06:51.927	2022.01.10 06:00:00   buy stop 0.05 EURUSD at 1.13486 sl: 1.13366 (1.13377 / 1.13378 / 1.13377)
2025.08.27 20:06:51.930	2022.01.10 06:00:00   CTrade::OrderSend: buy stop 0.05 EURUSD at 1.13486 sl: 1.13366 [done]
2025.08.27 20:06:51.930	2022.01.10 06:00:00   sell stop 0.05 EURUSD at 1.13363 sl: 1.13483 (1.13377 / 1.13378 / 1.13377)
2025.08.27 20:06:51.932	2022.01.10 06:00:00   CTrade::OrderSend: sell stop 0.05 EURUSD at 1.13363 sl: 1.13483 [done]
2025.08.27 20:06:51.934	2022.01.10 06:18:39   order [#3 sell stop 0.05 EURUSD at 1.13363] triggered
2025.08.27 20:06:51.934	2022.01.10 06:18:39   deal #2 sell 0.05 EURUSD at 1.13362 done (based on order #3)
2025.08.27 20:06:51.934	2022.01.10 06:18:39   deal performed [#2 sell 0.05 EURUSD at 1.13362]
2025.08.27 20:06:51.934	2022.01.10 06:18:39   order performed sell 0.05 at 1.13362 [#3 sell stop 0.05 EURUSD at 1.13363]
2025.08.27 20:06:51.938	2022.01.10 06:18:39   order canceled [#2 buy stop 0.05 EURUSD at 1.13486]
2025.08.27 20:06:51.940	2022.01.10 06:18:39   CTrade::OrderSend: cancel #2 [done]
2025.08.27 20:06:51.967	2022.01.10 10:00:00   buy stop 0.05 EURUSD at 1.13370 sl: 1.13257 (1.13292 / 1.13293 / 1.13292)
2025.08.27 20:06:51.969	2022.01.10 10:00:00   CTrade::OrderSend: buy stop 0.05 EURUSD at 1.13370 sl: 1.13257 [done]
2025.08.27 20:06:51.969	2022.01.10 10:00:00   sell stop 0.05 EURUSD at 1.13250 sl: 1.13363 (1.13292 / 1.13293 / 1.13292)
2025.08.27 20:06:51.971	2022.01.10 10:00:00   CTrade::OrderSend: sell stop 0.05 EURUSD at 1.13250 sl: 1.13363 [done]
2025.08.27 20:06:51.972	2022.01.10 10:06:27   order [#5 sell stop 0.05 EURUSD at 1.13250] triggered
2025.08.27 20:06:51.972	2022.01.10 10:06:27   deal #3 sell 0.05 EURUSD at 1.13248 done (based on order #5)
2025.08.27 20:06:51.972	2022.01.10 10:06:27   deal performed [#3 sell 0.05 EURUSD at 1.13248]
2025.08.27 20:06:51.972	2022.01.10 10:06:27   order performed sell 0.05 at 1.13248 [#5 sell stop 0.05 EURUSD at 1.13250]
2025.08.27 20:06:51.972	2022.01.10 10:06:28   order canceled [#4 buy stop 0.05 EURUSD at 1.13370]
2025.08.27 20:06:51.974	2022.01.10 10:06:28   CTrade::OrderSend: cancel #4 [done]
2025.08.27 20:06:51.986	2022.01.10 10:58:16   stop loss triggered #5 sell 0.05 EURUSD 1.13248 sl: 1.13363 [#6 buy 0.05 EURUSD at 1.13363]
2025.08.27 20:06:51.986	2022.01.10 10:58:16   deal #4 buy 0.05 EURUSD at 1.13364 done (based on order #6)
2025.08.27 20:06:51.986	2022.01.10 10:58:16   deal performed [#4 buy 0.05 EURUSD at 1.13364]
2025.08.27 20:06:51.986	2022.01.10 10:58:16   order performed buy 0.05 at 1.13364 [#6 buy 0.05 EURUSD at 1.13363]
2025.08.27 20:06:52.133	2022.01.11 10:05:39   stop loss triggered #3 sell 0.05 EURUSD 1.13362 sl: 1.13483 [#7 buy 0.05 EURUSD at 1.13483]
2025.08.27 20:06:52.133	2022.01.11 10:05:39   deal #5 buy 0.05 EURUSD at 1.13483 done (based on order #7)
2025.08.27 20:06:52.133	2022.01.11 10:05:39   deal performed [#5 buy 0.05 EURUSD at 1.13483]
2025.08.27 20:06:52.133	2022.01.11 10:05:39   order performed buy 0.05 at 1.13483 [#7 buy 0.05 EURUSD at 1.13483]
2025.08.27 20:07:12.607	2022.01.19 10:00:00   buy stop 0.07 EURUSD at 1.13354 sl: 1.13263 (1.13308 / 1.13315 / 1.13308)
2025.08.27 20:07:12.609	2022.01.19 10:00:00   CTrade::OrderSend: buy stop 0.07 EURUSD at 1.13354 sl: 1.13263 [done]
2025.08.27 20:07:12.609	2022.01.19 10:00:00   sell stop 0.07 EURUSD at 1.13252 sl: 1.13343 (1.13308 / 1.13315 / 1.13308)
2025.08.27 20:07:12.611	2022.01.19 10:00:00   CTrade::OrderSend: sell stop 0.07 EURUSD at 1.13252 sl: 1.13343 [done]
2025.08.27 20:07:12.615	2022.01.19 10:10:36   order [#8 buy stop 0.07 EURUSD at 1.13354] triggered
2025.08.27 20:07:12.615	2022.01.19 10:10:36   deal #6 buy 0.07 EURUSD at 1.13355 done (based on order #8)
2025.08.27 20:07:12.615	2022.01.19 10:10:36   deal performed [#6 buy 0.07 EURUSD at 1.13355]
2025.08.27 20:07:12.615	2022.01.19 10:10:36   order performed buy 0.07 at 1.13355 [#8 buy stop 0.07 EURUSD at 1.13354]
2025.08.27 20:07:12.615	2022.01.19 10:10:36   order canceled [#9 sell stop 0.07 EURUSD at 1.13252]
2025.08.27 20:07:12.617	2022.01.19 10:10:36   CTrade::OrderSend: cancel #9 [done]
2025.08.27 20:07:12.919	2022.01.20 20:05:04   stop loss triggered #8 buy 0.07 EURUSD 1.13355 sl: 1.13263 [#10 sell 0.07 EURUSD at 1.13263]
2025.08.27 20:07:12.919	2022.01.20 20:05:04   deal #7 sell 0.07 EURUSD at 1.13263 done (based on order #10)
2025.08.27 20:07:12.919	2022.01.20 20:05:04   deal performed [#7 sell 0.07 EURUSD at 1.13263]
2025.08.27 20:07:12.919	2022.01.20 20:05:04   order performed sell 0.07 at 1.13263 [#10 sell 0.07 EURUSD at 1.13263]
2025.08.27 20:07:12.960	2022.01.21 06:00:00   buy stop 0.03 EURUSD at 1.13369 sl: 1.13165 (1.13258 / 1.13265 / 1.13258)
2025.08.27 20:07:12.962	2022.01.21 06:00:00   CTrade::OrderSend: buy stop 0.03 EURUSD at 1.13369 sl: 1.13165 [done]
2025.08.27 20:07:12.962	2022.01.21 06:00:00   sell stop 0.03 EURUSD at 1.13161 sl: 1.13365 (1.13258 / 1.13265 / 1.13258)
2025.08.27 20:07:12.964	2022.01.21 06:00:00   CTrade::OrderSend: sell stop 0.03 EURUSD at 1.13161 sl: 1.13365 [done]
2025.08.27 20:07:12.975	2022.01.21 09:29:05   order [#11 buy stop 0.03 EURUSD at 1.13369] triggered
2025.08.27 20:07:12.975	2022.01.21 09:29:05   deal #8 buy 0.03 EURUSD at 1.13369 done (based on order #11)
2025.08.27 20:07:12.975	2022.01.21 09:29:05   deal performed [#8 buy 0.03 EURUSD at 1.13369]
2025.08.27 20:07:12.975	2022.01.21 09:29:05   order performed buy 0.03 at 1.13369 [#11 buy stop 0.03 EURUSD at 1.13369]
2025.08.27 20:07:12.975	2022.01.21 09:29:05   order canceled [#12 sell stop 0.03 EURUSD at 1.13161]
2025.08.27 20:07:12.977	2022.01.21 09:29:05   CTrade::OrderSend: cancel #12 [done]
2025.08.27 20:07:12.980	2022.01.21 10:00:00   buy stop 0.08 EURUSD at 1.13299 sl: 1.13220 (1.13286 / 1.13293 / 1.13286)
2025.08.27 20:07:12.982	2022.01.21 10:00:00   CTrade::OrderSend: buy stop 0.08 EURUSD at 1.13299 sl: 1.13220 [done]
2025.08.27 20:07:12.982	2022.01.21 10:00:00   sell stop 0.08 EURUSD at 1.13210 sl: 1.13289 (1.13286 / 1.13293 / 1.13286)
2025.08.27 20:07:12.984	2022.01.21 10:00:00   CTrade::OrderSend: sell stop 0.08 EURUSD at 1.13210 sl: 1.13289 [done]
2025.08.27 20:07:12.984	2022.01.21 10:00:18   order [#13 buy stop 0.08 EURUSD at 1.13299] triggered
2025.08.27 20:07:12.984	2022.01.21 10:00:18   deal #9 buy 0.08 EURUSD at 1.13299 done (based on order #13)
2025.08.27 20:07:12.984	2022.01.21 10:00:18   deal performed [#9 buy 0.08 EURUSD at 1.13299]
2025.08.27 20:07:12.984	2022.01.21 10:00:18   order performed buy 0.08 at 1.13299 [#13 buy stop 0.08 EURUSD at 1.13299]
2025.08.27 20:07:12.984	2022.01.21 10:00:18   order canceled [#14 sell stop 0.08 EURUSD at 1.13210]
2025.08.27 20:07:12.986	2022.01.21 10:00:18   CTrade::OrderSend: cancel #14 [done]
2025.08.27 20:07:13.176	2022.01.24 07:59:18   stop loss triggered #13 buy 0.08 EURUSD 1.13299 sl: 1.13220 [#15 sell 0.08 EURUSD at 1.13220]
2025.08.27 20:07:13.176	2022.01.24 07:59:18   deal #10 sell 0.08 EURUSD at 1.13219 done (based on order #15)
2025.08.27 20:07:13.176	2022.01.24 07:59:18   deal performed [#10 sell 0.08 EURUSD at 1.13219]
2025.08.27 20:07:13.176	2022.01.24 07:59:18   order performed sell 0.08 at 1.13219 [#15 sell 0.08 EURUSD at 1.13220]
2025.08.27 20:07:13.176	2022.01.24 07:59:40   stop loss triggered #11 buy 0.03 EURUSD 1.13369 sl: 1.13165 [#16 sell 0.03 EURUSD at 1.13165]
2025.08.27 20:07:13.176	2022.01.24 07:59:40   deal #11 sell 0.03 EURUSD at 1.13163 done (based on order #16)
2025.08.27 20:07:13.176	2022.01.24 07:59:40   deal performed [#11 sell 0.03 EURUSD at 1.13163]
2025.08.27 20:07:13.177	2022.01.24 07:59:40   order performed sell 0.03 at 1.13163 [#16 sell 0.03 EURUSD at 1.13165]
2025.08.27 20:07:13.856	2022.01.28 06:00:00   buy stop 0.07 EURUSD at 1.11536 sl: 1.11458 (1.11532 / 1.11535 / 1.11532)
2025.08.27 20:07:13.858	2022.01.28 06:00:00   CTrade::OrderSend: buy stop 0.07 EURUSD at 1.11536 sl: 1.11458 [done]
2025.08.27 20:07:13.858	2022.01.28 06:00:00   sell stop 0.07 EURUSD at 1.11451 sl: 1.11529 (1.11532 / 1.11535 / 1.11532)
2025.08.27 20:07:13.860	2022.01.28 06:00:00   CTrade::OrderSend: sell stop 0.07 EURUSD at 1.11451 sl: 1.11529 [done]
2025.08.27 20:07:13.860	2022.01.28 06:00:01   order [#17 buy stop 0.07 EURUSD at 1.11536] triggered
2025.08.27 20:07:13.860	2022.01.28 06:00:01   deal #12 buy 0.07 EURUSD at 1.11536 done (based on order #17)
2025.08.27 20:07:13.860	2022.01.28 06:00:01   deal performed [#12 buy 0.07 EURUSD at 1.11536]
2025.08.27 20:07:13.860	2022.01.28 06:00:01   order performed buy 0.07 at 1.11536 [#17 buy stop 0.07 EURUSD at 1.11536]
2025.08.27 20:07:13.862	2022.01.28 06:00:01   order canceled [#18 sell stop 0.07 EURUSD at 1.11451]
2025.08.27 20:07:13.864	2022.01.28 06:00:01   CTrade::OrderSend: cancel #18 [done]
2025.08.27 20:07:13.880	2022.01.28 09:00:28   stop loss triggered #17 buy 0.07 EURUSD 1.11536 sl: 1.11458 [#19 sell 0.07 EURUSD at 1.11458]
2025.08.27 20:07:13.880	2022.01.28 09:00:28   deal #13 sell 0.07 EURUSD at 1.11458 done (based on order #19)
2025.08.27 20:07:13.880	2022.01.28 09:00:28   deal performed [#13 sell 0.07 EURUSD at 1.11458]
2025.08.27 20:07:13.880	2022.01.28 09:00:28   order performed sell 0.07 at 1.11458 [#19 sell 0.07 EURUSD at 1.11458]
2025.08.27 20:07:14.544	2022.02.03 06:00:00   buy stop 0.05 EURUSD at 1.13095 sl: 1.12984 (1.13048 / 1.13055 / 1.13048)
2025.08.27 20:07:14.546	2022.02.03 06:00:00   CTrade::OrderSend: buy stop 0.05 EURUSD at 1.13095 sl: 1.12984 [done]
2025.08.27 20:07:14.546	2022.02.03 06:00:00   sell stop 0.05 EURUSD at 1.12978 sl: 1.13089 (1.13048 / 1.13055 / 1.13048)
2025.08.27 20:07:14.548	2022.02.03 06:00:00   CTrade::OrderSend: sell stop 0.05 EURUSD at 1.12978 sl: 1.13089 [done]
2025.08.27 20:07:14.551	2022.02.03 06:24:25   order [#21 sell stop 0.05 EURUSD at 1.12978] triggered
2025.08.27 20:07:14.551	2022.02.03 06:24:25   deal #14 sell 0.05 EURUSD at 1.12977 done (based on order #21)
2025.08.27 20:07:14.551	2022.02.03 06:24:25   deal performed [#14 sell 0.05 EURUSD at 1.12977]
2025.08.27 20:07:14.551	2022.02.03 06:24:25   order performed sell 0.05 at 1.12977 [#21 sell stop 0.05 EURUSD at 1.12978]
2025.08.27 20:07:14.551	2022.02.03 06:24:25   order canceled [#20 buy stop 0.05 EURUSD at 1.13095]
2025.08.27 20:07:14.553	2022.02.03 06:24:25   CTrade::OrderSend: cancel #20 [done]
2025.08.27 20:07:14.663	2022.02.03 15:38:41   stop loss triggered #21 sell 0.05 EURUSD 1.12977 sl: 1.13089 [#22 buy 0.05 EURUSD at 1.13089]
2025.08.27 20:07:14.663	2022.02.03 15:38:41   deal #15 buy 0.05 EURUSD at 1.13096 done (based on order #22)
2025.08.27 20:07:14.663	2022.02.03 15:38:41   deal performed [#15 buy 0.05 EURUSD at 1.13096]
2025.08.27 20:07:14.663	2022.02.03 15:38:41   order performed buy 0.05 at 1.13096 [#22 buy 0.05 EURUSD at 1.13089]
2025.08.27 20:08:07.103	2022.02.16 06:00:00   buy stop 0.05 EURUSD at 1.13548 sl: 1.13439 (1.13457 / 1.13458 / 1.13457)
2025.08.27 20:08:07.105	2022.02.16 06:00:00   CTrade::OrderSend: buy stop 0.05 EURUSD at 1.13548 sl: 1.13439 [done]
2025.08.27 20:08:07.105	2022.02.16 06:00:00   sell stop 0.05 EURUSD at 1.13435 sl: 1.13544 (1.13457 / 1.13458 / 1.13457)
2025.08.27 20:08:07.107	2022.02.16 06:00:00   CTrade::OrderSend: sell stop 0.05 EURUSD at 1.13435 sl: 1.13544 [done]
2025.08.27 20:08:07.112	2022.02.16 07:43:35   order [#23 buy stop 0.05 EURUSD at 1.13548] triggered
2025.08.27 20:08:07.112	2022.02.16 07:43:35   deal #16 buy 0.05 EURUSD at 1.13548 done (based on order #23)
2025.08.27 20:08:07.112	2022.02.16 07:43:35   deal performed [#16 buy 0.05 EURUSD at 1.13548]
2025.08.27 20:08:07.112	2022.02.16 07:43:35   order performed buy 0.05 at 1.13548 [#23 buy stop 0.05 EURUSD at 1.13548]
2025.08.27 20:08:07.112	2022.02.16 07:43:35   order canceled [#24 sell stop 0.05 EURUSD at 1.13435]
2025.08.27 20:08:07.114	2022.02.16 07:43:35   CTrade::OrderSend: cancel #24 [done]
2025.08.27 20:08:07.365	2022.02.17 05:56:21   stop loss triggered #23 buy 0.05 EURUSD 1.13548 sl: 1.13439 [#25 sell 0.05 EURUSD at 1.13439]
2025.08.27 20:08:07.365	2022.02.17 05:56:21   deal #17 sell 0.05 EURUSD at 1.13439 done (based on order #25)
2025.08.27 20:08:07.365	2022.02.17 05:56:21   deal performed [#17 sell 0.05 EURUSD at 1.13439]
2025.08.27 20:08:07.365	2022.02.17 05:56:21   order performed sell 0.05 at 1.13439 [#25 sell 0.05 EURUSD at 1.13439]
2025.08.27 20:08:13.328	2022.02.23 06:00:00   buy stop 0.04 EURUSD at 1.13372 sl: 1.13236 (1.13257 / 1.13260 / 1.13257)
2025.08.27 20:08:13.330	2022.02.23 06:00:00   CTrade::OrderSend: buy stop 0.04 EURUSD at 1.13372 sl: 1.13236 [done]
2025.08.27 20:08:13.330	2022.02.23 06:00:00   sell stop 0.04 EURUSD at 1.13232 sl: 1.13368 (1.13257 / 1.13260 / 1.13257)
2025.08.27 20:08:13.332	2022.02.23 06:00:00   CTrade::OrderSend: sell stop 0.04 EURUSD at 1.13232 sl: 1.13368 [done]
2025.08.27 20:08:13.334	2022.02.23 06:44:30   order [#27 sell stop 0.04 EURUSD at 1.13232] triggered
2025.08.27 20:08:13.334	2022.02.23 06:44:30   deal #18 sell 0.04 EURUSD at 1.13231 done (based on order #27)
2025.08.27 20:08:13.334	2022.02.23 06:44:30   deal performed [#18 sell 0.04 EURUSD at 1.13231]
2025.08.27 20:08:13.334	2022.02.23 06:44:30   order performed sell 0.04 at 1.13231 [#27 sell stop 0.04 EURUSD at 1.13232]
2025.08.27 20:08:13.334	2022.02.23 06:44:30   order canceled [#26 buy stop 0.04 EURUSD at 1.13372]
2025.08.27 20:08:13.336	2022.02.23 06:44:30   CTrade::OrderSend: cancel #26 [done]
2025.08.27 20:08:13.354	2022.02.23 09:36:39   stop loss triggered #27 sell 0.04 EURUSD 1.13231 sl: 1.13368 [#28 buy 0.04 EURUSD at 1.13368]
2025.08.27 20:08:13.354	2022.02.23 09:36:39   deal #19 buy 0.04 EURUSD at 1.13368 done (based on order #28)
2025.08.27 20:08:13.354	2022.02.23 09:36:39   deal performed [#19 buy 0.04 EURUSD at 1.13368]
2025.08.27 20:08:13.354	2022.02.23 09:36:39   order performed buy 0.04 at 1.13368 [#28 buy 0.04 EURUSD at 1.13368]
2025.08.27 20:08:32.352	2022.03.08 06:00:00   buy stop 0.03 EURUSD at 1.08875 sl: 1.08691 (1.08675 / 1.08679 / 1.08675)
2025.08.27 20:08:32.354	2022.03.08 06:00:00   CTrade::OrderSend: buy stop 0.03 EURUSD at 1.08875 sl: 1.08691 [done]
2025.08.27 20:08:32.354	2022.03.08 06:00:00   sell stop 0.03 EURUSD at 1.08668 sl: 1.08853 (1.08675 / 1.08679 / 1.08675)
2025.08.27 20:08:32.356	2022.03.08 06:00:00   CTrade::OrderSend: sell stop 0.03 EURUSD at 1.08668 sl: 1.08852 [done]
2025.08.27 20:08:32.360	2022.03.08 06:03:03   order [#30 sell stop 0.03 EURUSD at 1.08668] triggered
2025.08.27 20:08:32.360	2022.03.08 06:03:03   deal #20 sell 0.03 EURUSD at 1.08666 done (based on order #30)
2025.08.27 20:08:32.360	2022.03.08 06:03:03   deal performed [#20 sell 0.03 EURUSD at 1.08666]
2025.08.27 20:08:32.360	2022.03.08 06:03:03   order performed sell 0.03 at 1.08666 [#30 sell stop 0.03 EURUSD at 1.08668]
2025.08.27 20:08:32.360	2022.03.08 06:03:03   order canceled [#29 buy stop 0.03 EURUSD at 1.08875]
2025.08.27 20:08:32.362	2022.03.08 06:03:03   CTrade::OrderSend: cancel #29 [done]
2025.08.27 20:08:32.428	2022.03.08 10:10:31   stop loss triggered #30 sell 0.03 EURUSD 1.08666 sl: 1.08853 [#31 buy 0.03 EURUSD at 1.08853]
2025.08.27 20:08:32.428	2022.03.08 10:10:31   deal #21 buy 0.03 EURUSD at 1.08854 done (based on order #31)
2025.08.27 20:08:32.428	2022.03.08 10:10:31   deal performed [#21 buy 0.03 EURUSD at 1.08854]
2025.08.27 20:08:32.428	2022.03.08 10:10:31   order performed buy 0.03 at 1.08854 [#31 buy 0.03 EURUSD at 1.08853]
2025.08.27 20:08:32.754	2022.03.09 06:00:00   buy stop 0.02 EURUSD at 1.09224 sl: 1.08999 (1.09071 / 1.09074 / 1.09071)
2025.08.27 20:08:32.757	2022.03.09 06:00:00   CTrade::OrderSend: buy stop 0.02 EURUSD at 1.09224 sl: 1.08999 [done]
2025.08.27 20:08:32.757	2022.03.09 06:00:00   sell stop 0.02 EURUSD at 1.08990 sl: 1.09215 (1.09071 / 1.09074 / 1.09071)
2025.08.27 20:08:32.759	2022.03.09 06:00:00   CTrade::OrderSend: sell stop 0.02 EURUSD at 1.08990 sl: 1.09215 [done]
2025.08.27 20:08:32.768	2022.03.09 07:14:26   order [#32 buy stop 0.02 EURUSD at 1.09224] triggered
2025.08.27 20:08:32.768	2022.03.09 07:14:26   deal #22 buy 0.02 EURUSD at 1.09224 done (based on order #32)
2025.08.27 20:08:32.768	2022.03.09 07:14:26   deal performed [#22 buy 0.02 EURUSD at 1.09224]
2025.08.27 20:08:32.768	2022.03.09 07:14:26   order performed buy 0.02 at 1.09224 [#32 buy stop 0.02 EURUSD at 1.09224]
2025.08.27 20:08:32.768	2022.03.09 07:14:26   order canceled [#33 sell stop 0.02 EURUSD at 1.08990]
2025.08.27 20:08:32.770	2022.03.09 07:14:26   CTrade::OrderSend: cancel #33 [done]
2025.08.27 20:08:35.792	2022.03.10 06:00:00   buy stop 0.01 EURUSD at 1.10806 sl: 1.10417 (1.10585 / 1.10588 / 1.10585)
2025.08.27 20:08:35.795	2022.03.10 06:00:00   CTrade::OrderSend: buy stop 0.01 EURUSD at 1.10806 sl: 1.10417 [done]
2025.08.27 20:08:35.795	2022.03.10 06:00:00   sell stop 0.01 EURUSD at 1.10421 sl: 1.10810 (1.10585 / 1.10588 / 1.10585)
2025.08.27 20:08:35.797	2022.03.10 06:00:00   CTrade::OrderSend: sell stop 0.01 EURUSD at 1.10421 sl: 1.10810 [done]
2025.08.27 20:08:35.833	2022.03.10 10:11:39   order [#35 sell stop 0.01 EURUSD at 1.10421] triggered
2025.08.27 20:08:35.833	2022.03.10 10:11:39   deal #23 sell 0.01 EURUSD at 1.10421 done (based on order #35)
2025.08.27 20:08:35.833	2022.03.10 10:11:39   deal performed [#23 sell 0.01 EURUSD at 1.10421]
2025.08.27 20:08:35.833	2022.03.10 10:11:39   order performed sell 0.01 at 1.10421 [#35 sell stop 0.01 EURUSD at 1.10421]
2025.08.27 20:08:35.834	2022.03.10 10:11:39   order canceled [#34 buy stop 0.01 EURUSD at 1.10806]
2025.08.27 20:08:35.836	2022.03.10 10:11:39   CTrade::OrderSend: cancel #34 [done]
2025.08.27 20:08:35.971	2022.03.10 14:45:39   stop loss triggered #35 sell 0.01 EURUSD 1.10421 sl: 1.10810 [#36 buy 0.01 EURUSD at 1.10810]
2025.08.27 20:08:35.971	2022.03.10 14:45:39   deal #24 buy 0.01 EURUSD at 1.10815 done (based on order #36)
2025.08.27 20:08:35.971	2022.03.10 14:45:39   deal performed [#24 buy 0.01 EURUSD at 1.10815]
2025.08.27 20:08:35.971	2022.03.10 14:45:39   order performed buy 0.01 at 1.10815 [#36 buy 0.01 EURUSD at 1.10810]
2025.08.27 20:08:37.212	2022.03.16 06:00:00   buy stop 0.03 EURUSD at 1.09725 sl: 1.09536 (1.09672 / 1.09677 / 1.09672)
2025.08.27 20:08:37.214	2022.03.16 06:00:00   CTrade::OrderSend: buy stop 0.03 EURUSD at 1.09725 sl: 1.09536 [done]
2025.08.27 20:08:37.214	2022.03.16 06:00:00   sell stop 0.03 EURUSD at 1.09528 sl: 1.09717 (1.09672 / 1.09677 / 1.09672)
2025.08.27 20:08:37.216	2022.03.16 06:00:00   CTrade::OrderSend: sell stop 0.03 EURUSD at 1.09528 sl: 1.09717 [done]
2025.08.27 20:08:37.222	2022.03.16 07:27:14   order [#37 buy stop 0.03 EURUSD at 1.09725] triggered
2025.08.27 20:08:37.222	2022.03.16 07:27:14   deal #25 buy 0.03 EURUSD at 1.09725 done (based on order #37)
2025.08.27 20:08:37.222	2022.03.16 07:27:14   deal performed [#25 buy 0.03 EURUSD at 1.09725]
2025.08.27 20:08:37.222	2022.03.16 07:27:14   order performed buy 0.03 at 1.09725 [#37 buy stop 0.03 EURUSD at 1.09725]
2025.08.27 20:08:37.222	2022.03.16 07:27:14   order canceled [#38 sell stop 0.03 EURUSD at 1.09528]
2025.08.27 20:08:37.224	2022.03.16 07:27:14   CTrade::OrderSend: cancel #38 [done]
2025.08.27 20:08:37.538	2022.03.16 20:10:39   stop loss triggered #37 buy 0.03 EURUSD 1.09725 sl: 1.09536 [#39 sell 0.03 EURUSD at 1.09536]
2025.08.27 20:08:37.538	2022.03.16 20:10:39   deal #26 sell 0.03 EURUSD at 1.09536 done (based on order #39)
2025.08.27 20:08:37.538	2022.03.16 20:10:39   deal performed [#26 sell 0.03 EURUSD at 1.09536]
2025.08.27 20:08:37.538	2022.03.16 20:10:39   order performed sell 0.03 at 1.09536 [#39 sell 0.03 EURUSD at 1.09536]
2025.08.27 20:08:37.949	2022.03.18 06:00:00   buy stop 0.03 EURUSD at 1.10988 sl: 1.10800 (1.10835 / 1.10842 / 1.10835)
2025.08.27 20:08:37.951	2022.03.18 06:00:00   CTrade::OrderSend: buy stop 0.03 EURUSD at 1.10988 sl: 1.10800 [done]
2025.08.27 20:08:37.951	2022.03.18 06:00:00   sell stop 0.03 EURUSD at 1.10788 sl: 1.10976 (1.10835 / 1.10842 / 1.10835)
2025.08.27 20:08:37.953	2022.03.18 06:00:00   CTrade::OrderSend: sell stop 0.03 EURUSD at 1.10788 sl: 1.10976 [done]
2025.08.27 20:08:37.956	2022.03.18 06:53:59   order [#41 sell stop 0.03 EURUSD at 1.10788] triggered
2025.08.27 20:08:37.956	2022.03.18 06:53:59   deal #27 sell 0.03 EURUSD at 1.10787 done (based on order #41)
2025.08.27 20:08:37.956	2022.03.18 06:53:59   deal performed [#27 sell 0.03 EURUSD at 1.10787]
2025.08.27 20:08:37.956	2022.03.18 06:53:59   order performed sell 0.03 at 1.10787 [#41 sell stop 0.03 EURUSD at 1.10788]
2025.08.27 20:08:37.956	2022.03.18 06:53:59   order canceled [#40 buy stop 0.03 EURUSD at 1.10988]
2025.08.27 20:08:37.958	2022.03.18 06:53:59   CTrade::OrderSend: cancel #40 [done]















//+------------------------------------------------------------------+
//|                                                   Settings.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                                             https://...        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل برای حفاظت قانونی.
#property link      "https://..." // لینک مرتبط با پروژه یا وبسایت توسعه‌دهنده.

//--- این گارد برای جلوگیری از include شدن چندباره فایل در پروژه است. این کار کمک می‌کند تا از خطاهای کامپایل مانند redefinition جلوگیری شود و کد تمیز بماند.
#ifndef SETTINGS_MQH // چک وجود تعریف گارد.
#define SETTINGS_MQH // تعریف گارد برای جلوگیری از تکرار.

//+------------------------------------------------------------------+
//| ENUMs for Input Parameters                                       |
//+------------------------------------------------------------------+
//--- enum برای انتخاب حالت فیلتر محدوده. این enum به ما اجازه می‌دهد تا بین دو حالت فیلتر بر اساس پوینت ثابت یا ضریبی از ATR انتخاب کنیم. این یک راه آموزشی برای تعریف گزینه‌های کاربر است و انعطاف‌پذیری سیستم را افزایش می‌دهد.
enum ENUM_RANGE_FILTER_MODE // تعریف انوم برای حالت‌های فیلتر محدوده.
  {
   MODE_POINTS, // فیلتر بر اساس پوینت ثابت - مناسب برای بازارهای با نوسان ثابت، جایی که اندازه محدوده با مقادیر ثابت کنترل می‌شود.
   MODE_ATR     // فیلتر بر اساس ضریبی از ATR - مناسب برای بازارهای پویا، جایی که فیلتر با نوسانات بازار انطباق پیدا می‌کند.
  };

//+------------------------------------------------------------------+
//| INPUT PARAMETERS                                                 |
//+------------------------------------------------------------------+

// --- تنظیمات کلی پورتفولیو ---
// این بخش تنظیمات کلی مربوط به مدیریت ریسک را شامل می‌شود که برای تمام جلسات مشترک است. این پارامترها پایه مدیریت سرمایه را تشکیل می‌دهند و کمک می‌کنند تا ریسک هر معامله کنترل‌شده باشد.
input group "====== Portfolio Global Settings ======"; // گروه ورودی برای تنظیمات کلی پورتفولیو.
input double InpRiskPercentage = 0.5; // درصد ریسک از کل سرمایه در هر معامله - این مقدار تعیین می‌کند که چقدر از سرمایه را در هر معامله ریسک کنیم. مثلاً 0.5% به معنای ریسک نیم درصد است و برای جلوگیری از ضررهای بزرگ مفید است.

// --- تنظیمات کلی فیلترها ---
// این بخش برای فیلترهای جهانی مانند ایچیموکو و ATR برای قرارگیری سفارشات استفاده می‌شود. این تنظیمات به سیستم کمک می‌کنند تا محدوده‌های باکیفیت‌تری شناسایی کند.
input group "====== Global Filter Settings ======"; // گروه ورودی برای فیلترهای جهانی.
input bool InpUseIchimokuFilter = true; // آیا فیلتر ایچیموکو فعال باشد؟ - اگر true، از فیلتر ایچیموکو برای شناسایی محدوده استفاده می‌شود؛ اگر false، از منطق قدیمی (بالاترین/پایین‌ترین قیمت) استفاده می‌شود. این گزینه انعطاف‌پذیری سیستم را افزایش می‌دهد.
input int InpIchimoku_Tenkan = 9; // دوره تنکان‌سن برای ایچیموکو - دوره کوتاه برای محاسبه میانگین بالا/پایین ۹ کندل اخیر، که حساسیت به تغییرات کوتاه‌مدت را نشان می‌دهد.
input int InpIchimoku_Kijun = 26; // دوره کیجون‌سن برای ایچیموکو - دوره متوسط برای محاسبه میانگین بالا/پایین ۲۶ کندل، که روند میان‌مدت را نشان می‌دهد.
input int InpIchimoku_Senkou = 52; // دوره سنکو اسپن B برای ایچیموکو - دوره بلند برای ابر کومو، که میانگین بالا/پایین ۵۲ کندل را محاسبه می‌کند و آینده را پیش‌بینی می‌کند.
input int InpMinConsecutiveCandles = 3; // حداقل تعداد کندل‌های متوالی برای تعادل بازار در ایچیموکو - برای تأیید پایداری تعادل و جلوگیری از سیگنال‌های کاذب.
input double InpAtrMultiplier_Placement = 0.4; // ضریب ATR برای بافر قرارگیری سفارشات - برای تنظیم فاصله دینامیک از لبه‌های محدوده، که بر اساس نوسان بازار تنظیم می‌شود و از فعال شدن زودرس جلوگیری می‌کند.
input int InpKijunFlatPeriod = 3; // دوره چک صاف بودن کیجون‌سن - تعداد کندل‌های اخیر برای محاسبه شیب رگرسیون (مثلاً ۳ برای سیگنال‌های بیشتر، ۲۰ برای سخت‌گیرانه‌تر و سیگنال‌های باکیفیت‌تر). این پارامتر برای بهینه‌سازی در بک‌تست مفید است.

// --- پارامترهای جلسه اول (Session 1) ---
// هر جلسه دارای پارامترهای مستقل برای فعال/غیرفعال کردن، زمان شروع، پایان و انقضا است. مجیک نامبر برای شناسایی معاملات منحصر به فرد است. این ساختار آموزشی برای مدیریت چند جلسه است و اجازه می‌دهد هر جلسه مانند یک استراتژی مستقل عمل کند.
input group"====== Session 1 Settings ======"; // گروه ورودی برای جلسه اول.
input bool   InpS1_IsActive = true;         // آیا جلسه اول فعال باشد؟ - اگر false باشد، این جلسه نادیده گرفته می‌شود و هیچ تحلیلی انجام نمی‌شود.
input ENUM_TIMEFRAMES InpS1_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۱ - مثلاً M15 برای کندل‌های ۱۵ دقیقه‌ای، که دقت و تعداد سیگنال‌ها را تعدیل می‌کند.
input int    InpS1_StartTime_Hour = 0;      // ساعت شروع تحلیل جلسه ۱ - زمان شروع بازه برای شناسایی محدوده (ساعت از 0 تا 23).
input int    InpS1_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۱ (دقیقه از 0 تا 59).
input int    InpS1_EndTime_Hour = 6;        // ساعت پایان تحلیل جلسه ۱ - زمان پایان بازه برای شناسایی High/Low.
input int    InpS1_EndTime_Minute = 0;      // دقیقه پایان تحلیل جلسه ۱.
input int    InpS1_ExpiryTime_Hour = 12;    // ساعت انقضای جلسه ۱ - زمانی که تمام معاملات و سفارشات این جلسه بسته/حذف می‌شوند.
input int    InpS1_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۱.
const int    S1_MagicNumber = 111101;       // مجیک نامبر اختصاصی جلسه ۱ - برای تمایز معاملات این جلسه از دیگران، باید منحصر به فرد باشد و از تداخل جلوگیری کند.

// --- پارامترهای جلسه دوم (Session 2) ---
input group "====== Session 2 Settings ======"; // گروه ورودی برای جلسه دوم.
input bool   InpS2_IsActive = true;         // آیا جلسه دوم فعال باشد؟
input ENUM_TIMEFRAMES InpS2_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۲.
input int    InpS2_StartTime_Hour = 8;      // ساعت شروع تحلیل جلسه ۲.
input int    InpS2_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۲.
input int    InpS2_EndTime_Hour = 10;       // ساعت پایان تحلیل جلسه ۲.
input int    InpS2_EndTime_Minute = 0;      // دقیقه پایان تحلیل جلسه ۲.
input int    InpS2_ExpiryTime_Hour = 20;    // ساعت انقضای جلسه ۲.
input int    InpS2_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۲.
const int    S2_MagicNumber = 222202;       // مجیک نامبر اختصاصی جلسه ۲.

// --- پارامترهای جلسه سوم (Session 3) ---
input group "====== Session 3 Settings ======"; // گروه ورودی برای جلسه سوم.
input bool   InpS3_IsActive = true;         // آیا جلسه سوم فعال باشد؟
input ENUM_TIMEFRAMES InpS3_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۳.
input int    InpS3_StartTime_Hour = 13;     // ساعت شروع تحلیل جلسه ۳.
input int    InpS3_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۳.
input int    InpS3_EndTime_Hour = 14;       // ساعت پایان تحلیل جلسه ۳.
input int    InpS3_EndTime_Minute = 30;     // دقیقه پایان تحلیل جلسه ۳.
input int    InpS3_ExpiryTime_Hour = 21;    // ساعت انقضای جلسه ۳.
input int    InpS3_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۳.
const int    S3_MagicNumber = 333303;       // مجیک نامبر اختصاصی جلسه ۳.

// --- پارامترهای جلسه چهارم (Session 4) ---
input group "====== Session 4 Settings ======"; // گروه ورودی برای جلسه چهارم.
input bool   InpS4_IsActive = false;        // آیا جلسه چهارم فعال باشد؟ - پیش‌فرض false برای غیرفعال بودن.
input ENUM_TIMEFRAMES InpS4_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۴.
input int    InpS4_StartTime_Hour = 0;      // ساعت شروع تحلیل جلسه ۴.
input int    InpS4_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۴.
input int    InpS4_EndTime_Hour = 0;        // ساعت پایان تحلیل جلسه ۴.
input int    InpS4_EndTime_Minute = 0;      // دقیقه پایان تحلیل جلسه ۴.
input int    InpS4_ExpiryTime_Hour = 0;     // ساعت انقضای جلسه ۴.
input int    InpS4_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۴.
const int    S4_MagicNumber = 444404;       // مجیک نامبر اختصاصی جلسه ۴.

// --- پارامترهای تعریف محدوده (مشترک برای همه جلسات) ---
// این بخش برای شناسایی و اعتبارسنجی محدوده استفاده می‌شود و برای تمام جلسات مشترک است. این پارامترها پایه استراتژی شکست را تشکیل می‌دهند.
input group "====== Range Definition ======"; // گروه ورودی برای تعریف محدوده.
input ENUM_RANGE_FILTER_MODE InpRangeFilterMode        = MODE_ATR;     // حالت فیلتر اندازه محدوده - انتخاب بین POINTS یا ATR برای انعطاف‌پذیری.
input int                    InpMinRangePoints         = 50;           // حداقل اندازه رنج به پوینت (در حالت Points) - اگر کمتر باشد، نامعتبر، برای جلوگیری از رنج‌های کوچک و نوسانی.
input int                    InpMaxRangePoints         = 500;          // حداکثر اندازه رنج به پوینت (در حالت Points) - اگر بیشتر باشد، نامعتبر، برای جلوگیری از رنج‌های خیلی بزرگ.
input ENUM_TIMEFRAMES        InRangeATR_TimeFrame      = PERIOD_D1;    // تایم فریم محاسبه ATR برای اعتبارسنجی - مثلاً D1 برای روزانه، برای اندازه‌گیری نوسان کلی.
input int                    InRangeATR_Period         = 14;           // دوره ATR برای اعتبارسنجی - دوره استاندارد ۱۴، برای محاسبه میانگین نوسان.
input double                 InRangeATR_MinMultiplier  = 0.2;          // ضریب حداقل ATR برای اعتبارسنجی - اندازه رنج حداقل این ضریب ATR باشد، برای فیلتر رنج‌های کوچک نسبت به نوسان.
input double                 InRangeATR_MaxMultiplier  = 1.2;          // ضریب حداکثر ATR برای اعتبارسنجی - اندازه رنج حداکثر این ضریب ATR باشد، برای فیلتر رنج‌های بزرگ.

// --- پارامترهای فیلتر روند (مشترک برای همه جلسات) ---
// فیلتر روند برای تعیین جهت معامله بر اساس EMA. این بخش آموزشی برای اضافه کردن فیلتر روند به استراتژی است.
input group "====== Trend Filter ======"; // گروه ورودی برای فیلتر روند.
input bool               InpTrendFilterIsOn    = true;         // آیا فیلتر روند فعال باشد؟ - اگر true، فقط در جهت روند معامله می‌کند، برای کاهش معاملات خلاف روند.
input ENUM_TIMEFRAMES    InpTrendEMATimeFrame  = PERIOD_H4;    // تایم فریم محاسبه EMA - مثلاً H4 برای ۴ ساعته، تایم فریم بالاتر برای روندهای بلندمدت.
input int                InpTrendEMAPeriod     = 150;          // دوره EMA - دوره طولانی برای روندهای بلندمدت، مثلاً ۱۵۰ برای EMA آهسته.
input ENUM_APPLIED_PRICE InpTrendEMAAppliedPrice = PRICE_CLOSE;  // قیمت اعمالی EMA - معمولاً CLOSE برای قیمت بسته شدن کندل.

// --- پارامترهای مدیریت معامله و ریسک (مشترک) ---
// این بخش برای مدیریت سفارشات، استاپ لاس، تیک پروفیت و ترلینگ. این پارامترها پایه مدیریت معامله را تشکیل می‌دهند.
// توجه: InpFixedTakeProfitRatio حذف شده و از InpTakeProfitRatio_Stage1 برای حالت ثابت استفاده می‌شود تا ساده‌سازی شود.
// InpOrderBufferPoints حذف شده و از ATR دینامیک استفاده می‌شود.
input group "====== Trade & Risk Management ======"; // گروه ورودی برای مدیریت معامله و ریسک.
input double InpStopLossAdditionalPercent   = 10.0;         // درصد اضافه به اندازه رنج برای SL اولیه - مثلاً ۱۰% بیشتر از اندازه رنج برای فضای بیشتر.
//--- خروج پله ای
input bool   InpEnablePartialClose          = true;         // آیا خروج پله‌ای فعال باشد؟ - اگر false، از تارگت ثابت استفاده می‌شود، برای استراتژی‌های ساده‌تر.
input double InpTakeProfitRatio_Stage1      = 1.5;          // نسبت سود به ضرر برای بستن بخش اول یا TP ثابت - مثلاً ۱.۵ برابر فاصله SL، برای خروج اولیه یا ثابت.
input double InpPartialClosePercentage      = 50.0;         // درصد حجمی که در مرحله اول بسته می‌شود - مثلاً ۵۰% برای تقسیم معامله.
//--- حد ضرر متحرک
input ENUM_TIMEFRAMES InpTrailingStopATRTimeFrame = PERIOD_D1;    // تایم فریم ATR برای حد ضرر متحرک - مثلاً D1 برای نوسان روزانه.
input int             InpTrailingStopATRPeriod      = 22;           // دوره ATR برای حد ضرر متحرک - دوره متفاوت برای ترلینگ، مثلاً ۲۲ برای حساسیت کمتر.
input double          InpTrailingStopATRMultiplier  = 3.0;          // ضریب ATR برای فاصله حد ضرر متحرک - مثلاً ۳ برابر ATR برای فضای کافی.

//--- گروه: تنظیمات بهینه‌سازی سفارشی ---
input group "  تنظیمات بهینه‌سازی سفارشی"; // گروه بهینه‌سازی
input int InpMinTradesPerYear = 30; // حداقل تعداد معاملات قابل قبول در یک سال
input int InpMaxAcceptableDrawdown = 15; // حداکثر دراوداون قابل قبول

#endif //SETTINGS_MQH








//+------------------------------------------------------------------+
//|                                                   hipobreck.mq5   |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy        |
//|                          >> FINAL REVISED VERSION 3.0 <<          |
//+------------------------------------------------------------------+
// توضیح: فایل اصلی اکسپرت برای سیستم معاملاتی. مدیریت چندین جلسه معاملاتی،
//        رویدادهای تیک، تراکنش‌های معاملاتی و بهینه‌سازی سفارشی را انجام می‌دهد.

#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy"
#property link      "https://..."
#property version   "3.00"
#property strict // فعال‌سازی بررسی سخت‌گیرانه برای جلوگیری از خطاها.

#include "Settings.mqh"
#include "SessionTrader.mqh"
#include <Trade\Trade.mqh> // کتابخانه استاندارد برای عملیات معاملاتی.

//+------------------------------------------------------------------+
//| متغیرهای سراسری                                                |
//+------------------------------------------------------------------+
// توضیح: آرایه‌ای از اشیاء CSessionTrader برای مدیریت چهار جلسه معاملاتی مستقل.
CSessionTrader g_sessions[4];

//+------------------------------------------------------------------+
//| تابع اولیه‌سازی اکسپرت                                          |
//+------------------------------------------------------------------+
// هدف: راه‌اندازی اکسپرت، تنظیم جلسه‌های معاملاتی و تایمر برای به‌روزرسانی‌های دوره‌ای.
int OnInit()
  {
   // مقداردهی اولیه هر جلسه با پارامترهای تعریف‌شده توسط کاربر.
   g_sessions[0].Init(InpS1_IsActive, InpS1_TimeFrame, InpS1_StartTime_Hour, InpS1_StartTime_Minute,
                     InpS1_EndTime_Hour, InpS1_EndTime_Minute, InpS1_ExpiryTime_Hour, InpS1_ExpiryTime_Minute, S1_MagicNumber);
   g_sessions[1].Init(InpS2_IsActive, InpS2_TimeFrame, InpS2_StartTime_Hour, InpS2_StartTime_Minute,
                     InpS2_EndTime_Hour, InpS2_EndTime_Minute, InpS2_ExpiryTime_Hour, InpS2_ExpiryTime_Minute, S2_MagicNumber);
   g_sessions[2].Init(InpS3_IsActive, InpS3_TimeFrame, InpS3_StartTime_Hour, InpS3_StartTime_Minute,
                     InpS3_EndTime_Hour, InpS3_EndTime_Minute, InpS3_ExpiryTime_Hour, InpS3_ExpiryTime_Minute, S3_MagicNumber);
   g_sessions[3].Init(InpS4_IsActive, InpS4_TimeFrame, InpS4_StartTime_Hour, InpS4_StartTime_Minute,
                     InpS4_EndTime_Hour, InpS4_EndTime_Minute, InpS4_ExpiryTime_Hour, InpS4_ExpiryTime_Minute, S4_MagicNumber);

   EventSetTimer(60); // تنظیم تایمر برای به‌روزرسانی هر 60 ثانیه، کاهش بار OnTick.

   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| تابع خاتمه اکسپرت                                              |
//+------------------------------------------------------------------+
// هدف: آزادسازی منابع هنگام حذف اکسپرت.
void OnDeinit(const int reason)
  {
   EventKillTimer(); // متوقف کردن تایمر.

   for(int i = 0; i < 4; i++) g_sessions[i].Deinit(); // خاتمه هر جلسه.
  }

//+------------------------------------------------------------------+
//| تابع تایمر                                                     |
//+------------------------------------------------------------------+
// هدف: هر 60 ثانیه فراخوانی می‌شود برای به‌روزرسانی تحلیل و پاکسازی جلسات.
void OnTimer()
  {
   for(int i = 0; i < 4; i++) g_sessions[i].OnTimerUpdate(); // به‌روزرسانی هر جلسه.
  }

//+------------------------------------------------------------------+
//| تابع تیک                                                       |
//+------------------------------------------------------------------+
// هدف: مدیریت تیک‌های جدید برای به‌روزرسانی پوزیشن‌های فعال (خروج پله‌ای و حد ضرر متحرک).
void OnTick()
  {
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      ulong ticket = PositionGetTicket(i); // دریافت تیکت پوزیشن به‌صورت ulong.
      if(ticket > 0 && PositionSelectByTicket(ticket)) // اطمینان از انتخاب پوزیشن.
        {
         long magic = PositionGetInteger(POSITION_MAGIC); // دریافت مجیک نامبر پوزیشن.
         bool managed = false;

         for(int j = 0; j < 4; j++)
           {
            if(g_sessions[j].GetMagicNumber() == magic)
              {
               managed = g_sessions[j].ManageActiveTrade(ticket); // فراخوانی تابع مدیریت پوزیشن با تیکت ulong.
               break;
              }
           }

         if(managed) break; // اگر پوزیشن مدیریت شد، از حلقه خارج شو.
        }
     }
  }

//+------------------------------------------------------------------+
//| تابع تراکنش معاملاتی                                           |
//+------------------------------------------------------------------+
// هدف: مدیریت منطق OCO (یکی دیگری را لغو می‌کند) با حذف سفارش معکوس هنگام باز شدن معامله.
void OnTradeTransaction(const MqlTradeTransaction &trans, const MqlTradeRequest &request, const MqlTradeResult &result)
  {
   if(trans.type == TRADE_TRANSACTION_DEAL_ADD)
     {
      if(HistoryDealSelect(trans.deal))
        {
         if(HistoryDealGetInteger(trans.deal, DEAL_ENTRY) == DEAL_ENTRY_IN)
           {
            long magic = HistoryDealGetInteger(trans.deal, DEAL_MAGIC);
            for(int i = OrdersTotal() - 1; i >= 0; i--)
              {
               ulong order_ticket = OrderGetTicket(i);
               if(order_ticket > 0 && OrderSelect(order_ticket))
                 {
                  if(OrderGetInteger(ORDER_MAGIC) == magic)
                    {
                     trade.OrderDelete(order_ticket); // حذف سفارش معکوس.
                    }
                 }
              }
           }
        }
     }
  }

//+------------------------------------------------------------------+
//| تابع بهینه‌سازی سفارشی (OnTester)                              |
//+------------------------------------------------------------------+
// هدف: محاسبه امتیاز بهینه‌سازی سفارشی بر اساس آمار معاملات و معیارهای پیشرفته.
double OnTester()
  {
   double total_trades = TesterStatistics(STAT_TRADES); // تعداد کل معاملات.
   double net_profit = TesterStatistics(STAT_PROFIT); // سود خالص.
   double profit_factor = TesterStatistics(STAT_PROFIT_FACTOR); // فاکتور سود.
   double sharpe_ratio = TesterStatistics(STAT_SHARPE_RATIO); // نسبت شارپ.
   double max_balance_drawdown_percent = TesterStatistics(STAT_BALANCE_DDREL_PERCENT); // حداکثر دراوداون درصدی.

   // محاسبه حداقل معاملات موردنیاز بر اساس مدت تست.
   datetime startDate = 0, endDate = 0;
   if(HistoryDealsTotal() > 0)
     {
      startDate = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(0), DEAL_TIME);
      endDate = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(HistoryDealsTotal() - 1), DEAL_TIME);
     }
   double duration_days = (endDate > startDate) ? double(endDate - startDate) / (24.0 * 3600.0) : 1.0;
   double required_min_trades = MathFloor((duration_days / 365.0) * InpMinTradesPerYear);
   if(required_min_trades < 10) required_min_trades = 10;

   // اگر معیارهای اولیه برآورده نشوند، امتیاز صفر.
   if(total_trades < required_min_trades || profit_factor < 1.1 || sharpe_ratio <= 0 || net_profit <= 0) return 0.0;

   // محاسبه معیارهای پیشرفته (R-squared و پایداری نزولی).
   double r_squared = 0, downside_consistency = 0;
   CalculateAdvancedMetrics(r_squared, downside_consistency);

   // محاسبه جریمه دراوداون با استفاده از منحنی کسینوسی.
   double drawdown_penalty_factor = 0.0;
   if(max_balance_drawdown_percent < InpMaxAcceptableDrawdown && InpMaxAcceptableDrawdown > 0)
     {
      double angle = (max_balance_drawdown_percent / InpMaxAcceptableDrawdown) * (M_PI / 2.0);
      drawdown_penalty_factor = MathCos(angle);
     }

   // محاسبه امتیاز نهایی.
   double final_score = 0.0;
   if(drawdown_penalty_factor > 0)
     {
      double trades_factor = MathLog(total_trades + 1);
      double net_profit_factor = MathLog(net_profit + 1);
      final_score = (profit_factor * sharpe_ratio * r_squared * downside_consistency * trades_factor * net_profit_factor) * drawdown_penalty_factor;
     }

   // لاگ نتایج برای دیباگ.
   PrintFormat("نتیجه: معاملات=%d, فاکتور سود=%.2f, شارپ=%.2f, R²=%.3f, دراوداون=%.2f%%, جریمه=%.2f -> امتیاز: %.4f",
               (int)total_trades, profit_factor, sharpe_ratio, r_squared, max_balance_drawdown_percent, drawdown_penalty_factor, final_score);

   return final_score;
  }

//+------------------------------------------------------------------+
//| تابع محاسبه معیارهای پیشرفته                                    |
//+------------------------------------------------------------------+
// هدف: محاسبه R-squared و پایداری نزولی برای امتیازدهی بهینه‌سازی.
void CalculateAdvancedMetrics(double &r_squared, double &downside_consistency)
  {
   r_squared = 0;
   downside_consistency = 1.0;

   if(!HistorySelect(0, TimeCurrent())) return; // انتخاب کل تاریخچه.
   uint total_deals = HistoryDealsTotal();
   if(total_deals < 5) return; // حداقل 5 معامله برای معیارهای معنی‌دار.

   struct EquityPoint { datetime time; double balance; }; // ساختار برای نقاط منحنی بالانس.
   EquityPoint equity_curve[];
   ArrayResize(equity_curve, (int)total_deals + 2);

   double final_balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double net_profit = TesterStatistics(STAT_PROFIT);
   double initial_balance = final_balance - net_profit;

   double current_balance = initial_balance;
   equity_curve[0].time = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(0), DEAL_TIME) - 1;
   equity_curve[0].balance = current_balance;

   int equity_points = 1;
   for(uint i = 0; i < total_deals; i++)
     {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0)
        {
         if(HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
           {
            current_balance += HistoryDealGetDouble(ticket, DEAL_PROFIT) +
                              HistoryDealGetDouble(ticket, DEAL_COMMISSION) +
                              HistoryDealGetDouble(ticket, DEAL_SWAP);
            equity_curve[equity_points].time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
            equity_curve[equity_points].balance = current_balance;
            equity_points++;
           }
        }
     }
   ArrayResize(equity_curve, equity_points);
   if(equity_points < 3) return;

   // محاسبه R-squared.
   double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0, sum_y2 = 0;
   for(int i = 0; i < equity_points; i++)
     {
      double x = i + 1.0;
      double y = equity_curve[i].balance;
      sum_x += x;
      sum_y += y;
      sum_xy += x * y;
      sum_x2 += x * x;
      sum_y2 += y * y;
     }
   double n = equity_points;
   double den_part1 = (n * sum_x2) - (sum_x * sum_x);
   double den_part2 = (n * sum_y2) - (sum_y * sum_y);
   if(den_part1 > 0 && den_part2 > 0)
     {
      double r = ((n * sum_xy) - (sum_x * sum_y)) / MathSqrt(den_part1 * den_part2);
      r_squared = r * r;
     }

   // محاسبه پایداری نزولی.
   struct MonthlyTrades { int year; int month; int count; };
   MonthlyTrades monthly_counts[];
   int total_months = 0;

   for(uint i = 0; i < total_deals; i++)
     {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
        {
         datetime deal_time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
         MqlDateTime dt;
         TimeToStruct(deal_time, dt);

         int month_idx = -1;
         for(int j = 0; j < total_months; j++)
           {
            if(monthly_counts[j].year == dt.year && monthly_counts[j].month == dt.mon)
              {
               month_idx = j;
               break;
              }
           }

         if(month_idx == -1)
           {
            ArrayResize(monthly_counts, total_months + 1);
            monthly_counts[total_months].year = dt.year;
            monthly_counts[total_months].month = dt.mon;
            monthly_counts[total_months].count = 1;
            total_months++;
           }
         else
           {
            monthly_counts[month_idx].count++;
           }
        }
     }

   if(total_months <= 1)
     {
      downside_consistency = 1.0;
      return;
     }

   double target_trades_per_month = InpMinTradesPerYear / 12.0;
   if(target_trades_per_month < 1) target_trades_per_month = 1;

   double sum_of_squared_downside_dev = 0;
   for(int i = 0; i < total_months; i++)
     {
      if(monthly_counts[i].count < target_trades_per_month)
        {
         double deviation = target_trades_per_month - monthly_counts[i].count;
         sum_of_squared_downside_dev += deviation * deviation;
        }
     }

   double downside_variance = sum_of_squared_downside_dev / total_months;
   double downside_deviation = MathSqrt(downside_variance);
   downside_consistency = 1.0 / (1.0 + downside_deviation);
  }












//+------------------------------------------------------------------+
//|                                                 TradeManager.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل.
#property link      "https://..." // لینک مرتبط با پروژه.

//--- گارد برای جلوگیری از include شدن چندباره.
#ifndef TRADEMANAGER_MQH // چک گارد.
#define TRADEMANAGER_MQH // تعریف گارد.

#include "Settings.mqh"     // کتابخانه تنظیمات ورودی کاربر.
#include "RangeLib.mqh"     // کتابخانه تحلیل و اعتبارسنجی محدوده (شامل struct RangeData).
#include <Trade\Trade.mqh>  // کتابخانه استاندارد MQL5 برای معاملات.
CTrade trade;               // نمونه سراسری CTrade برای عملیات معاملاتی.

//+------------------------------------------------------------------+
//| Function to Calculate Lot Size                                   |
//+------------------------------------------------------------------+
//--- این تابع حجم معامله را بر اساس درصد ریسک و فاصله استاپ لاس محاسبه می‌کند.
double CalculateLotSize(double risk_percent,double stop_loss_pips)
  {
   //--- شرط ایمنی: اگر فاصله استاپ صفر یا منفی، حجم صفر.
   if(stop_loss_pips <= 0) return 0.0;

   //--- گرفتن اکویتی حساب (شامل سود/زیان باز).
   double account_equity = AccountInfoDouble(ACCOUNT_EQUITY);
   //--- محاسبه مبلغ ریسک مجاز.
   double risk_amount = account_equity * (risk_percent / 100.0);

   //--- گرفتن ارزش تیک و اندازه تیک نماد.
   double tick_value = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
   double tick_size = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);

   //--- شرط ایمنی: اگر اطلاعات نامعتبر، حجم صفر.
   if(tick_value <= 0 || tick_size <= 0) return 0.0;

   //--- محاسبه ارزش هر پیپ.
   double value_per_pip = tick_value / tick_size * _Point;
   if(value_per_pip <= 0) return 0.0;

   //--- محاسبه حجم خام.
   double lot_size = risk_amount / (stop_loss_pips * value_per_pip);

   //--- گرفتن قوانین بروکر برای حجم.
   double min_lot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   double max_lot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX);
   double lot_step = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);

   //--- گرد کردن حجم به گام مجاز.
   lot_size = MathRound(lot_size / lot_step) * lot_step;
   //--- محدود کردن بین min و max.
   lot_size = MathMax(min_lot,MathMin(max_lot,lot_size));

   return lot_size; // بازگشت حجم نهایی.
  }

//+------------------------------------------------------------------+
//| Function to Place Pending Orders                                 |
//+------------------------------------------------------------------+
//--- این تابع سفارشات پندینگ را بر اساس قیمت‌های محاسبه شده ثبت می‌کند.
void PlacePendingOrders(int session_magic_base,bool is_trend_on,bool is_uptrend,RangeData &rd,double buy_stop_price,double sell_stop_price)
  {
   //--- محاسبه فاصله اضافی برای استاپ لاس.
   double sl_additional_pips = rd.rangeSizePips * (InpStopLossAdditionalPercent / 100.0);
   //--- محاسبه فاصله کل استاپ لاس به پیپ.
   double sl_distance_pips = rd.rangeSizePips + sl_additional_pips;

   //--- محاسبه حجم معامله.
   double lot_size = CalculateLotSize(InpRiskPercentage,sl_distance_pips);
   if(lot_size <= 0) return; // اگر حجم نامعتبر، خارج شو.

   //--- محاسبه استاپ لاس برای خرید و فروش.
   double buy_sl = rd.rangeLow - sl_additional_pips * _Point;
   double sell_sl = rd.rangeHigh + sl_additional_pips * _Point;

   double buy_tp = 0.0; // پیش‌فرض بدون تی‌پی (برای پله‌ای).
   double sell_tp = 0.0;

   //--- اگر پله‌ای خاموش باشد، تی‌پی ثابت محاسبه کن.
   if(!InpEnablePartialClose)
     {
      buy_tp = buy_stop_price + (buy_stop_price - buy_sl) * InpTakeProfitRatio_Stage1;
      sell_tp = sell_stop_price - (sell_sl - sell_stop_price) * InpTakeProfitRatio_Stage1;
     }

   //--- اگر فیلتر روند خاموش، هر دو سفارش را ثبت کن.
   if(!is_trend_on)
     {
      trade.BuyStop(lot_size,buy_stop_price,_Symbol,buy_sl,buy_tp,0,0,IntegerToString(session_magic_base)); // ثبت BuyStop.
      trade.SellStop(lot_size,sell_stop_price,_Symbol,sell_sl,sell_tp,0,0,IntegerToString(session_magic_base)); // ثبت SellStop.
     }
   else // اگر روند فعال، فقط در جهت روند ثبت کن.
     {
      if(is_uptrend) trade.BuyStop(lot_size,buy_stop_price,_Symbol,buy_sl,buy_tp,0,0,IntegerToString(session_magic_base)); // فقط خرید اگر صعودی.
      else trade.SellStop(lot_size,sell_stop_price,_Symbol,sell_sl,sell_tp,0,0,IntegerToString(session_magic_base)); // فقط فروش اگر نزولی.
     }
  }

//+------------------------------------------------------------------+
//| Function for Session CleanUp                                     |
//+------------------------------------------------------------------+
//--- این تابع تمام پوزیشن‌ها و سفارشات جلسه را در انقضا پاک می‌کند.
void SessionCleanUp(int session_magic_base)
  {
   //--- حلقه روی پوزیشن‌های باز.
   for(int i=PositionsTotal()-1; i>=0; i--)
     {
      ulong pos_ticket = PositionGetTicket(i); // تیکت پوزیشن.
      if(pos_ticket > 0 && PositionSelectByTicket(pos_ticket)) // اگر معتبر و انتخاب شود.
        {
         long magic = PositionGetInteger(POSITION_MAGIC); // مجیک پوزیشن.
         if(magic == session_magic_base) trade.PositionClose(pos_ticket); // اگر مطابقت، ببند.
        }
     }

   //--- حلقه روی سفارشات پندینگ.
   for(int i=OrdersTotal()-1; i>=0; i--)
     {
      ulong ord_ticket = OrderGetTicket(i); // تیکت سفارش.
      if(ord_ticket > 0 && OrderSelect(ord_ticket)) // اگر معتبر و انتخاب شود.
        {
         if(OrderGetInteger(ORDER_MAGIC) == session_magic_base) trade.OrderDelete(ord_ticket); // اگر مطابقت، حذف.
        }
     }
  }

#endif //TRADEMANAGER_MQH












//+------------------------------------------------------------------+
//|                                                    RangeLib.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل.
#property link      "https://..." // لینک مرتبط با پروژه.

//--- این گارد از include شدن چندباره فایل در پروژه جلوگیری می‌کند.
#ifndef RANGELIB_MQH // چک گارد.
#define RANGELIB_MQH // تعریف گارد.

#include "Settings.mqh"     // کتابخانه تنظیمات ورودی کاربر.

//+------------------------------------------------------------------+
//| STRUCT for Range Data                                            |
//+------------------------------------------------------------------+
//--- ساختار برای نگهداری داده‌های محدوده. این ساختار مثل یک کلاس ساده عمل می‌کند و تمام داده‌های مرتبط را در یک جا نگه می‌دارد تا کد خواناتر شود.
struct RangeData
  {
   double            rangeHigh;      // بالاترین قیمت شناسایی شده در بازه (High محدوده).
   double            rangeLow;       // پایین‌ترین قیمت شناسایی شده در بازه (Low محدوده).
   bool              isValid;        // پرچم اعتبار محدوده (true اگر پس از اعتبارسنجی معتبر باشد).
   datetime          startTime;      // زمان شروع بازه به فرمت datetime برای ترسیم و محاسبات.
   datetime          endTime;        // زمان پایان بازه به فرمت datetime.
   double            rangeSizePips;  // اندازه محدوده به پیپ (برای محاسبات ریسک و استاپ لاس).
  };

//+------------------------------------------------------------------+
//| Function to Draw Range on Chart                                  |
//+------------------------------------------------------------------+
//--- این تابع برای نمایش بصری محدوده روی چارت استفاده می‌شود تا کاربر بتواند محدوده شناسایی‌شده را به صورت گرافیکی ببیند و استراتژی را ارزیابی کند.
void DrawRangeOnChart(RangeData &rd,int session_magic)
  {
   //--- اگر محدوده نامعتبر باشد، هیچ چیزی ترسیم نکن تا از خطاهای غیرضروری جلوگیری شود.
   if(!rd.isValid) return;

   //--- ساخت پیشوند منحصر به فرد برای اشیاء این جلسه تا با جلسات دیگر تداخل نداشته باشد.
   string obj_prefix = "Range_" + IntegerToString(session_magic) + "_";

   //--- ایجاد مستطیل برای نمایش محدوده زمانی و قیمتی.
   ObjectCreate(0,obj_prefix + "Rect",OBJ_RECTANGLE,0,rd.startTime,rd.rangeHigh,rd.endTime,rd.rangeLow);
   //--- تنظیم رنگ مستطیل برای تمایز بصری.
   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_COLOR,clrDarkSlateGray);
   //--- تنظیم استایل خطوط مستطیل (جامد برای وضوح).
   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_STYLE,STYLE_SOLID);
   //--- پر کردن داخل مستطیل برای نمایش بهتر محدوده.
   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_FILL,true);
   //--- ارسال مستطیل به پس‌زمینه تا مزاحم دیدن کندل‌ها نشود.
   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_BACK,true);
  }

//+------------------------------------------------------------------+
//| Helper Function: IsKijunFlat                                     |
//+------------------------------------------------------------------+
//--- این تابع چک می‌کند آیا کیجون‌سن صاف است (شیب نزدیک به صفر با رگرسیون خطی). تایم فریم را به عنوان ورودی می‌گیرد تا مستقل از چارت باشد.
//--- نکته آموزشی: از رگرسیون خطی ساده برای محاسبه شیب استفاده می‌شود. دوره (InpKijunFlatPeriod) اجازه می‌دهد تا حساسیت را تنظیم کنید: دوره کوتاه (مثل ۳) سیگنال‌های بیشتری می‌دهد اما ممکن است نویز داشته باشد؛ دوره بلند (مثل ۲۰) سیگنال‌های باکیفیت‌تری می‌دهد اما کمتر.
bool IsKijunFlat(int ichimoku_handle,int bar_idx,ENUM_TIMEFRAMES timeframe)
  {
   //--- تعریف آرایه دینامیک برای کیجون‌سن بر اساس دوره ورودی.
   double kijun_buffer[]; // آرایه برای مقادیر کیجون.
   ArrayResize(kijun_buffer, InpKijunFlatPeriod); // تغییر اندازه آرایه به دوره مشخص‌شده.
   //--- کپی مقادیر کیجون از هندل (از دوره-۱ کندل قبل تا کندل فعلی).
   if(CopyBuffer(ichimoku_handle,1,bar_idx - InpKijunFlatPeriod + 1,InpKijunFlatPeriod,kijun_buffer) != InpKijunFlatPeriod) return false; // اگر کپی شکست خورد، false برگردان.

   //--- محاسبه شیب رگرسیون خطی ساده برای دوره کندل.
   double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0; // متغیرهای جمع برای فرمول رگرسیون.
   double n = InpKijunFlatPeriod; // تعداد نقاط (دوره).
   for(int k = 0; k < InpKijunFlatPeriod; k++) // حلقه روی دوره برای محاسبه جمع‌ها.
     {
      double x = k + 1.0; // x ایندکس از ۱ تا n.
      double y = kijun_buffer[InpKijunFlatPeriod - 1 - k]; // y مقادیر کیجون از قدیمی به جدید (چون بافر از جدید به قدیمی است).
      sum_x += x; // جمع x.
      sum_y += y; // جمع y.
      sum_xy += x * y; // جمع xy.
      sum_x2 += x * x; // جمع x^2.
     }

   double denominator = (n * sum_x2 - sum_x * sum_x); // دنومیناتور شیب.
   if (denominator == 0) return false; // جلوگیری از تقسیم بر صفر (هرچند بعید است).

   //--- فرمول شیب رگرسیون.
   double slope = (n * sum_xy - sum_x * sum_y) / denominator;

   //--- اگر شیب مطلق کمتر از آستانه (مثل ۰.۰۰۰۱) باشد، صاف در نظر بگیر. این آستانه را می‌توان تنظیم کرد اگر نیاز به حساسیت بیشتر باشد.
   return MathAbs(slope) < 0.0001;
  }

//+------------------------------------------------------------------+
//| Helper Function: IsCandleInKumo                                  |
//+------------------------------------------------------------------+
//--- این تابع چک می‌کند آیا کندل کاملاً درون ابر کومو است. تایم فریم را به عنوان ورودی می‌گیرد تا با تایم فریم جلسه همخوانی داشته باشد.
//--- نکته آموزشی: چک می‌کند آیا High کندل زیر سقف کومو و Low بالای کف کومو باشد، که نشان‌دهنده تعادل بازار است.
bool IsCandleInKumo(int ichimoku_handle,int bar_idx,ENUM_TIMEFRAMES timeframe)
  {
   //--- خواندن سنکو A و B برای کندل مشخص.
   double senkou_a[1], senkou_b[1]; // بافرها برای سنکو A و B.
   if(CopyBuffer(ichimoku_handle,2,bar_idx,1,senkou_a) != 1) return false; // کپی سنکو A، اگر شکست false.
   if(CopyBuffer(ichimoku_handle,3,bar_idx,1,senkou_b) != 1) return false; // کپی سنکو B، اگر شکست false.

   //--- گرفتن High و Low کندل از تایم فریم جلسه.
   double high = iHigh(_Symbol,timeframe,bar_idx); // بالاترین قیمت کندل.
   double low = iLow(_Symbol,timeframe,bar_idx); // پایین‌ترین قیمت کندل.

   //--- تعیین سقف و کف ابر کومو (سقف Max سنکوها، کف Min).
   double kumo_top = MathMax(senkou_a[0],senkou_b[0]); // سقف کومو.
   double kumo_bottom = MathMin(senkou_a[0],senkou_b[0]); // کف کومو.

   //--- چک شرط تعادل: High <= سقف و Low >= کف.
   return (high <= kumo_top && low >= kumo_bottom);
  }

#endif //RANGELIB_MQH









//+------------------------------------------------------------------+
//|                                             SessionTrader.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل.
#property link      "https://..." // لینک مرتبط با پروژه.

//--- این گارد از include شدن چندباره فایل در پروژه جلوگیری می‌کند.
#ifndef SESSIONTRADER_MQH // چک گارد.
#define SESSIONTRADER_MQH // تعریف گارد.

#include "Settings.mqh"     // کتابخانه تنظیمات ورودی کاربر.
#include "RangeLib.mqh"     // کتابخانه توابع کمکی برای تحلیل محدوده.
#include "TradeManager.mqh" // کتابخانه مدیریت معاملات و ریسک.

//+------------------------------------------------------------------+
//| Class CSessionTrader                                             |
//+------------------------------------------------------------------+
//--- این کلاس، منطق کامل یک جلسه معاملاتی را کپسوله می‌کند تا سیستم ماژولار و بدون تداخل باشد. هر نمونه از این کلاس یک جلسه مستقل را مدیریت می‌کند.
class CSessionTrader
  {
private:
   // --- متغیرهای پیکربندی ---
   bool              m_is_active; // وضعیت فعال بودن جلسه (true اگر فعال باشد).
   int               m_magic_number; // مجیک نامبر منحصر به فرد برای شناسایی معاملات این جلسه.
   ENUM_TIMEFRAMES   m_timeframe; // تایم فریم مخصوص این جلسه برای تحلیل محدوده.
   int               m_start_hour, m_start_min; // ساعت و دقیقه شروع بازه تحلیل.
   int               m_end_hour, m_end_min; // ساعت و دقیقه پایان بازه تحلیل.
   int               m_expiry_hour, m_expiry_min; // ساعت و دقیقه انقضای جلسه (برای پاکسازی).

   // --- هندل‌های اندیکاتور ---
   int               m_ichimoku_handle; // هندل اندیکاتور ایچیموکو برای فیلتر تعادل بازار.
   int               m_placement_atr_handle; // هندل ATR برای محاسبه بافر دینامیک سفارشات.
   int               m_range_atr_handle; // هندل ATR برای اعتبارسنجی اندازه محدوده.
   int               m_ema_handle; // هندل EMA برای فیلتر روند.
   int               m_trail_atr_handle; // هندل ATR برای ترلینگ استاپ.

   // --- متغیرهای وضعیت ---
   datetime          m_last_analysis_date; // تاریخ آخرین تحلیل موفق برای جلوگیری از تکرار روزانه.

public:
   //--- سازنده کلاس: تمام متغیرها را با مقادیر پیش‌فرض مقداردهی می‌کند تا از خطاهای زمان اجرا جلوگیری شود.
                     CSessionTrader(void) : m_is_active(false), m_magic_number(0), m_timeframe(PERIOD_M15),
                     m_start_hour(0),m_start_min(0), m_end_hour(0),m_end_min(0), m_expiry_hour(0),m_expiry_min(0),
                     m_ichimoku_handle(INVALID_HANDLE), m_placement_atr_handle(INVALID_HANDLE), m_range_atr_handle(INVALID_HANDLE),
                     m_ema_handle(INVALID_HANDLE), m_trail_atr_handle(INVALID_HANDLE), m_last_analysis_date(0) {} // اولیه‌سازی صریح همه متغیرها برای ایمنی.

   //--- این تابع برای مقداردهی اولیه کلاس با پارامترهای ورودی یک جلسه استفاده می‌شود. هندل‌های اندیکاتورها را ایجاد می‌کند و در صورت خطا لاگ می‌زند.
   void              Init(bool is_active,ENUM_TIMEFRAMES timeframe,int start_h,int start_m,int end_h,int end_m,int expiry_h,int expiry_m,int magic)
     {
      m_is_active = is_active; // تنظیم وضعیت فعال بودن جلسه.
      m_timeframe = timeframe; // تنظیم تایم فریم تحلیل جلسه.
      m_start_hour = start_h; // تنظیم ساعت شروع بازه.
      m_start_min = start_m; // تنظیم دقیقه شروع بازه.
      m_end_hour = end_h; // تنظیم ساعت پایان بازه.
      m_end_min = end_m; // تنظیم دقیقه پایان بازه.
      m_expiry_hour = expiry_h; // تنظیم ساعت انقضا.
      m_expiry_min = expiry_m; // تنظیم دقیقه انقضا.
      m_magic_number = magic; // تنظیم مجیک نامبر منحصر به فرد.

      if(!m_is_active) return; // اگر جلسه غیرفعال است، هندل‌ها را ایجاد نکن تا منابع هدر نرود.

      m_ichimoku_handle = iIchimoku(_Symbol,m_timeframe,InpIchimoku_Tenkan,InpIchimoku_Kijun,InpIchimoku_Senkou); // ایجاد هندل ایچیموکو با پارامترهای ورودی کاربر و تایم فریم جلسه.
      if(m_ichimoku_handle == INVALID_HANDLE) Print("خطا در ایجاد هندل ایچیموکو برای جلسه ",magic); // لاگ خطا اگر ایجاد نشود.

      m_placement_atr_handle = iATR(_Symbol,m_timeframe,InRangeATR_Period); // ایجاد هندل ATR برای بافر قرارگیری سفارشات، با تایم فریم جلسه.
      if(m_placement_atr_handle == INVALID_HANDLE) Print("خطا در ایجاد هندل ATR قرارگیری برای جلسه ",magic); // لاگ خطا.

      m_range_atr_handle = iATR(_Symbol,InRangeATR_TimeFrame,InRangeATR_Period); // ایجاد هندل ATR برای اعتبارسنجی محدوده.
      if(m_range_atr_handle == INVALID_HANDLE) Print("خطا در ایجاد هندل ATR اعتبارسنجی برای جلسه ",magic); // لاگ خطا.

      m_ema_handle = iMA(_Symbol,InpTrendEMATimeFrame,InpTrendEMAPeriod,0,MODE_EMA,InpTrendEMAAppliedPrice); // ایجاد هندل EMA برای فیلتر روند.
      if(m_ema_handle == INVALID_HANDLE) Print("خطا در ایجاد هندل EMA برای جلسه ",magic); // لاگ خطا.

      m_trail_atr_handle = iATR(_Symbol,InpTrailingStopATRTimeFrame,InpTrailingStopATRPeriod); // ایجاد هندل ATR برای ترلینگ استاپ.
      if(m_trail_atr_handle == INVALID_HANDLE) Print("خطا در ایجاد هندل ATR ترلینگ برای جلسه ",magic); // لاگ خطا.
     }

   //--- این تابع برای آزادسازی منابع (هندل‌ها و اشیاء گرافیکی) در زمان حذف اکسپرت استفاده می‌شود تا حافظه آزاد شود.
   void              Deinit(void)
     {
      if(m_ichimoku_handle != INVALID_HANDLE) IndicatorRelease(m_ichimoku_handle); // آزادسازی هندل ایچیموکو اگر معتبر باشد.
      if(m_placement_atr_handle != INVALID_HANDLE) IndicatorRelease(m_placement_atr_handle); // آزادسازی هندل ATR قرارگیری.
      if(m_range_atr_handle != INVALID_HANDLE) IndicatorRelease(m_range_atr_handle); // آزادسازی هندل ATR اعتبارسنجی.
      if(m_ema_handle != INVALID_HANDLE) IndicatorRelease(m_ema_handle); // آزادسازی هندل EMA.
      if(m_trail_atr_handle != INVALID_HANDLE) IndicatorRelease(m_trail_atr_handle); // آزادسازی هندل ATR ترلینگ.
      ObjectsDeleteAll(0,"Range_"+IntegerToString(m_magic_number)+"_"); // حذف تمام اشیاء گرافیکی مربوط به این جلسه با پیشوند خاص.
     }

   //--- این تابع هر ۶۰ ثانیه فراخوانی می‌شود و منطق تحلیل و پاکسازی جلسه را مدیریت می‌کند. این روش بهینه است زیرا بار OnTick را کاهش می‌دهد.
   void              OnTimerUpdate(void)
     {
      if(!m_is_active) return; // اگر جلسه غیرفعال است، از تابع خارج شو تا پردازش بیهوده انجام نشود.

      datetime now = TimeCurrent(); // گرفتن زمان فعلی سرور.
      MqlDateTime now_struct; // ساختار برای شکستن زمان به اجزا.
      TimeToStruct(now,now_struct); // تبدیل زمان به ساختار.

      if(now_struct.hour == m_expiry_hour && now_struct.min == m_expiry_min) // چک اگر زمان انقضا رسیده باشد.
        {
         SessionCleanUp(m_magic_number); // فراخوانی تابع پاکسازی برای بستن پوزیشن‌ها و حذف سفارشات.
         return; // خروج از تابع پس از پاکسازی.
        }

      MqlDateTime end_struct = now_struct; // ساختار برای زمان پایان بازه.
      end_struct.hour = m_end_hour; // تنظیم ساعت پایان.
      end_struct.min = m_end_min; // تنظیم دقیقه پایان - تحلیل دقیقا در دقیقه پایان انجام می‌شود تا کندل کامل شود.
      end_struct.sec = 0; // ثانیه صفر برای دقت.
      datetime analysis_time = StructToTime(end_struct); // تبدیل ساختار به datetime.

      if(now >= analysis_time && !IsSameDay(m_last_analysis_date,now)) // اگر زمان تحلیل رسیده و امروز تحلیل نشده.
        {
         AnalyzeAndPlaceOrders(); // فراخوانی تابع تحلیل و قرارگیری سفارشات.
         m_last_analysis_date = now; // آپدیت تاریخ آخرین تحلیل برای جلوگیری از تکرار.
        }
     }

   //--- این تابع مجیک نامبر جلسه را برمی‌گرداند تا در OnTick برای پیدا کردن نمونه کلاس استفاده شود.
   int               GetMagicNumber(void) { return m_magic_number; } // بازگشت ساده مجیک نامبر.

   //--- این تابع مدیریت معاملات فعال (خروج پله‌ای و ترلینگ استاپ) را انجام می‌دهد. حالا داخل کلاس است تا به هندل ATR دسترسی داشته باشد.
   bool              ManageActiveTrade(ulong ticket)
     {
      if(!PositionSelectByTicket(ticket)) return false; // اگر پوزیشن انتخاب نشود، false برگردان.

      long current_magic = PositionGetInteger(POSITION_MAGIC); // خواندن مجیک پوزیشن.
      if(current_magic != m_magic_number) return false; // اگر مجیک مطابقت ندارد، false.

      if(!InpEnablePartialClose) return false; // اگر خروج پله‌ای خاموش، هیچ کاری نکن.

      double entry_price = PositionGetDouble(POSITION_PRICE_OPEN); // قیمت ورود پوزیشن.
      double current_sl = PositionGetDouble(POSITION_SL); // استاپ لاس فعلی.
      double volume = PositionGetDouble(POSITION_VOLUME); // حجم پوزیشن.
      ENUM_POSITION_TYPE pos_type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE); // نوع پوزیشن (خرید یا فروش).

      bool is_stage1 = (pos_type == POSITION_TYPE_BUY && current_sl < entry_price - _Point * 10) || // چک مرحله ۱ برای خرید (استاپ زیر ورود).
                       (pos_type == POSITION_TYPE_SELL && current_sl > entry_price + _Point * 10); // چک مرحله ۱ برای فروش (استاپ بالای ورود).
      if(is_stage1)
        {
         double sl_distance_price = MathAbs(entry_price - current_sl); // فاصله استاپ از ورود.
         double target_price = (pos_type == POSITION_TYPE_BUY) ? entry_price + sl_distance_price * InpTakeProfitRatio_Stage1 : // هدف برای خرید.
                               entry_price - sl_distance_price * InpTakeProfitRatio_Stage1; // هدف برای فروش.

         double current_price = (pos_type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol,SYMBOL_BID) : // قیمت فعلی برای خرید (Bid).
                                SymbolInfoDouble(_Symbol,SYMBOL_ASK); // قیمت فعلی برای فروش (Ask).

         if((pos_type == POSITION_TYPE_BUY && current_price >= target_price) || // اگر هدف رسیده برای خرید.
            (pos_type == POSITION_TYPE_SELL && current_price <= target_price)) // اگر هدف رسیده برای فروش.
           {
            double lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP); // گام لات بروکر.
            double min_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN); // حداقل لات.
            double volume_to_close_raw = volume * (InpPartialClosePercentage / 100.0); // حجم خام برای بستن.
            double close_volume = MathRound(volume_to_close_raw / lot_step) * lot_step; // گرد به گام.

            if(volume - close_volume < min_lot && volume > min_lot) close_volume = volume; // اگر باقی‌مانده کمتر از min، کل را ببند.

            if(close_volume >= min_lot) // اگر حجم معتبر.
              {
               if(trade.PositionClose(ticket,close_volume)) // بستن پله‌ای.
                 {
                  if(PositionSelectByTicket(ticket)) // اگر هنوز باز است.
                    {
                     trade.PositionModify(ticket,entry_price,0.0); // انتقال استاپ به ورود.
                    }
                  return true; // موفقیت.
                 }
               else
                 {
                  return false; // شکست.
                 }
              }
           }
        }

      bool is_stage2 = (pos_type == POSITION_TYPE_BUY && current_sl >= entry_price - _Point) || // چک مرحله ۲ برای خرید.
                       (pos_type == POSITION_TYPE_SELL && current_sl <= entry_price + _Point); // چک مرحله ۲ برای فروش.
      if(is_stage2)
        {
         double atr_buffer[1]; // بافر برای ATR.
         if(CopyBuffer(m_trail_atr_handle,0,1,1,atr_buffer) !=1) return false; // خواندن ATR، اگر شکست false.
         double trail_offset = atr_buffer[0] * InpTrailingStopATRMultiplier; // افست ترلینگ.

         if(pos_type == POSITION_TYPE_BUY) // برای خرید.
           {
            double new_sl = SymbolInfoDouble(_Symbol,SYMBOL_BID) - trail_offset; // استاپ جدید زیر Bid.
            if(new_sl > current_sl) // اگر بهتر.
              {
               trade.PositionModify(ticket,new_sl,0.0); // اصلاح استاپ.
               return true; // موفقیت.
              }
           }
         else // برای فروش.
           {
            double new_sl = SymbolInfoDouble(_Symbol,SYMBOL_ASK) + trail_offset; // استاپ جدید بالای Ask.
            if(new_sl < current_sl) // اگر بهتر.
              {
               trade.PositionModify(ticket,new_sl,0.0); // اصلاح استاپ.
               return true; // موفقیت.
              }
           }
        }

      return false; // هیچ عملیاتی انجام نشد.
     }

private:
   //--- این تابع محدوده معتبر را شناسایی و اعتبارسنجی می‌کند. اگر ایچیموکو روشن باشد، از فیلتر پیشرفته استفاده می‌کند.
   bool              IdentifyValidRange(RangeData &rd)
     {
      rd.isValid = false; // پیش‌فرض نامعتبر.

      datetime now = TimeCurrent(); // زمان فعلی سرور.
      MqlDateTime now_struct; // ساختار زمان.
      TimeToStruct(now,now_struct); // تبدیل به ساختار.

      MqlDateTime end_dt_struct = now_struct; // ساختار پایان.
      end_dt_struct.hour = m_end_hour; // تنظیم ساعت پایان.
      end_dt_struct.min = m_end_min; // تنظیم دقیقه پایان.
      end_dt_struct.sec = 0; // ثانیه صفر.
      datetime end_time = StructToTime(end_dt_struct); // تبدیل به datetime.

      MqlDateTime start_dt_struct = now_struct; // ساختار شروع.
      start_dt_struct.hour = m_start_hour; // تنظیم ساعت شروع.
      start_dt_struct.min = m_start_min; // تنظیم دقیقه شروع.
      start_dt_struct.sec = 0; // ثانیه صفر.
      datetime start_time = StructToTime(start_dt_struct); // تبدیل به datetime.

      if(m_start_hour > m_end_hour) // مدیریت جلسات شبانه.
        {
         if(now_struct.hour < m_end_hour) start_time -= 86400; // شروع به دیروز.
         else end_time += 86400; // پایان به فردا.
        }
      
      rd.startTime = start_time; // ذخیره شروع.
      rd.endTime = end_time; // ذخیره پایان.

      int start_bar_idx = iBarShift(_Symbol,m_timeframe,start_time,true); // ایندکس شروع (قدیمی‌ترین).
      int end_bar_idx = iBarShift(_Symbol,m_timeframe,end_time,true); // ایندکس پایان (جدیدترین).

      if(start_bar_idx < 0 || end_bar_idx < 0) return false; // اگر ایندکس نامعتبر.

      int bars_to_check = start_bar_idx - end_bar_idx + 1; // تعداد کندل‌ها.
      if(bars_to_check <= 0) return false; // اگر تعداد نامعتبر.

      if(InpUseIchimokuFilter) // اگر ایچیموکو فعال.
        {
         int max_sequence = 0; // حداکثر سکانس.
         int current_sequence = 0; // سکانس فعلی.
         int sequence_start_idx = -1; // شروع سکانس فعلی.
         int best_start_idx = -1; // بهترین شروع.

         for(int i = start_bar_idx; i >= end_bar_idx; i--) // حلقه از قدیمی به جدید.
           {
            if(IsCandleInKumo(m_ichimoku_handle, i, m_timeframe) && IsKijunFlat(m_ichimoku_handle, i, m_timeframe)) // چک شرایط تعادل.
              {
               if(current_sequence == 0) sequence_start_idx = i; // شروع جدید.
               current_sequence++; // افزایش.
              }
            else
              {
               if(current_sequence > max_sequence) // آپدیت اگر بهتر.
                 {
                  max_sequence = current_sequence;
                  best_start_idx = sequence_start_idx;
                 }
               current_sequence = 0; // ریست.
              }
           }
           
           if(current_sequence > max_sequence) // چک نهایی برای سکانس آخر.
             {
              max_sequence = current_sequence;
              best_start_idx = sequence_start_idx;
             }

           if(max_sequence >= InpMinConsecutiveCandles) // اگر معتبر.
             {
              int high_bar_idx = iHighest(_Symbol,m_timeframe,MODE_HIGH,max_sequence,best_start_idx); // High.
              int low_bar_idx = iLowest(_Symbol,m_timeframe,MODE_LOW,max_sequence,best_start_idx); // Low.
              
              if(high_bar_idx != -1 && low_bar_idx != -1) // اگر ایندکس معتبر.
                {
                 rd.rangeHigh = iHigh(_Symbol,m_timeframe,high_bar_idx); // High.
                 rd.rangeLow = iLow(_Symbol,m_timeframe,low_bar_idx); // Low.
                 rd.rangeSizePips = (rd.rangeHigh - rd.rangeLow) / _Point; // اندازه.
                 rd.isValid = true; // معتبر.
                }
             }
        }
      else // منطق بدون ایچیموکو.
        {
         int high_bar_idx = iHighest(_Symbol,m_timeframe,MODE_HIGH,bars_to_check,end_bar_idx); // High.
         int low_bar_idx = iLowest(_Symbol,m_timeframe,MODE_LOW,bars_to_check,end_bar_idx); // Low.
         
         if(high_bar_idx != -1 && low_bar_idx != -1) // اگر معتبر.
           {
            rd.rangeHigh = iHigh(_Symbol,m_timeframe,high_bar_idx); // High.
            rd.rangeLow = iLow(_Symbol,m_timeframe,low_bar_idx); // Low.
            rd.rangeSizePips = (rd.rangeHigh - rd.rangeLow) / _Point; // اندازه.

            if(InpRangeFilterMode == MODE_POINTS) // حالت پوینت.
              {
               if(rd.rangeSizePips >= InpMinRangePoints && rd.rangeSizePips <= InpMaxRangePoints) rd.isValid = true; // چک اندازه.
              }
            else // حالت ATR.
              {
               double atr_buffer[1];
               if(CopyBuffer(m_range_atr_handle,0,1,1,atr_buffer) == 1) // خواندن ATR.
                 {
                  double atr_value = atr_buffer[0];
                  if(atr_value > 0) // اگر مثبت.
                    {
                     double min_allowed = (atr_value * InRangeATR_MinMultiplier) / _Point; // حداقل.
                     double max_allowed = (atr_value * InRangeATR_MaxMultiplier) / _Point; // حداکثر.
                     if(rd.rangeSizePips >= min_allowed && rd.rangeSizePips <= max_allowed) rd.isValid = true; // چک.
                    }
                 }
              }
           }
        }
      return rd.isValid; // بازگشت وضعیت اعتبار.
     }

   //--- این تابع تحلیل محدوده را انجام داده و در صورت معتبر بودن، سفارشات را قرار می‌دهد.
   void              AnalyzeAndPlaceOrders(void)
     {
      RangeData rd; // ساختار محدوده.
      if(!IdentifyValidRange(rd)) return; // اگر نامعتبر، خارج.

      DrawRangeOnChart(rd,m_magic_number); // ترسیم محدوده.

      bool is_trend_on = InpTrendFilterIsOn; // وضعیت روند.
      bool is_uptrend = false; // جهت روند.

      if(is_trend_on) // اگر فعال.
        {
         double ema_buffer[1];
         if(CopyBuffer(m_ema_handle,0,1,1,ema_buffer) == 1) // خواندن EMA.
           {
            double current_price = SymbolInfoDouble(_Symbol,SYMBOL_BID); // قیمت.
            is_uptrend = current_price > ema_buffer[0]; // چک جهت.
           }
        }

      double atr_buffer[1];
      if(CopyBuffer(m_placement_atr_handle,0,1,1,atr_buffer) != 1) return; // خواندن ATR.
      double atr_value = atr_buffer[0]; // مقدار.
      double buffer = atr_value * InpAtrMultiplier_Placement; // بافر.

      double buy_stop_price = rd.rangeHigh + buffer; // قیمت خرید.
      double sell_stop_price = rd.rangeLow - buffer; // قیمت فروش.

      double current_bid = SymbolInfoDouble(_Symbol,SYMBOL_BID); // Bid.
      double current_ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK); // Ask.
      if((is_trend_on && is_uptrend && current_ask >= buy_stop_price) ||  // Safety check برای خرید.
         (is_trend_on && !is_uptrend && current_bid <= sell_stop_price) || // برای فروش.
         (!is_trend_on && (current_ask >= buy_stop_price || current_bid <= sell_stop_price))) // بدون روند.
         {
            return; // اگر عبور کرده، سفارش نگذار.
         }

      PlacePendingOrders(m_magic_number,is_trend_on,is_uptrend,rd,buy_stop_price,sell_stop_price); // قرارگیری سفارشات.
     }

   //--- این تابع چک می‌کند آیا دو تاریخ در یک روز هستند. برای جلوگیری از تحلیل تکراری روزانه استفاده می‌شود.
   bool              IsSameDay(datetime d1,datetime d2)
     {
      MqlDateTime s1,s2; // ساختارها برای شکستن زمان.
      TimeToStruct(d1,s1); // تبدیل d1 به ساختار (سال، ماه، روز و غیره).
      TimeToStruct(d2,s2); // تبدیل d2 به ساختار.
      return (s1.year == s2.year && s1.mon == s2.mon && s1.day == s2.day); // مقایسه سال، ماه و روز برای تعیین یکسان بودن روز.
     }
  };

#endif //SESSIONTRADER_MQH
//end






































//+------------------------------------------------------------------+
//|                                                   Settings.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                                             https://...        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل برای حفاظت قانونی.
#property link      "https://..." // لینک مرتبط با پروژه یا وبسایت توسعه‌دهنده.

//--- این گارد برای جلوگیری از include شدن چندباره فایل در پروژه است. این کار کمک می‌کند تا از خطاهای کامپایل مانند redefinition جلوگیری شود و کد تمیز بماند.
#ifndef SETTINGS_MQH // چک وجود تعریف گارد.
#define SETTINGS_MQH // تعریف گارد برای جلوگیری از تکرار.

//+------------------------------------------------------------------+
//| ENUMs for Input Parameters                                       |
//+------------------------------------------------------------------+
//--- enum برای انتخاب حالت فیلتر محدوده. این enum به ما اجازه می‌دهد تا بین دو حالت فیلتر بر اساس پوینت ثابت یا ضریبی از ATR انتخاب کنیم. این یک راه آموزشی برای تعریف گزینه‌های کاربر است و انعطاف‌پذیری سیستم را افزایش می‌دهد.
enum ENUM_RANGE_FILTER_MODE // تعریف انوم برای حالت‌های فیلتر محدوده.
  {
   MODE_POINTS, // فیلتر بر اساس پوینت ثابت - مناسب برای بازارهای با نوسان ثابت، جایی که اندازه محدوده با مقادیر ثابت کنترل می‌شود.
   MODE_ATR     // فیلتر بر اساس ضریبی از ATR - مناسب برای بازارهای پویا، جایی که فیلتر با نوسانات بازار انطباق پیدا می‌کند.
  };

//+------------------------------------------------------------------+
//| INPUT PARAMETERS                                                 |
//+------------------------------------------------------------------+

// --- تنظیمات کلی پورتفولیو ---
// این بخش تنظیمات کلی مربوط به مدیریت ریسک را شامل می‌شود که برای تمام جلسات مشترک است. این پارامترها پایه مدیریت سرمایه را تشکیل می‌دهند و کمک می‌کنند تا ریسک هر معامله کنترل‌شده باشد.
input group "====== Portfolio Global Settings ======"; // گروه ورودی برای تنظیمات کلی پورتفولیو.
input double InpRiskPercentage = 0.5; // درصد ریسک از کل سرمایه در هر معامله - این مقدار تعیین می‌کند که چقدر از سرمایه را در هر معامله ریسک کنیم. مثلاً 0.5% به معنای ریسک نیم درصد است و برای جلوگیری از ضررهای بزرگ مفید است.

// --- تنظیمات کلی فیلترها ---
// این بخش برای فیلترهای جهانی مانند ایچیموکو و ATR برای قرارگیری سفارشات استفاده می‌شود. این تنظیمات به سیستم کمک می‌کنند تا محدوده‌های باکیفیت‌تری شناسایی کند.
input group "====== Global Filter Settings ======"; // گروه ورودی برای فیلترهای جهانی.
input bool InpUseIchimokuFilter = true; // آیا فیلتر ایچیموکو فعال باشد؟ - اگر true، از فیلتر ایچیموکو برای شناسایی محدوده استفاده می‌شود؛ اگر false، از منطق قدیمی (بالاترین/پایین‌ترین قیمت) استفاده می‌شود. این گزینه انعطاف‌پذیری سیستم را افزایش می‌دهد.
input int InpIchimoku_Tenkan = 9; // دوره تنکان‌سن برای ایچیموکو - دوره کوتاه برای محاسبه میانگین بالا/پایین ۹ کندل اخیر، که حساسیت به تغییرات کوتاه‌مدت را نشان می‌دهد.
input int InpIchimoku_Kijun = 26; // دوره کیجون‌سن برای ایچیموکو - دوره متوسط برای محاسبه میانگین بالا/پایین ۲۶ کندل، که روند میان‌مدت را نشان می‌دهد.
input int InpIchimoku_Senkou = 52; // دوره سنکو اسپن B برای ایچیموکو - دوره بلند برای ابر کومو، که میانگین بالا/پایین ۵۲ کندل را محاسبه می‌کند و آینده را پیش‌بینی می‌کند.
input int InpMinConsecutiveCandles = 3; // حداقل تعداد کندل‌های متوالی برای تعادل بازار در ایچیموکو - برای تأیید پایداری تعادل و جلوگیری از سیگنال‌های کاذب.
input double InpAtrMultiplier_Placement = 0.4; // ضریب ATR برای بافر قرارگیری سفارشات - برای تنظیم فاصله دینامیک از لبه‌های محدوده، که بر اساس نوسان بازار تنظیم می‌شود و از فعال شدن زودرس جلوگیری می‌کند.
input int InpKijunFlatPeriod = 3; // دوره چک صاف بودن کیجون‌سن - تعداد کندل‌های اخیر برای محاسبه شیب رگرسیون (مثلاً ۳ برای سیگنال‌های بیشتر، ۲۰ برای سخت‌گیرانه‌تر و سیگنال‌های باکیفیت‌تر). این پارامتر برای بهینه‌سازی در بک‌تست مفید است.

// --- پارامترهای جلسه اول (Session 1) ---
// هر جلسه دارای پارامترهای مستقل برای فعال/غیرفعال کردن، زمان شروع، پایان و انقضا است. مجیک نامبر برای شناسایی معاملات منحصر به فرد است. این ساختار آموزشی برای مدیریت چند جلسه است و اجازه می‌دهد هر جلسه مانند یک استراتژی مستقل عمل کند.
input group"====== Session 1 Settings ======"; // گروه ورودی برای جلسه اول.
input bool   InpS1_IsActive = true;         // آیا جلسه اول فعال باشد؟ - اگر false باشد، این جلسه نادیده گرفته می‌شود و هیچ تحلیلی انجام نمی‌شود.
input ENUM_TIMEFRAMES InpS1_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۱ - مثلاً M15 برای کندل‌های ۱۵ دقیقه‌ای، که دقت و تعداد سیگنال‌ها را تعدیل می‌کند.
input int    InpS1_StartTime_Hour = 0;      // ساعت شروع تحلیل جلسه ۱ - زمان شروع بازه برای شناسایی محدوده (ساعت از 0 تا 23).
input int    InpS1_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۱ (دقیقه از 0 تا 59).
input int    InpS1_EndTime_Hour = 6;        // ساعت پایان تحلیل جلسه ۱ - زمان پایان بازه برای شناسایی High/Low.
input int    InpS1_EndTime_Minute = 0;      // دقیقه پایان تحلیل جلسه ۱.
input int    InpS1_ExpiryTime_Hour = 12;    // ساعت انقضای جلسه ۱ - زمانی که تمام معاملات و سفارشات این جلسه بسته/حذف می‌شوند.
input int    InpS1_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۱.
const int    S1_MagicNumber = 111101;       // مجیک نامبر اختصاصی جلسه ۱ - برای تمایز معاملات این جلسه از دیگران، باید منحصر به فرد باشد و از تداخل جلوگیری کند.

// --- پارامترهای جلسه دوم (Session 2) ---
input group "====== Session 2 Settings ======"; // گروه ورودی برای جلسه دوم.
input bool   InpS2_IsActive = true;         // آیا جلسه دوم فعال باشد؟
input ENUM_TIMEFRAMES InpS2_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۲.
input int    InpS2_StartTime_Hour = 8;      // ساعت شروع تحلیل جلسه ۲.
input int    InpS2_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۲.
input int    InpS2_EndTime_Hour = 10;       // ساعت پایان تحلیل جلسه ۲.
input int    InpS2_EndTime_Minute = 0;      // دقیقه پایان تحلیل جلسه ۲.
input int    InpS2_ExpiryTime_Hour = 20;    // ساعت انقضای جلسه ۲.
input int    InpS2_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۲.
const int    S2_MagicNumber = 222202;       // مجیک نامبر اختصاصی جلسه ۲.

// --- پارامترهای جلسه سوم (Session 3) ---
input group "====== Session 3 Settings ======"; // گروه ورودی برای جلسه سوم.
input bool   InpS3_IsActive = true;         // آیا جلسه سوم فعال باشد؟
input ENUM_TIMEFRAMES InpS3_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۳.
input int    InpS3_StartTime_Hour = 13;     // ساعت شروع تحلیل جلسه ۳.
input int    InpS3_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۳.
input int    InpS3_EndTime_Hour = 14;       // ساعت پایان تحلیل جلسه ۳.
input int    InpS3_EndTime_Minute = 30;     // دقیقه پایان تحلیل جلسه ۳.
input int    InpS3_ExpiryTime_Hour = 21;    // ساعت انقضای جلسه ۳.
input int    InpS3_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۳.
const int    S3_MagicNumber = 333303;       // مجیک نامبر اختصاصی جلسه ۳.

// --- پارامترهای جلسه چهارم (Session 4) ---
input group "====== Session 4 Settings ======"; // گروه ورودی برای جلسه چهارم.
input bool   InpS4_IsActive = false;        // آیا جلسه چهارم فعال باشد؟ - پیش‌فرض false برای غیرفعال بودن.
input ENUM_TIMEFRAMES InpS4_TimeFrame = PERIOD_M15; // تایم فریم شناسایی محدوده برای جلسه ۴.
input int    InpS4_StartTime_Hour = 0;      // ساعت شروع تحلیل جلسه ۴.
input int    InpS4_StartTime_Minute = 0;    // دقیقه شروع تحلیل جلسه ۴.
input int    InpS4_EndTime_Hour = 0;        // ساعت پایان تحلیل جلسه ۴.
input int    InpS4_EndTime_Minute = 0;      // دقیقه پایان تحلیل جلسه ۴.
input int    InpS4_ExpiryTime_Hour = 0;     // ساعت انقضای جلسه ۴.
input int    InpS4_ExpiryTime_Minute = 0;   // دقیقه انقضای جلسه ۴.
const int    S4_MagicNumber = 444404;       // مجیک نامبر اختصاصی جلسه ۴.

// --- پارامترهای تعریف محدوده (مشترک برای همه جلسات) ---
// این بخش برای شناسایی و اعتبارسنجی محدوده استفاده می‌شود و برای تمام جلسات مشترک است. این پارامترها پایه استراتژی شکست را تشکیل می‌دهند.
input group "====== Range Definition ======"; // گروه ورودی برای تعریف محدوده.
input ENUM_RANGE_FILTER_MODE InpRangeFilterMode        = MODE_ATR;     // حالت فیلتر اندازه محدوده - انتخاب بین POINTS یا ATR برای انعطاف‌پذیری.
input int                    InpMinRangePoints         = 50;           // حداقل اندازه رنج به پوینت (در حالت Points) - اگر کمتر باشد، نامعتبر، برای جلوگیری از رنج‌های کوچک و نوسانی.
input int                    InpMaxRangePoints         = 500;          // حداکثر اندازه رنج به پوینت (در حالت Points) - اگر بیشتر باشد، نامعتبر، برای جلوگیری از رنج‌های خیلی بزرگ.
input ENUM_TIMEFRAMES        InRangeATR_TimeFrame      = PERIOD_D1;    // تایم فریم محاسبه ATR برای اعتبارسنجی - مثلاً D1 برای روزانه، برای اندازه‌گیری نوسان کلی.
input int                    InRangeATR_Period         = 14;           // دوره ATR برای اعتبارسنجی - دوره استاندارد ۱۴، برای محاسبه میانگین نوسان.
input double                 InRangeATR_MinMultiplier  = 0.2;          // ضریب حداقل ATR برای اعتبارسنجی - اندازه رنج حداقل این ضریب ATR باشد، برای فیلتر رنج‌های کوچک نسبت به نوسان.
input double                 InRangeATR_MaxMultiplier  = 1.2;          // ضریب حداکثر ATR برای اعتبارسنجی - اندازه رنج حداکثر این ضریب ATR باشد، برای فیلتر رنج‌های بزرگ.

// --- پارامترهای فیلتر روند (مشترک برای همه جلسات) ---
// فیلتر روند برای تعیین جهت معامله بر اساس EMA. این بخش آموزشی برای اضافه کردن فیلتر روند به استراتژی است.
input group "====== Trend Filter ======"; // گروه ورودی برای فیلتر روند.
input bool               InpTrendFilterIsOn    = true;         // آیا فیلتر روند فعال باشد؟ - اگر true، فقط در جهت روند معامله می‌کند، برای کاهش معاملات خلاف روند.
input ENUM_TIMEFRAMES    InpTrendEMATimeFrame  = PERIOD_H4;    // تایم فریم محاسبه EMA - مثلاً H4 برای ۴ ساعته، تایم فریم بالاتر برای روندهای بلندمدت.
input int                InpTrendEMAPeriod     = 150;          // دوره EMA - دوره طولانی برای روندهای بلندمدت، مثلاً ۱۵۰ برای EMA آهسته.
input ENUM_APPLIED_PRICE InpTrendEMAAppliedPrice = PRICE_CLOSE;  // قیمت اعمالی EMA - معمولاً CLOSE برای قیمت بسته شدن کندل.

// --- پارامترهای مدیریت معامله و ریسک (مشترک) ---
// این بخش برای مدیریت سفارشات، استاپ لاس، تیک پروفیت و ترلینگ. این پارامترها پایه مدیریت معامله را تشکیل می‌دهند.
// توجه: InpFixedTakeProfitRatio حذف شده و از InpTakeProfitRatio_Stage1 برای حالت ثابت استفاده می‌شود تا ساده‌سازی شود.
// InpOrderBufferPoints حذف شده و از ATR دینامیک استفاده می‌شود.
input group "====== Trade & Risk Management ======"; // گروه ورودی برای مدیریت معامله و ریسک.
input double InpStopLossAdditionalPercent   = 10.0;         // درصد اضافه به اندازه رنج برای SL اولیه - مثلاً ۱۰% بیشتر از اندازه رنج برای فضای بیشتر.
//--- خروج پله ای
input bool   InpEnablePartialClose          = true;         // آیا خروج پله‌ای فعال باشد؟ - اگر false، از تارگت ثابت استفاده می‌شود، برای استراتژی‌های ساده‌تر.
input double InpTakeProfitRatio_Stage1      = 1.5;          // نسبت سود به ضرر برای بستن بخش اول یا TP ثابت - مثلاً ۱.۵ برابر فاصله SL، برای خروج اولیه یا ثابت.
input double InpPartialClosePercentage      = 50.0;         // درصد حجمی که در مرحله اول بسته می‌شود - مثلاً ۵۰% برای تقسیم معامله.
//--- حد ضرر متحرک
input ENUM_TIMEFRAMES InpTrailingStopATRTimeFrame = PERIOD_D1;    // تایم فریم ATR برای حد ضرر متحرک - مثلاً D1 برای نوسان روزانه.
input int             InpTrailingStopATRPeriod      = 22;           // دوره ATR برای حد ضرر متحرک - دوره متفاوت برای ترلینگ، مثلاً ۲۲ برای حساسیت کمتر.
input double          InpTrailingStopATRMultiplier  = 3.0;          // ضریب ATR برای فاصله حد ضرر متحرک - مثلاً ۳ برابر ATR برای فضای کافی.

//--- گروه: تنظیمات بهینه‌سازی سفارشی ---
input group "  تنظیمات بهینه‌سازی سفارشی"; // گروه بهینه‌سازی
input int InpMinTradesPerYear = 30; // حداقل تعداد معاملات قابل قبول در یک سال
input int InpMaxAcceptableDrawdown = 15; // حداکثر دراوداون قابل قبول

#endif //SETTINGS_MQH








//+------------------------------------------------------------------+
//|                                                   hipobreck.mq5   |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy        |
//|                          >> FINAL REVISED VERSION 3.0 <<          |
//+------------------------------------------------------------------+
// توضیح: فایل اصلی اکسپرت برای سیستم معاملاتی. مدیریت چندین جلسه معاملاتی،
//        رویدادهای تیک، تراکنش‌های معاملاتی و بهینه‌سازی سفارشی را انجام می‌دهد.

#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy"
#property link      "https://..."
#property version   "3.00"
#property strict // فعال‌سازی بررسی سخت‌گیرانه برای جلوگیری از خطاها.

#include "Settings.mqh"
#include "SessionTrader.mqh"
#include <Trade\Trade.mqh> // کتابخانه استاندارد برای عملیات معاملاتی.

//+------------------------------------------------------------------+
//| متغیرهای سراسری                                                |
//+------------------------------------------------------------------+
// توضیح: آرایه‌ای از اشیاء CSessionTrader برای مدیریت چهار جلسه معاملاتی مستقل.
CSessionTrader g_sessions[4];

//+------------------------------------------------------------------+
//| تابع اولیه‌سازی اکسپرت                                          |
//+------------------------------------------------------------------+
// هدف: راه‌اندازی اکسپرت، تنظیم جلسه‌های معاملاتی و تایمر برای به‌روزرسانی‌های دوره‌ای.
int OnInit()
  {
   // مقداردهی اولیه هر جلسه با پارامترهای تعریف‌شده توسط کاربر.
   g_sessions[0].Init(InpS1_IsActive, InpS1_TimeFrame, InpS1_StartTime_Hour, InpS1_StartTime_Minute,
                     InpS1_EndTime_Hour, InpS1_EndTime_Minute, InpS1_ExpiryTime_Hour, InpS1_ExpiryTime_Minute, S1_MagicNumber);
   g_sessions[1].Init(InpS2_IsActive, InpS2_TimeFrame, InpS2_StartTime_Hour, InpS2_StartTime_Minute,
                     InpS2_EndTime_Hour, InpS2_EndTime_Minute, InpS2_ExpiryTime_Hour, InpS2_ExpiryTime_Minute, S2_MagicNumber);
   g_sessions[2].Init(InpS3_IsActive, InpS3_TimeFrame, InpS3_StartTime_Hour, InpS3_StartTime_Minute,
                     InpS3_EndTime_Hour, InpS3_EndTime_Minute, InpS3_ExpiryTime_Hour, InpS3_ExpiryTime_Minute, S3_MagicNumber);
   g_sessions[3].Init(InpS4_IsActive, InpS4_TimeFrame, InpS4_StartTime_Hour, InpS4_StartTime_Minute,
                     InpS4_EndTime_Hour, InpS4_EndTime_Minute, InpS4_ExpiryTime_Hour, InpS4_ExpiryTime_Minute, S4_MagicNumber);

   EventSetTimer(60); // تنظیم تایمر برای به‌روزرسانی هر 60 ثانیه، کاهش بار OnTick.

   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| تابع خاتمه اکسپرت                                              |
//+------------------------------------------------------------------+
// هدف: آزادسازی منابع هنگام حذف اکسپرت.
void OnDeinit(const int reason)
  {
   EventKillTimer(); // متوقف کردن تایمر.

   for(int i = 0; i < 4; i++) g_sessions[i].Deinit(); // خاتمه هر جلسه.
  }

//+------------------------------------------------------------------+
//| تابع تایمر                                                     |
//+------------------------------------------------------------------+
// هدف: هر 60 ثانیه فراخوانی می‌شود برای به‌روزرسانی تحلیل و پاکسازی جلسات.
void OnTimer()
  {
   for(int i = 0; i < 4; i++) g_sessions[i].OnTimerUpdate(); // به‌روزرسانی هر جلسه.
  }

//+------------------------------------------------------------------+
//| تابع تیک                                                       |
//+------------------------------------------------------------------+
// هدف: مدیریت تیک‌های جدید برای به‌روزرسانی پوزیشن‌های فعال (خروج پله‌ای و حد ضرر متحرک).
void OnTick()
  {
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      ulong ticket = PositionGetTicket(i); // دریافت تیکت پوزیشن به‌صورت ulong.
      if(ticket > 0 && PositionSelectByTicket(ticket)) // اطمینان از انتخاب پوزیشن.
        {
         long magic = PositionGetInteger(POSITION_MAGIC); // دریافت مجیک نامبر پوزیشن.
         bool managed = false;

         for(int j = 0; j < 4; j++)
           {
            if(g_sessions[j].GetMagicNumber() == magic)
              {
               managed = g_sessions[j].ManageActiveTrade(ticket); // فراخوانی تابع مدیریت پوزیشن با تیکت ulong.
               break;
              }
           }

         if(managed) break; // اگر پوزیشن مدیریت شد، از حلقه خارج شو.
        }
     }
  }

//+------------------------------------------------------------------+
//| تابع تراکنش معاملاتی                                           |
//+------------------------------------------------------------------+
// هدف: مدیریت منطق OCO (یکی دیگری را لغو می‌کند) با حذف سفارش معکوس هنگام باز شدن معامله.
void OnTradeTransaction(const MqlTradeTransaction &trans, const MqlTradeRequest &request, const MqlTradeResult &result)
  {
   if(trans.type == TRADE_TRANSACTION_DEAL_ADD)
     {
      if(HistoryDealSelect(trans.deal))
        {
         if(HistoryDealGetInteger(trans.deal, DEAL_ENTRY) == DEAL_ENTRY_IN)
           {
            long magic = HistoryDealGetInteger(trans.deal, DEAL_MAGIC);
            for(int i = OrdersTotal() - 1; i >= 0; i--)
              {
               ulong order_ticket = OrderGetTicket(i);
               if(order_ticket > 0 && OrderSelect(order_ticket))
                 {
                  if(OrderGetInteger(ORDER_MAGIC) == magic)
                    {
                     trade.OrderDelete(order_ticket); // حذف سفارش معکوس.
                    }
                 }
              }
           }
        }
     }
  }

//+------------------------------------------------------------------+
//| تابع بهینه‌سازی سفارشی (OnTester)                              |
//+------------------------------------------------------------------+
// هدف: محاسبه امتیاز بهینه‌سازی سفارشی بر اساس آمار معاملات و معیارهای پیشرفته.
double OnTester()
  {
   double total_trades = TesterStatistics(STAT_TRADES); // تعداد کل معاملات.
   double net_profit = TesterStatistics(STAT_PROFIT); // سود خالص.
   double profit_factor = TesterStatistics(STAT_PROFIT_FACTOR); // فاکتور سود.
   double sharpe_ratio = TesterStatistics(STAT_SHARPE_RATIO); // نسبت شارپ.
   double max_balance_drawdown_percent = TesterStatistics(STAT_BALANCE_DDREL_PERCENT); // حداکثر دراوداون درصدی.

   // محاسبه حداقل معاملات موردنیاز بر اساس مدت تست.
   datetime startDate = 0, endDate = 0;
   if(HistoryDealsTotal() > 0)
     {
      startDate = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(0), DEAL_TIME);
      endDate = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(HistoryDealsTotal() - 1), DEAL_TIME);
     }
   double duration_days = (endDate > startDate) ? double(endDate - startDate) / (24.0 * 3600.0) : 1.0;
   double required_min_trades = MathFloor((duration_days / 365.0) * InpMinTradesPerYear);
   if(required_min_trades < 10) required_min_trades = 10;

   // اگر معیارهای اولیه برآورده نشوند، امتیاز صفر.
   if(total_trades < required_min_trades || profit_factor < 1.1 || sharpe_ratio <= 0 || net_profit <= 0) return 0.0;

   // محاسبه معیارهای پیشرفته (R-squared و پایداری نزولی).
   double r_squared = 0, downside_consistency = 0;
   CalculateAdvancedMetrics(r_squared, downside_consistency);

   // محاسبه جریمه دراوداون با استفاده از منحنی کسینوسی.
   double drawdown_penalty_factor = 0.0;
   if(max_balance_drawdown_percent < InpMaxAcceptableDrawdown && InpMaxAcceptableDrawdown > 0)
     {
      double angle = (max_balance_drawdown_percent / InpMaxAcceptableDrawdown) * (M_PI / 2.0);
      drawdown_penalty_factor = MathCos(angle);
     }

   // محاسبه امتیاز نهایی.
   double final_score = 0.0;
   if(drawdown_penalty_factor > 0)
     {
      double trades_factor = MathLog(total_trades + 1);
      double net_profit_factor = MathLog(net_profit + 1);
      final_score = (profit_factor * sharpe_ratio * r_squared * downside_consistency * trades_factor * net_profit_factor) * drawdown_penalty_factor;
     }

   // لاگ نتایج برای دیباگ.
   PrintFormat("نتیجه: معاملات=%d, فاکتور سود=%.2f, شارپ=%.2f, R²=%.3f, دراوداون=%.2f%%, جریمه=%.2f -> امتیاز: %.4f",
               (int)total_trades, profit_factor, sharpe_ratio, r_squared, max_balance_drawdown_percent, drawdown_penalty_factor, final_score);

   return final_score;
  }

//+------------------------------------------------------------------+
//| تابع محاسبه معیارهای پیشرفته                                    |
//+------------------------------------------------------------------+
// هدف: محاسبه R-squared و پایداری نزولی برای امتیازدهی بهینه‌سازی.
void CalculateAdvancedMetrics(double &r_squared, double &downside_consistency)
  {
   r_squared = 0;
   downside_consistency = 1.0;

   if(!HistorySelect(0, TimeCurrent())) return; // انتخاب کل تاریخچه.
   uint total_deals = HistoryDealsTotal();
   if(total_deals < 5) return; // حداقل 5 معامله برای معیارهای معنی‌دار.

   struct EquityPoint { datetime time; double balance; }; // ساختار برای نقاط منحنی بالانس.
   EquityPoint equity_curve[];
   ArrayResize(equity_curve, (int)total_deals + 2);

   double final_balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double net_profit = TesterStatistics(STAT_PROFIT);
   double initial_balance = final_balance - net_profit;

   double current_balance = initial_balance;
   equity_curve[0].time = (datetime)HistoryDealGetInteger(HistoryDealGetTicket(0), DEAL_TIME) - 1;
   equity_curve[0].balance = current_balance;

   int equity_points = 1;
   for(uint i = 0; i < total_deals; i++)
     {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0)
        {
         if(HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
           {
            current_balance += HistoryDealGetDouble(ticket, DEAL_PROFIT) +
                              HistoryDealGetDouble(ticket, DEAL_COMMISSION) +
                              HistoryDealGetDouble(ticket, DEAL_SWAP);
            equity_curve[equity_points].time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
            equity_curve[equity_points].balance = current_balance;
            equity_points++;
           }
        }
     }
   ArrayResize(equity_curve, equity_points);
   if(equity_points < 3) return;

   // محاسبه R-squared.
   double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0, sum_y2 = 0;
   for(int i = 0; i < equity_points; i++)
     {
      double x = i + 1.0;
      double y = equity_curve[i].balance;
      sum_x += x;
      sum_y += y;
      sum_xy += x * y;
      sum_x2 += x * x;
      sum_y2 += y * y;
     }
   double n = equity_points;
   double den_part1 = (n * sum_x2) - (sum_x * sum_x);
   double den_part2 = (n * sum_y2) - (sum_y * sum_y);
   if(den_part1 > 0 && den_part2 > 0)
     {
      double r = ((n * sum_xy) - (sum_x * sum_y)) / MathSqrt(den_part1 * den_part2);
      r_squared = r * r;
     }

   // محاسبه پایداری نزولی.
   struct MonthlyTrades { int year; int month; int count; };
   MonthlyTrades monthly_counts[];
   int total_months = 0;

   for(uint i = 0; i < total_deals; i++)
     {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
        {
         datetime deal_time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
         MqlDateTime dt;
         TimeToStruct(deal_time, dt);

         int month_idx = -1;
         for(int j = 0; j < total_months; j++)
           {
            if(monthly_counts[j].year == dt.year && monthly_counts[j].month == dt.mon)
              {
               month_idx = j;
               break;
              }
           }

         if(month_idx == -1)
           {
            ArrayResize(monthly_counts, total_months + 1);
            monthly_counts[total_months].year = dt.year;
            monthly_counts[total_months].month = dt.mon;
            monthly_counts[total_months].count = 1;
            total_months++;
           }
         else
           {
            monthly_counts[month_idx].count++;
           }
        }
     }

   if(total_months <= 1)
     {
      downside_consistency = 1.0;
      return;
     }

   double target_trades_per_month = InpMinTradesPerYear / 12.0;
   if(target_trades_per_month < 1) target_trades_per_month = 1;

   double sum_of_squared_downside_dev = 0;
   for(int i = 0; i < total_months; i++)
     {
      if(monthly_counts[i].count < target_trades_per_month)
        {
         double deviation = target_trades_per_month - monthly_counts[i].count;
         sum_of_squared_downside_dev += deviation * deviation;
        }
     }

   double downside_variance = sum_of_squared_downside_dev / total_months;
   double downside_deviation = MathSqrt(downside_variance);
   downside_consistency = 1.0 / (1.0 + downside_deviation);
  }












//+------------------------------------------------------------------+
//|                                                 TradeManager.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل.
#property link      "https://..." // لینک مرتبط با پروژه.

//--- گارد برای جلوگیری از include شدن چندباره.
#ifndef TRADEMANAGER_MQH // چک گارد.
#define TRADEMANAGER_MQH // تعریف گارد.

#include "Settings.mqh"     // کتابخانه تنظیمات ورودی کاربر.
#include "RangeLib.mqh"     // کتابخانه تحلیل و اعتبارسنجی محدوده (شامل struct RangeData).
#include <Trade\Trade.mqh>  // کتابخانه استاندارد MQL5 برای معاملات.
CTrade trade;               // نمونه سراسری CTrade برای عملیات معاملاتی.

//+------------------------------------------------------------------+
//| Function to Calculate Lot Size                                   |
//+------------------------------------------------------------------+
//--- این تابع حجم معامله را بر اساس درصد ریسک و فاصله استاپ لاس محاسبه می‌کند.
double CalculateLotSize(double risk_percent,double stop_loss_pips)
  {
   //--- شرط ایمنی: اگر فاصله استاپ صفر یا منفی، حجم صفر.
   if(stop_loss_pips <= 0) return 0.0;

   //--- گرفتن اکویتی حساب (شامل سود/زیان باز).
   double account_equity = AccountInfoDouble(ACCOUNT_EQUITY);
   //--- محاسبه مبلغ ریسک مجاز.
   double risk_amount = account_equity * (risk_percent / 100.0);

   //--- گرفتن ارزش تیک و اندازه تیک نماد.
   double tick_value = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
   double tick_size = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);

   //--- شرط ایمنی: اگر اطلاعات نامعتبر، حجم صفر.
   if(tick_value <= 0 || tick_size <= 0) return 0.0;

   //--- محاسبه ارزش هر پیپ.
   double value_per_pip = tick_value / tick_size * _Point;
   if(value_per_pip <= 0) return 0.0;

   //--- محاسبه حجم خام.
   double lot_size = risk_amount / (stop_loss_pips * value_per_pip);

   //--- گرفتن قوانین بروکر برای حجم.
   double min_lot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   double max_lot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX);
   double lot_step = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);

   //--- گرد کردن حجم به گام مجاز.
   lot_size = MathRound(lot_size / lot_step) * lot_step;
   //--- محدود کردن بین min و max.
   lot_size = MathMax(min_lot,MathMin(max_lot,lot_size));

   return lot_size; // بازگشت حجم نهایی.
  }

//+------------------------------------------------------------------+
//| Function to Place Pending Orders                                 |
//+------------------------------------------------------------------+
//--- این تابع سفارشات پندینگ را بر اساس قیمت‌های محاسبه شده ثبت می‌کند.
void PlacePendingOrders(int session_magic_base,bool is_trend_on,bool is_uptrend,RangeData &rd,double buy_stop_price,double sell_stop_price)
  {
   //--- محاسبه فاصله اضافی برای استاپ لاس.
   double sl_additional_pips = rd.rangeSizePips * (InpStopLossAdditionalPercent / 100.0);
   //--- محاسبه فاصله کل استاپ لاس به پیپ.
   double sl_distance_pips = rd.rangeSizePips + sl_additional_pips;

   //--- محاسبه حجم معامله.
   double lot_size = CalculateLotSize(InpRiskPercentage,sl_distance_pips);
   if(lot_size <= 0) return; // اگر حجم نامعتبر، خارج شو.

   //--- محاسبه استاپ لاس برای خرید و فروش.
   double buy_sl = rd.rangeLow - sl_additional_pips * _Point;
   double sell_sl = rd.rangeHigh + sl_additional_pips * _Point;

   double buy_tp = 0.0; // پیش‌فرض بدون تی‌پی (برای پله‌ای).
   double sell_tp = 0.0;

   //--- اگر پله‌ای خاموش باشد، تی‌پی ثابت محاسبه کن.
   if(!InpEnablePartialClose)
     {
      buy_tp = buy_stop_price + (buy_stop_price - buy_sl) * InpTakeProfitRatio_Stage1;
      sell_tp = sell_stop_price - (sell_sl - sell_stop_price) * InpTakeProfitRatio_Stage1;
     }

   //--- اگر فیلتر روند خاموش، هر دو سفارش را ثبت کن.
   if(!is_trend_on)
     {
      trade.BuyStop(lot_size,buy_stop_price,_Symbol,buy_sl,buy_tp,0,0,IntegerToString(session_magic_base)); // ثبت BuyStop.
      trade.SellStop(lot_size,sell_stop_price,_Symbol,sell_sl,sell_tp,0,0,IntegerToString(session_magic_base)); // ثبت SellStop.
     }
   else // اگر روند فعال، فقط در جهت روند ثبت کن.
     {
      if(is_uptrend) trade.BuyStop(lot_size,buy_stop_price,_Symbol,buy_sl,buy_tp,0,0,IntegerToString(session_magic_base)); // فقط خرید اگر صعودی.
      else trade.SellStop(lot_size,sell_stop_price,_Symbol,sell_sl,sell_tp,0,0,IntegerToString(session_magic_base)); // فقط فروش اگر نزولی.
     }
  }

//+------------------------------------------------------------------+
//| Function for Session CleanUp                                     |
//+------------------------------------------------------------------+
//--- این تابع تمام پوزیشن‌ها و سفارشات جلسه را در انقضا پاک می‌کند.
void SessionCleanUp(int session_magic_base)
  {
   //--- حلقه روی پوزیشن‌های باز.
   for(int i=PositionsTotal()-1; i>=0; i--)
     {
      ulong pos_ticket = PositionGetTicket(i); // تیکت پوزیشن.
      if(pos_ticket > 0 && PositionSelectByTicket(pos_ticket)) // اگر معتبر و انتخاب شود.
        {
         long magic = PositionGetInteger(POSITION_MAGIC); // مجیک پوزیشن.
         if(magic == session_magic_base) trade.PositionClose(pos_ticket); // اگر مطابقت، ببند.
        }
     }

   //--- حلقه روی سفارشات پندینگ.
   for(int i=OrdersTotal()-1; i>=0; i--)
     {
      ulong ord_ticket = OrderGetTicket(i); // تیکت سفارش.
      if(ord_ticket > 0 && OrderSelect(ord_ticket)) // اگر معتبر و انتخاب شود.
        {
         if(OrderGetInteger(ORDER_MAGIC) == session_magic_base) trade.OrderDelete(ord_ticket); // اگر مطابقت، حذف.
        }
     }
  }

#endif //TRADEMANAGER_MQH












//+------------------------------------------------------------------+
//|                                                    RangeLib.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل.
#property link      "https://..." // لینک مرتبط با پروژه.

//--- این گارد از include شدن چندباره فایل در پروژه جلوگیری می‌کند.
#ifndef RANGELIB_MQH // چک گارد.
#define RANGELIB_MQH // تعریف گارد.

#include "Settings.mqh"     // کتابخانه تنظیمات ورودی کاربر.

//+------------------------------------------------------------------+
//| STRUCT for Range Data                                            |
//+------------------------------------------------------------------+
//--- ساختار برای نگهداری داده‌های محدوده. این ساختار مثل یک کلاس ساده عمل می‌کند و تمام داده‌های مرتبط را در یک جا نگه می‌دارد تا کد خواناتر شود.
struct RangeData
  {
   double            rangeHigh;      // بالاترین قیمت شناسایی شده در بازه (High محدوده).
   double            rangeLow;       // پایین‌ترین قیمت شناسایی شده در بازه (Low محدوده).
   bool              isValid;        // پرچم اعتبار محدوده (true اگر پس از اعتبارسنجی معتبر باشد).
   datetime          startTime;      // زمان شروع بازه به فرمت datetime برای ترسیم و محاسبات.
   datetime          endTime;        // زمان پایان بازه به فرمت datetime.
   double            rangeSizePips;  // اندازه محدوده به پیپ (برای محاسبات ریسک و استاپ لاس).
  };

//+------------------------------------------------------------------+
//| Function to Draw Range on Chart                                  |
//+------------------------------------------------------------------+
//--- این تابع برای نمایش بصری محدوده روی چارت استفاده می‌شود تا کاربر بتواند محدوده شناسایی‌شده را به صورت گرافیکی ببیند و استراتژی را ارزیابی کند.
void DrawRangeOnChart(RangeData &rd,int session_magic)
  {
   //--- اگر محدوده نامعتبر باشد، هیچ چیزی ترسیم نکن تا از خطاهای غیرضروری جلوگیری شود.
   if(!rd.isValid) return;

   //--- ساخت پیشوند منحصر به فرد برای اشیاء این جلسه تا با جلسات دیگر تداخل نداشته باشد.
   string obj_prefix = "Range_" + IntegerToString(session_magic) + "_";

   //--- ایجاد مستطیل برای نمایش محدوده زمانی و قیمتی.
   ObjectCreate(0,obj_prefix + "Rect",OBJ_RECTANGLE,0,rd.startTime,rd.rangeHigh,rd.endTime,rd.rangeLow);
   //--- تنظیم رنگ مستطیل برای تمایز بصری.
   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_COLOR,clrDarkSlateGray);
   //--- تنظیم استایل خطوط مستطیل (جامد برای وضوح).
   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_STYLE,STYLE_SOLID);
   //--- پر کردن داخل مستطیل برای نمایش بهتر محدوده.
   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_FILL,true);
   //--- ارسال مستطیل به پس‌زمینه تا مزاحم دیدن کندل‌ها نشود.
   ObjectSetInteger(0,obj_prefix + "Rect",OBJPROP_BACK,true);
  }

//+------------------------------------------------------------------+
//| Helper Function: IsKijunFlat                                     |
//+------------------------------------------------------------------+
//--- این تابع چک می‌کند آیا کیجون‌سن صاف است (شیب نزدیک به صفر با رگرسیون خطی). تایم فریم را به عنوان ورودی می‌گیرد تا مستقل از چارت باشد.
//--- نکته آموزشی: از رگرسیون خطی ساده برای محاسبه شیب استفاده می‌شود. دوره (InpKijunFlatPeriod) اجازه می‌دهد تا حساسیت را تنظیم کنید: دوره کوتاه (مثل ۳) سیگنال‌های بیشتری می‌دهد اما ممکن است نویز داشته باشد؛ دوره بلند (مثل ۲۰) سیگنال‌های باکیفیت‌تری می‌دهد اما کمتر.
bool IsKijunFlat(int ichimoku_handle,int bar_idx,ENUM_TIMEFRAMES timeframe)
  {
   //--- تعریف آرایه دینامیک برای کیجون‌سن بر اساس دوره ورودی.
   double kijun_buffer[]; // آرایه برای مقادیر کیجون.
   ArrayResize(kijun_buffer, InpKijunFlatPeriod); // تغییر اندازه آرایه به دوره مشخص‌شده.
   //--- کپی مقادیر کیجون از هندل (از دوره-۱ کندل قبل تا کندل فعلی).
   if(CopyBuffer(ichimoku_handle,1,bar_idx - InpKijunFlatPeriod + 1,InpKijunFlatPeriod,kijun_buffer) != InpKijunFlatPeriod) return false; // اگر کپی شکست خورد، false برگردان.

   //--- محاسبه شیب رگرسیون خطی ساده برای دوره کندل.
   double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0; // متغیرهای جمع برای فرمول رگرسیون.
   double n = InpKijunFlatPeriod; // تعداد نقاط (دوره).
   for(int k = 0; k < InpKijunFlatPeriod; k++) // حلقه روی دوره برای محاسبه جمع‌ها.
     {
      double x = k + 1.0; // x ایندکس از ۱ تا n.
      double y = kijun_buffer[InpKijunFlatPeriod - 1 - k]; // y مقادیر کیجون از قدیمی به جدید (چون بافر از جدید به قدیمی است).
      sum_x += x; // جمع x.
      sum_y += y; // جمع y.
      sum_xy += x * y; // جمع xy.
      sum_x2 += x * x; // جمع x^2.
     }

   double denominator = (n * sum_x2 - sum_x * sum_x); // دنومیناتور شیب.
   if (denominator == 0) return false; // جلوگیری از تقسیم بر صفر (هرچند بعید است).

   //--- فرمول شیب رگرسیون.
   double slope = (n * sum_xy - sum_x * sum_y) / denominator;

   //--- اگر شیب مطلق کمتر از آستانه (مثل ۰.۰۰۰۱) باشد، صاف در نظر بگیر. این آستانه را می‌توان تنظیم کرد اگر نیاز به حساسیت بیشتر باشد.
   return MathAbs(slope) < 0.0001;
  }

//+------------------------------------------------------------------+
//| Helper Function: IsCandleInKumo                                  |
//+------------------------------------------------------------------+
//--- این تابع چک می‌کند آیا کندل کاملاً درون ابر کومو است. تایم فریم را به عنوان ورودی می‌گیرد تا با تایم فریم جلسه همخوانی داشته باشد.
//--- نکته آموزشی: چک می‌کند آیا High کندل زیر سقف کومو و Low بالای کف کومو باشد، که نشان‌دهنده تعادل بازار است.
bool IsCandleInKumo(int ichimoku_handle,int bar_idx,ENUM_TIMEFRAMES timeframe)
  {
   //--- خواندن سنکو A و B برای کندل مشخص.
   double senkou_a[1], senkou_b[1]; // بافرها برای سنکو A و B.
   if(CopyBuffer(ichimoku_handle,2,bar_idx,1,senkou_a) != 1) return false; // کپی سنکو A، اگر شکست false.
   if(CopyBuffer(ichimoku_handle,3,bar_idx,1,senkou_b) != 1) return false; // کپی سنکو B، اگر شکست false.

   //--- گرفتن High و Low کندل از تایم فریم جلسه.
   double high = iHigh(_Symbol,timeframe,bar_idx); // بالاترین قیمت کندل.
   double low = iLow(_Symbol,timeframe,bar_idx); // پایین‌ترین قیمت کندل.

   //--- تعیین سقف و کف ابر کومو (سقف Max سنکوها، کف Min).
   double kumo_top = MathMax(senkou_a[0],senkou_b[0]); // سقف کومو.
   double kumo_bottom = MathMin(senkou_a[0],senkou_b[0]); // کف کومو.

   //--- چک شرط تعادل: High <= سقف و Low >= کف.
   return (high <= kumo_top && low >= kumo_bottom);
  }

#endif //RANGELIB_MQH









//+------------------------------------------------------------------+
//|                                             SessionTrader.mqh |
//|                   Copyright 2025, Mohammad Khajavi & Jimmy     |
//|                          >> FINAL REVISED VERSION 3.0 <<        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad Khajavi & Jimmy" // تعریف کپی‌رایت فایل.
#property link      "https://..." // لینک مرتبط با پروژه.

//--- این گارد از include شدن چندباره فایل در پروژه جلوگیری می‌کند.
#ifndef SESSIONTRADER_MQH // چک گارد.
#define SESSIONTRADER_MQH // تعریف گارد.

#include "Settings.mqh"     // کتابخانه تنظیمات ورودی کاربر.
#include "RangeLib.mqh"     // کتابخانه توابع کمکی برای تحلیل محدوده.
#include "TradeManager.mqh" // کتابخانه مدیریت معاملات و ریسک.

//+------------------------------------------------------------------+
//| Class CSessionTrader                                             |
//+------------------------------------------------------------------+
//--- این کلاس، منطق کامل یک جلسه معاملاتی را کپسوله می‌کند تا سیستم ماژولار و بدون تداخل باشد. هر نمونه از این کلاس یک جلسه مستقل را مدیریت می‌کند.
class CSessionTrader
  {
private:
   // --- متغیرهای پیکربندی ---
   bool              m_is_active; // وضعیت فعال بودن جلسه (true اگر فعال باشد).
   int               m_magic_number; // مجیک نامبر منحصر به فرد برای شناسایی معاملات این جلسه.
   ENUM_TIMEFRAMES   m_timeframe; // تایم فریم مخصوص این جلسه برای تحلیل محدوده.
   int               m_start_hour, m_start_min; // ساعت و دقیقه شروع بازه تحلیل.
   int               m_end_hour, m_end_min; // ساعت و دقیقه پایان بازه تحلیل.
   int               m_expiry_hour, m_expiry_min; // ساعت و دقیقه انقضای جلسه (برای پاکسازی).

   // --- هندل‌های اندیکاتور ---
   int               m_ichimoku_handle; // هندل اندیکاتور ایچیموکو برای فیلتر تعادل بازار.
   int               m_placement_atr_handle; // هندل ATR برای محاسبه بافر دینامیک سفارشات.
   int               m_range_atr_handle; // هندل ATR برای اعتبارسنجی اندازه محدوده.
   int               m_ema_handle; // هندل EMA برای فیلتر روند.
   int               m_trail_atr_handle; // هندل ATR برای ترلینگ استاپ.

   // --- متغیرهای وضعیت ---
   datetime          m_last_analysis_date; // تاریخ آخرین تحلیل موفق برای جلوگیری از تکرار روزانه.

public:
   //--- سازنده کلاس: تمام متغیرها را با مقادیر پیش‌فرض مقداردهی می‌کند تا از خطاهای زمان اجرا جلوگیری شود.
                     CSessionTrader(void) : m_is_active(false), m_magic_number(0), m_timeframe(PERIOD_M15),
                     m_start_hour(0),m_start_min(0), m_end_hour(0),m_end_min(0), m_expiry_hour(0),m_expiry_min(0),
                     m_ichimoku_handle(INVALID_HANDLE), m_placement_atr_handle(INVALID_HANDLE), m_range_atr_handle(INVALID_HANDLE),
                     m_ema_handle(INVALID_HANDLE), m_trail_atr_handle(INVALID_HANDLE), m_last_analysis_date(0) {} // اولیه‌سازی صریح همه متغیرها برای ایمنی.

   //--- این تابع برای مقداردهی اولیه کلاس با پارامترهای ورودی یک جلسه استفاده می‌شود. هندل‌های اندیکاتورها را ایجاد می‌کند و در صورت خطا لاگ می‌زند.
   void              Init(bool is_active,ENUM_TIMEFRAMES timeframe,int start_h,int start_m,int end_h,int end_m,int expiry_h,int expiry_m,int magic)
     {
      m_is_active = is_active; // تنظیم وضعیت فعال بودن جلسه.
      m_timeframe = timeframe; // تنظیم تایم فریم تحلیل جلسه.
      m_start_hour = start_h; // تنظیم ساعت شروع بازه.
      m_start_min = start_m; // تنظیم دقیقه شروع بازه.
      m_end_hour = end_h; // تنظیم ساعت پایان بازه.
      m_end_min = end_m; // تنظیم دقیقه پایان بازه.
      m_expiry_hour = expiry_h; // تنظیم ساعت انقضا.
      m_expiry_min = expiry_m; // تنظیم دقیقه انقضا.
      m_magic_number = magic; // تنظیم مجیک نامبر منحصر به فرد.

      if(!m_is_active) return; // اگر جلسه غیرفعال است، هندل‌ها را ایجاد نکن تا منابع هدر نرود.

      m_ichimoku_handle = iIchimoku(_Symbol,m_timeframe,InpIchimoku_Tenkan,InpIchimoku_Kijun,InpIchimoku_Senkou); // ایجاد هندل ایچیموکو با پارامترهای ورودی کاربر و تایم فریم جلسه.
      if(m_ichimoku_handle == INVALID_HANDLE) Print("خطا در ایجاد هندل ایچیموکو برای جلسه ",magic); // لاگ خطا اگر ایجاد نشود.

      m_placement_atr_handle = iATR(_Symbol,m_timeframe,InRangeATR_Period); // ایجاد هندل ATR برای بافر قرارگیری سفارشات، با تایم فریم جلسه.
      if(m_placement_atr_handle == INVALID_HANDLE) Print("خطا در ایجاد هندل ATR قرارگیری برای جلسه ",magic); // لاگ خطا.

      m_range_atr_handle = iATR(_Symbol,InRangeATR_TimeFrame,InRangeATR_Period); // ایجاد هندل ATR برای اعتبارسنجی محدوده.
      if(m_range_atr_handle == INVALID_HANDLE) Print("خطا در ایجاد هندل ATR اعتبارسنجی برای جلسه ",magic); // لاگ خطا.

      m_ema_handle = iMA(_Symbol,InpTrendEMATimeFrame,InpTrendEMAPeriod,0,MODE_EMA,InpTrendEMAAppliedPrice); // ایجاد هندل EMA برای فیلتر روند.
      if(m_ema_handle == INVALID_HANDLE) Print("خطا در ایجاد هندل EMA برای جلسه ",magic); // لاگ خطا.

      m_trail_atr_handle = iATR(_Symbol,InpTrailingStopATRTimeFrame,InpTrailingStopATRPeriod); // ایجاد هندل ATR برای ترلینگ استاپ.
      if(m_trail_atr_handle == INVALID_HANDLE) Print("خطا در ایجاد هندل ATR ترلینگ برای جلسه ",magic); // لاگ خطا.
     }

   //--- این تابع برای آزادسازی منابع (هندل‌ها و اشیاء گرافیکی) در زمان حذف اکسپرت استفاده می‌شود تا حافظه آزاد شود.
   void              Deinit(void)
     {
      if(m_ichimoku_handle != INVALID_HANDLE) IndicatorRelease(m_ichimoku_handle); // آزادسازی هندل ایچیموکو اگر معتبر باشد.
      if(m_placement_atr_handle != INVALID_HANDLE) IndicatorRelease(m_placement_atr_handle); // آزادسازی هندل ATR قرارگیری.
      if(m_range_atr_handle != INVALID_HANDLE) IndicatorRelease(m_range_atr_handle); // آزادسازی هندل ATR اعتبارسنجی.
      if(m_ema_handle != INVALID_HANDLE) IndicatorRelease(m_ema_handle); // آزادسازی هندل EMA.
      if(m_trail_atr_handle != INVALID_HANDLE) IndicatorRelease(m_trail_atr_handle); // آزادسازی هندل ATR ترلینگ.
      ObjectsDeleteAll(0,"Range_"+IntegerToString(m_magic_number)+"_"); // حذف تمام اشیاء گرافیکی مربوط به این جلسه با پیشوند خاص.
     }

   //--- این تابع هر ۶۰ ثانیه فراخوانی می‌شود و منطق تحلیل و پاکسازی جلسه را مدیریت می‌کند. این روش بهینه است زیرا بار OnTick را کاهش می‌دهد.
   void              OnTimerUpdate(void)
     {
      if(!m_is_active) return; // اگر جلسه غیرفعال است، از تابع خارج شو تا پردازش بیهوده انجام نشود.

      datetime now = TimeCurrent(); // گرفتن زمان فعلی سرور.
      MqlDateTime now_struct; // ساختار برای شکستن زمان به اجزا.
      TimeToStruct(now,now_struct); // تبدیل زمان به ساختار.

      if(now_struct.hour == m_expiry_hour && now_struct.min == m_expiry_min) // چک اگر زمان انقضا رسیده باشد.
        {
         SessionCleanUp(m_magic_number); // فراخوانی تابع پاکسازی برای بستن پوزیشن‌ها و حذف سفارشات.
         return; // خروج از تابع پس از پاکسازی.
        }

      MqlDateTime end_struct = now_struct; // ساختار برای زمان پایان بازه.
      end_struct.hour = m_end_hour; // تنظیم ساعت پایان.
      end_struct.min = m_end_min; // تنظیم دقیقه پایان - تحلیل دقیقا در دقیقه پایان انجام می‌شود تا کندل کامل شود.
      end_struct.sec = 0; // ثانیه صفر برای دقت.
      datetime analysis_time = StructToTime(end_struct); // تبدیل ساختار به datetime.

      if(now >= analysis_time && !IsSameDay(m_last_analysis_date,now)) // اگر زمان تحلیل رسیده و امروز تحلیل نشده.
        {
         AnalyzeAndPlaceOrders(); // فراخوانی تابع تحلیل و قرارگیری سفارشات.
         m_last_analysis_date = now; // آپدیت تاریخ آخرین تحلیل برای جلوگیری از تکرار.
        }
     }

   //--- این تابع مجیک نامبر جلسه را برمی‌گرداند تا در OnTick برای پیدا کردن نمونه کلاس استفاده شود.
   int               GetMagicNumber(void) { return m_magic_number; } // بازگشت ساده مجیک نامبر.

   //--- این تابع مدیریت معاملات فعال (خروج پله‌ای و ترلینگ استاپ) را انجام می‌دهد. حالا داخل کلاس است تا به هندل ATR دسترسی داشته باشد.
   bool              ManageActiveTrade(ulong ticket)
     {
      if(!PositionSelectByTicket(ticket)) return false; // اگر پوزیشن انتخاب نشود، false برگردان.

      long current_magic = PositionGetInteger(POSITION_MAGIC); // خواندن مجیک پوزیشن.
      if(current_magic != m_magic_number) return false; // اگر مجیک مطابقت ندارد، false.

      if(!InpEnablePartialClose) return false; // اگر خروج پله‌ای خاموش، هیچ کاری نکن.

      double entry_price = PositionGetDouble(POSITION_PRICE_OPEN); // قیمت ورود پوزیشن.
      double current_sl = PositionGetDouble(POSITION_SL); // استاپ لاس فعلی.
      double volume = PositionGetDouble(POSITION_VOLUME); // حجم پوزیشن.
      ENUM_POSITION_TYPE pos_type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE); // نوع پوزیشن (خرید یا فروش).

      bool is_stage1 = (pos_type == POSITION_TYPE_BUY && current_sl < entry_price - _Point * 10) || // چک مرحله ۱ برای خرید (استاپ زیر ورود).
                       (pos_type == POSITION_TYPE_SELL && current_sl > entry_price + _Point * 10); // چک مرحله ۱ برای فروش (استاپ بالای ورود).
      if(is_stage1)
        {
         double sl_distance_price = MathAbs(entry_price - current_sl); // فاصله استاپ از ورود.
         double target_price = (pos_type == POSITION_TYPE_BUY) ? entry_price + sl_distance_price * InpTakeProfitRatio_Stage1 : // هدف برای خرید.
                               entry_price - sl_distance_price * InpTakeProfitRatio_Stage1; // هدف برای فروش.

         double current_price = (pos_type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol,SYMBOL_BID) : // قیمت فعلی برای خرید (Bid).
                                SymbolInfoDouble(_Symbol,SYMBOL_ASK); // قیمت فعلی برای فروش (Ask).

         if((pos_type == POSITION_TYPE_BUY && current_price >= target_price) || // اگر هدف رسیده برای خرید.
            (pos_type == POSITION_TYPE_SELL && current_price <= target_price)) // اگر هدف رسیده برای فروش.
           {
            double lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP); // گام لات بروکر.
            double min_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN); // حداقل لات.
            double volume_to_close_raw = volume * (InpPartialClosePercentage / 100.0); // حجم خام برای بستن.
            double close_volume = MathRound(volume_to_close_raw / lot_step) * lot_step; // گرد به گام.

            if(volume - close_volume < min_lot && volume > min_lot) close_volume = volume; // اگر باقی‌مانده کمتر از min، کل را ببند.

            if(close_volume >= min_lot) // اگر حجم معتبر.
              {
               if(trade.PositionClose(ticket,close_volume)) // بستن پله‌ای.
                 {
                  if(PositionSelectByTicket(ticket)) // اگر هنوز باز است.
                    {
                     trade.PositionModify(ticket,entry_price,0.0); // انتقال استاپ به ورود.
                    }
                  return true; // موفقیت.
                 }
               else
                 {
                  return false; // شکست.
                 }
              }
           }
        }

      bool is_stage2 = (pos_type == POSITION_TYPE_BUY && current_sl >= entry_price - _Point) || // چک مرحله ۲ برای خرید.
                       (pos_type == POSITION_TYPE_SELL && current_sl <= entry_price + _Point); // چک مرحله ۲ برای فروش.
      if(is_stage2)
        {
         double atr_buffer[1]; // بافر برای ATR.
         if(CopyBuffer(m_trail_atr_handle,0,1,1,atr_buffer) !=1) return false; // خواندن ATR، اگر شکست false.
         double trail_offset = atr_buffer[0] * InpTrailingStopATRMultiplier; // افست ترلینگ.

         if(pos_type == POSITION_TYPE_BUY) // برای خرید.
           {
            double new_sl = SymbolInfoDouble(_Symbol,SYMBOL_BID) - trail_offset; // استاپ جدید زیر Bid.
            if(new_sl > current_sl) // اگر بهتر.
              {
               trade.PositionModify(ticket,new_sl,0.0); // اصلاح استاپ.
               return true; // موفقیت.
              }
           }
         else // برای فروش.
           {
            double new_sl = SymbolInfoDouble(_Symbol,SYMBOL_ASK) + trail_offset; // استاپ جدید بالای Ask.
            if(new_sl < current_sl) // اگر بهتر.
              {
               trade.PositionModify(ticket,new_sl,0.0); // اصلاح استاپ.
               return true; // موفقیت.
              }
           }
        }

      return false; // هیچ عملیاتی انجام نشد.
     }

private:
   //--- این تابع محدوده معتبر را شناسایی و اعتبارسنجی می‌کند. اگر ایچیموکو روشن باشد، از فیلتر پیشرفته استفاده می‌کند.
   bool              IdentifyValidRange(RangeData &rd)
     {
      rd.isValid = false; // پیش‌فرض نامعتبر.

      datetime now = TimeCurrent(); // زمان فعلی سرور.
      MqlDateTime now_struct; // ساختار زمان.
      TimeToStruct(now,now_struct); // تبدیل به ساختار.

      MqlDateTime end_dt_struct = now_struct; // ساختار پایان.
      end_dt_struct.hour = m_end_hour; // تنظیم ساعت پایان.
      end_dt_struct.min = m_end_min; // تنظیم دقیقه پایان.
      end_dt_struct.sec = 0; // ثانیه صفر.
      datetime end_time = StructToTime(end_dt_struct); // تبدیل به datetime.

      MqlDateTime start_dt_struct = now_struct; // ساختار شروع.
      start_dt_struct.hour = m_start_hour; // تنظیم ساعت شروع.
      start_dt_struct.min = m_start_min; // تنظیم دقیقه شروع.
      start_dt_struct.sec = 0; // ثانیه صفر.
      datetime start_time = StructToTime(start_dt_struct); // تبدیل به datetime.

      if(m_start_hour > m_end_hour) // مدیریت جلسات شبانه.
        {
         if(now_struct.hour < m_end_hour) start_time -= 86400; // شروع به دیروز.
         else end_time += 86400; // پایان به فردا.
        }
      
      rd.startTime = start_time; // ذخیره شروع.
      rd.endTime = end_time; // ذخیره پایان.

      int start_bar_idx = iBarShift(_Symbol,m_timeframe,start_time,true); // ایندکس شروع (قدیمی‌ترین).
      int end_bar_idx = iBarShift(_Symbol,m_timeframe,end_time,true); // ایندکس پایان (جدیدترین).

      if(start_bar_idx < 0 || end_bar_idx < 0) return false; // اگر ایندکس نامعتبر.

      int bars_to_check = start_bar_idx - end_bar_idx + 1; // تعداد کندل‌ها.
      if(bars_to_check <= 0) return false; // اگر تعداد نامعتبر.

      if(InpUseIchimokuFilter) // اگر ایچیموکو فعال.
        {
         int max_sequence = 0; // حداکثر سکانس.
         int current_sequence = 0; // سکانس فعلی.
         int sequence_start_idx = -1; // شروع سکانس فعلی.
         int best_start_idx = -1; // بهترین شروع.

         for(int i = start_bar_idx; i >= end_bar_idx; i--) // حلقه از قدیمی به جدید.
           {
            if(IsCandleInKumo(m_ichimoku_handle, i, m_timeframe) && IsKijunFlat(m_ichimoku_handle, i, m_timeframe)) // چک شرایط تعادل.
              {
               if(current_sequence == 0) sequence_start_idx = i; // شروع جدید.
               current_sequence++; // افزایش.
              }
            else
              {
               if(current_sequence > max_sequence) // آپدیت اگر بهتر.
                 {
                  max_sequence = current_sequence;
                  best_start_idx = sequence_start_idx;
                 }
               current_sequence = 0; // ریست.
              }
           }
           
           if(current_sequence > max_sequence) // چک نهایی برای سکانس آخر.
             {
              max_sequence = current_sequence;
              best_start_idx = sequence_start_idx;
             }

           if(max_sequence >= InpMinConsecutiveCandles) // اگر معتبر.
             {
              int high_bar_idx = iHighest(_Symbol,m_timeframe,MODE_HIGH,max_sequence,best_start_idx); // High.
              int low_bar_idx = iLowest(_Symbol,m_timeframe,MODE_LOW,max_sequence,best_start_idx); // Low.
              
              if(high_bar_idx != -1 && low_bar_idx != -1) // اگر ایندکس معتبر.
                {
                 rd.rangeHigh = iHigh(_Symbol,m_timeframe,high_bar_idx); // High.
                 rd.rangeLow = iLow(_Symbol,m_timeframe,low_bar_idx); // Low.
                 rd.rangeSizePips = (rd.rangeHigh - rd.rangeLow) / _Point; // اندازه.
                 rd.isValid = true; // معتبر.
                }
             }
        }
      else // منطق بدون ایچیموکو.
        {
         int high_bar_idx = iHighest(_Symbol,m_timeframe,MODE_HIGH,bars_to_check,end_bar_idx); // High.
         int low_bar_idx = iLowest(_Symbol,m_timeframe,MODE_LOW,bars_to_check,end_bar_idx); // Low.
         
         if(high_bar_idx != -1 && low_bar_idx != -1) // اگر معتبر.
           {
            rd.rangeHigh = iHigh(_Symbol,m_timeframe,high_bar_idx); // High.
            rd.rangeLow = iLow(_Symbol,m_timeframe,low_bar_idx); // Low.
            rd.rangeSizePips = (rd.rangeHigh - rd.rangeLow) / _Point; // اندازه.

            if(InpRangeFilterMode == MODE_POINTS) // حالت پوینت.
              {
               if(rd.rangeSizePips >= InpMinRangePoints && rd.rangeSizePips <= InpMaxRangePoints) rd.isValid = true; // چک اندازه.
              }
            else // حالت ATR.
              {
               double atr_buffer[1];
               if(CopyBuffer(m_range_atr_handle,0,1,1,atr_buffer) == 1) // خواندن ATR.
                 {
                  double atr_value = atr_buffer[0];
                  if(atr_value > 0) // اگر مثبت.
                    {
                     double min_allowed = (atr_value * InRangeATR_MinMultiplier) / _Point; // حداقل.
                     double max_allowed = (atr_value * InRangeATR_MaxMultiplier) / _Point; // حداکثر.
                     if(rd.rangeSizePips >= min_allowed && rd.rangeSizePips <= max_allowed) rd.isValid = true; // چک.
                    }
                 }
              }
           }
        }
      return rd.isValid; // بازگشت وضعیت اعتبار.
     }

   //--- این تابع تحلیل محدوده را انجام داده و در صورت معتبر بودن، سفارشات را قرار می‌دهد.
   void              AnalyzeAndPlaceOrders(void)
     {
      RangeData rd; // ساختار محدوده.
      if(!IdentifyValidRange(rd)) return; // اگر نامعتبر، خارج.

      DrawRangeOnChart(rd,m_magic_number); // ترسیم محدوده.

      bool is_trend_on = InpTrendFilterIsOn; // وضعیت روند.
      bool is_uptrend = false; // جهت روند.

      if(is_trend_on) // اگر فعال.
        {
         double ema_buffer[1];
         if(CopyBuffer(m_ema_handle,0,1,1,ema_buffer) == 1) // خواندن EMA.
           {
            double current_price = SymbolInfoDouble(_Symbol,SYMBOL_BID); // قیمت.
            is_uptrend = current_price > ema_buffer[0]; // چک جهت.
           }
        }

      double atr_buffer[1];
      if(CopyBuffer(m_placement_atr_handle,0,1,1,atr_buffer) != 1) return; // خواندن ATR.
      double atr_value = atr_buffer[0]; // مقدار.
      double buffer = atr_value * InpAtrMultiplier_Placement; // بافر.

      double buy_stop_price = rd.rangeHigh + buffer; // قیمت خرید.
      double sell_stop_price = rd.rangeLow - buffer; // قیمت فروش.

      double current_bid = SymbolInfoDouble(_Symbol,SYMBOL_BID); // Bid.
      double current_ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK); // Ask.
      if((is_trend_on && is_uptrend && current_ask >= buy_stop_price) ||  // Safety check برای خرید.
         (is_trend_on && !is_uptrend && current_bid <= sell_stop_price) || // برای فروش.
         (!is_trend_on && (current_ask >= buy_stop_price || current_bid <= sell_stop_price))) // بدون روند.
         {
            return; // اگر عبور کرده، سفارش نگذار.
         }

      PlacePendingOrders(m_magic_number,is_trend_on,is_uptrend,rd,buy_stop_price,sell_stop_price); // قرارگیری سفارشات.
     }

   //--- این تابع چک می‌کند آیا دو تاریخ در یک روز هستند. برای جلوگیری از تحلیل تکراری روزانه استفاده می‌شود.
   bool              IsSameDay(datetime d1,datetime d2)
     {
      MqlDateTime s1,s2; // ساختارها برای شکستن زمان.
      TimeToStruct(d1,s1); // تبدیل d1 به ساختار (سال، ماه، روز و غیره).
      TimeToStruct(d2,s2); // تبدیل d2 به ساختار.
      return (s1.year == s2.year && s1.mon == s2.mon && s1.day == s2.day); // مقایسه سال، ماه و روز برای تعیین یکسان بودن روز.
     }
  };

#endif //SESSIONTRADER_MQH
//end
