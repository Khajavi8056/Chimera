//+------------------------------------------------------------------+
//|                            Elemento.mq5                          |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این فایل اصلی اکسپرت Elemento است که نقش "رهبر ارکستر" را ایفا می‌کند. این اکسپرت بر اساس استراتژی شکست رنج‌های زمانی (Time-Range Breakout) کار می‌کند و می‌تواند تا ۴ رنج زمانی مستقل را مدیریت کند. هر رنج یک بازه زمانی مشخص دارد (مانند ۲۳:۰۰ تا ۴:۰۰) که در آن سقف و کف قیمت را شناسایی می‌کند، سفارش‌های پندینگ قرار می‌دهد، معاملات را مدیریت می‌کند (با خروج پله‌ای و تریلینگ استاپ)، و در پایان زمان یا تعطیلات پاکسازی می‌کند.
// وظایف اصلی:
// 1. مقداردهی اولیه ۴ رنج با کلاس CRange (فقط رنج‌های فعال با InpRangeX_Enabled = true).
// 2. در OnTick، تشخیص کندل جدید در تایم‌فریم هر رنج و فراخوانی UpdateOnNewBar.
// 3. در OnTradeTransaction، مدیریت OCO (لغو سفارش مخالف وقتی معامله باز می‌شود).
// 4. مدیریت بهینه منابع: هندل‌های ATR shared، کش SymbolInfo، آزادسازی در OnDeinit.
// 5. چک tester mode برای جلوگیری از مشکل تعطیلات در بک‌تست.
// الگوریتم کلی:
// - OnInit: کش اطلاعات سیمبل، ولیدیشن ورودی‌ها، ایجاد هندل ATR، مقداردهی رنج‌های فعال.
// - OnTick: برای هر رنج فعال، چک کندل جدید با iTime و آپدیت اگر جدید باشد.
// - OnTradeTransaction: اگر معامله جدید (DEAL_ENTRY_IN)، سفارش مخالف لغو شود.
// - OnDeinit: آزادسازی هندل‌ها و پاکسازی گرافیک‌ها.
// بهینه‌سازی‌ها: لاگ conditional با InpDebugMode، کش ATR در CRange، normalize دقیق حجم/قیمت.
// اصلاحات: اضافه enabled برای رنج‌ها، چک tester برای IsMarketClosed، لاگ بدون تکرار.
// تغییرات نسخه 1.50: ولیدیشن و پاس دادن تنظیمات ایچیموکو به CRange.Init.
// این کامنت بخشی از سند کلی است: با کامنت‌های دیگر فایل‌ها، معماری کامل (ساختار فایل‌ها، کلاس‌ها، توابع مدیریت معاملات، ریسک، زمان) را توصیف می‌کند. پروژه ماژولار است برای نگهداری آسان.

#property copyright "Copyright 2025, Hipoalgorithm Team"
#property link      "https://hipoalgorithm.com"
#property version   "1.50"
#property strict

// شامل کردن کتابخانه‌ها
#include "Settings.mqh"
#include "CRange.mqh"

// آرایه برای ذخیره ۴ رنج
CRange g_ranges[4];

// آرایه برای ذخیره زمان آخرین کندل هر تایم‌فریم
datetime g_lastBarTime[4];

// آرایه برای هندل‌های ATR shared (برای جلوگیری از تکرار)
int g_atrHandles[4];

// متغیرهای کش‌شده برای بهینه‌سازی
double g_tickValue;
double g_tickSize;
double g_volumeStep;
double g_volumeMin;
double g_volumeMax;

// فلگ برای تشخیص حالت tester (برای skip چک تعطیلات در بک‌تست)
bool g_isTester = false;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   // تشخیص حالت tester برای مدیریت تعطیلات
   g_isTester = MQLInfoInteger(MQL_TESTER);

   // لاگ‌گذاری شروع مقداردهی (اگر دیباگ فعال باشد)
   if(InpDebugMode) Print("شروع مقداردهی اکسپرت Elemento...");

   // کش اطلاعات سیمبل برای بهینه‌سازی
   g_tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   g_tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   g_volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   g_volumeMin = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   g_volumeMax = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

   if(g_tickValue == 0 || g_tickSize == 0 || g_volumeStep == 0)
   {
      Print("خطا در گرفتن اطلاعات سیمبل.");
      return(INIT_FAILED);
   }

   // ولیدیشن ورودی‌های عمومی
   if(InpRiskPercent <= 0 || InpRiskPercent > 5.0)
   {
      Print("خطا: RiskPercent باید بین 0.1 تا 5.0 باشد.");
      return(INIT_PARAMETERS_INCORRECT);
   }

   // ولیدیشن تنظیمات ایچیموکو
   if(InpIchimoku_Enabled)
   {
      if(InpIchimoku_Tenkan_Period <= 0 || InpIchimoku_Kijun_Period <= 0 || InpIchimoku_Senkou_Period <= 0 || InpIchimoku_Shift <= 0)
      {
         Print("خطا: دوره‌های ایچیموکو باید بزرگتر از صفر باشند.");
         return(INIT_PARAMETERS_INCORRECT);
      }
      if(InpIchimoku_Tenkan_Period >= InpIchimoku_Kijun_Period || InpIchimoku_Kijun_Period >= InpIchimoku_Senkou_Period)
      {
         Print("خطا: ترتیب دوره‌های ایچیموکو باید Tenkan < Kijun < Senkou باشد.");
         return(INIT_PARAMETERS_INCORRECT);
      }
   }

   // مقداردهی ۴ رنج با تنظیمات مربوطه (فقط اگر فعال باشند)
   for(int i = 0; i < 4; i++)
   {
      // چک فعال بودن رنج
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;
      if(!enabled)
      {
         if(InpDebugMode) Print("رنج ", i + 1, " غیرفعال است. رد می‌شود.");
         continue;
      }

      // تخصیص مجیک نامبر منحصربه‌فرد برای هر رنج
      long magic = InpBaseMagicNumber + i;
      
      // ولیدیشن ساعات (0-23 برای ساعت، 0-59 برای دقیقه)
      int startHour = i == 0 ? InpRange1_Start_Hour : i == 1 ? InpRange2_Start_Hour : i == 2 ? InpRange3_Start_Hour : InpRange4_Start_Hour;
      int startMinute = i == 0 ? InpRange1_Start_Minute : i == 1 ? InpRange2_Start_Minute : i == 2 ? InpRange3_Start_Minute : InpRange4_Start_Minute;
      int endHour = i == 0 ? InpRange1_End_Hour : i == 1 ? InpRange2_End_Hour : i == 2 ? InpRange3_End_Hour : InpRange4_End_Hour;
      int endMinute = i == 0 ? InpRange1_End_Minute : i == 1 ? InpRange2_End_Minute : i == 2 ? InpRange3_End_Minute : InpRange4_End_Minute;
      
      if(startHour < 0 || startHour > 23 || startMinute < 0 || startMinute > 59 ||
         endHour < 0 || endHour > 23 || endMinute < 0 || endMinute > 59)
      {
         Print("خطا: ساعات یا دقیقه‌های رنج ", i + 1, " نامعتبر است.");
         return(INIT_PARAMETERS_INCORRECT);
      }

      // ایجاد هندل ATR shared
      ENUM_TIMEFRAMES timeframe = i == 0 ? InpRange1_Execution_Timeframe : i == 1 ? InpRange2_Execution_Timeframe : i == 2 ? InpRange3_Execution_Timeframe : InpRange4_Execution_Timeframe;
      int atrPeriod = i == 0 ? InpRange1_ATR_Period : i == 1 ? InpRange2_ATR_Period : i == 2 ? InpRange3_ATR_Period : InpRange4_ATR_Period;
      g_atrHandles[i] = iATR(_Symbol, timeframe, atrPeriod);
      if(g_atrHandles[i] == INVALID_HANDLE)
      {
         Print("خطا در ایجاد هندل ATR برای رنج ", i + 1);
         return(INIT_FAILED);
      }

      // بررسی عدم تکرار مجیک نامبر (با +i، منحصربه‌فرد است)
      if(!g_ranges[i].Init(
         i + 1, // شماره رنج (1 تا 4)
         magic,
         timeframe,
         startHour,
         startMinute,
         endHour,
         endMinute,
         i == 0 ? InpRange1_MinRangePoints : i == 1 ? InpRange2_MinRangePoints : i == 2 ? InpRange3_MinRangePoints : InpRange4_MinRangePoints,
         i == 0 ? InpRange1_MaxRangePoints : i == 1 ? InpRange2_MaxRangePoints : i == 2 ? InpRange3_MaxRangePoints : InpRange4_MaxRangePoints,
         i == 0 ? InpRange1_Placement_Mode : i == 1 ? InpRange2_Placement_Mode : i == 2 ? InpRange3_Placement_Mode : InpRange4_Placement_Mode,
         atrPeriod,
         i == 0 ? InpRange1_ATR_Multiplier : i == 1 ? InpRange2_ATR_Multiplier : i == 2 ? InpRange3_ATR_Multiplier : InpRange4_ATR_Multiplier,
         i == 0 ? InpRange1_SL_Mode : i == 1 ? InpRange2_SL_Mode : i == 2 ? InpRange3_SL_Mode : InpRange4_SL_Mode,
         i == 0 ? InpRange1_SL_ATR_Period : i == 1 ? InpRange2_SL_ATR_Period : i == 2 ? InpRange3_SL_ATR_Period : InpRange4_SL_ATR_Period,
         i == 0 ? InpRange1_SL_ATR_Multiplier : i == 1 ? InpRange2_SL_ATR_Multiplier : i == 2 ? InpRange3_SL_ATR_Multiplier : InpRange4_SL_ATR_Multiplier,
         i == 0 ? InpRange1_Trailing_Mode : i == 1 ? InpRange2_Trailing_Mode : i == 2 ? InpRange3_Trailing_Mode : InpRange4_Trailing_Mode,
         i == 0 ? InpRange1_Trailing_ATR_Period : i == 1 ? InpRange2_Trailing_ATR_Period : i == 2 ? InpRange3_Trailing_ATR_Period : InpRange4_Trailing_ATR_Period,
         i == 0 ? InpRange1_Trailing_ATR_Multiplier : i == 1 ? InpRange2_Trailing_ATR_Multiplier : i == 2 ? InpRange3_Trailing_ATR_Multiplier : InpRange4_Trailing_ATR_Multiplier,
         i == 0 ? InpRange1_RR_Ratio : i == 1 ? InpRange2_RR_Ratio : i == 2 ? InpRange3_RR_Ratio : InpRange4_RR_Ratio,
         i == 0 ? InpRange1_PartialClosePercent : i == 1 ? InpRange2_PartialClosePercent : i == 2 ? InpRange3_PartialClosePercent : InpRange4_PartialClosePercent,
         i == 0 ? InpRange1_Cleanup_Hours : i == 1 ? InpRange2_Cleanup_Hours : i == 2 ? InpRange3_Cleanup_Hours : InpRange4_Cleanup_Hours,
         i == 0 ? InpRange1_Color : i == 1 ? InpRange2_Color : i == 2 ? InpRange3_Color : InpRange4_Color,
         g_atrHandles[i], // هندل ATR shared
         InpIchimoku_Enabled, // فعال بودن فیلتر ایچیموکو
         InpIchimoku_Tenkan_Period,
         InpIchimoku_Kijun_Period,
         InpIchimoku_Senkou_Period,
         InpIchimoku_Shift
      ))
      {
         Print("خطا در مقداردهی رنج ", i + 1, ": ", GetLastError());
         return(INIT_PARAMETERS_INCORRECT);
      }
   }

   // مقداردهی اولیه زمان آخرین کندل‌ها
   for(int i = 0; i < 4; i++)
   {
      g_lastBarTime[i] = 0;
   }

   Print("مقداردهی اکسپرت Elemento با موفقیت انجام شد.");
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   // لاگ‌گذاری دفع مقداردهی (اگر دیباگ فعال باشد)
   if(InpDebugMode) Print("دفع مقداردهی اکسپرت Elemento. دلیل: ", reason);

   // آزادسازی منابع هر رنج
   for(int i = 0; i < 4; i++)
   {
      g_ranges[i].Deinit();
   }

   // آزادسازی هندل‌های ATR
   for(int i = 0; i < 4; i++)
   {
      if(g_atrHandles[i] != INVALID_HANDLE)
      {
         IndicatorRelease(g_atrHandles[i]);
      }
   }

   // پاکسازی اشیاء گرافیکی
   ObjectsDeleteAll(0, "Range_");
   Print("تمامی اشیاء گرافیکی پاکسازی شدند.");
}

//+------------------------------------------------------------------+
//| Expert tick function                                              |
//+------------------------------------------------------------------+
void OnTick()
{
   // بررسی کندل جدید برای هر رنج
   for(int i = 0; i < 4; i++)
   {
      // چک فعال بودن رنج
      bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;
      if(!enabled) continue;

      ENUM_TIMEFRAMES timeframe = g_ranges[i].GetTimeframe();
      datetime currentBarTime = iTime(_Symbol, timeframe, 0);
      
      // اگر کندل جدید باشد
      if(currentBarTime > g_lastBarTime[i])
      {
         if(InpDebugMode) Print("کندل جدید برای رنج ", i + 1, " در تایم‌فریم ", EnumToString(timeframe));
         g_ranges[i].UpdateOnNewBar();
         g_lastBarTime[i] = currentBarTime;
      }
   }
}

//+------------------------------------------------------------------+
//| Trade transaction function                                       |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction& trans, const MqlTradeRequest& request, const MqlTradeResult& result)
{
   if(trans.type == TRADE_TRANSACTION_DEAL_ADD && trans.deal == DEAL_ENTRY_IN)
   {
      if(HistoryDealSelect(trans.deal))
      {
         long magic = HistoryDealGetInteger(trans.deal, DEAL_MAGIC);
         for(int i = 0; i < 4; i++)
         {
            bool enabled = i == 0 ? InpRange1_Enabled : i == 1 ? InpRange2_Enabled : i == 2 ? InpRange3_Enabled : InpRange4_Enabled;
           if(enabled && magic == g_ranges[i].GetMagicNumber())
            {
               if(InpDebugMode) Print("معامله جدید برای رنج ", i + 1, " باز شد. لغو سفارش مخالف...");
               // تیکت پوزیشن رو مستقیماً به تابع پاس می‌دیم
               g_ranges[i].CancelOppositeOrder(HistoryDealGetInteger(trans.deal, DEAL_POSITION_ID)); 
               break;

            }
         }
      }
   }
}







//+------------------------------------------------------------------+
//|                            Settings.mqh                          |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این فایل شامل تمام تنظیمات ورودی اکسپرت Elemento است. تنظیمات به‌صورت گروه‌بندی شده برای کاربرپسندی تعریف شده‌اند:
// - General Settings: تنظیمات عمومی مثل مجیک نامبر پایه، درصد ریسک، و حالت دیباگ.
// - Range X Settings: تنظیمات اختصاصی برای هر رنج (۱ تا ۴)، شامل فعال/غیرفعال، زمان شروع و پایان، تایم‌فریم، فیلترهای رنج، تنظیمات ATR، رنگ مستطیل، و غیره.
// - Ichimoku Filter Settings: تنظیمات عمومی فیلتر ایچیموکو (فعال/غیرفعال، دوره‌های تنکان/کیجون/سنکو، شیفت آینده).
// تمام ورودی‌ها به‌صورت enum یا مقادیر محدود برای جلوگیری از خطای کاربر تعریف شده‌اند.
// نسخه ۱.۵۰ تغییرات جدید:
// ۱. اضافه شدن گروه تنظیمات ایچیموکو با ورودی‌های Enabled, Tenkan_Period, Kijun_Period, Senkou_Period, Shift.
// این فایل فقط برای تعریف متغیرهای ورودی است و هیچ منطق اجرایی ندارد.
// کامنت‌های ورودی‌ها فارسی هستند برای وضوح.
// این کامنت بخشی از سند کلی است: توصیف تمام ورودی‌ها و enumها برای پیکربندی اکسپرت.

#ifndef SETTINGS_MQH
#define SETTINGS_MQH

// تعریف enum برای حالت‌های مختلف
enum ENUM_PLACEMENT_MODE
{
   PLACEMENT_ATR,    // استفاده از ATR برای ثبت سفارش
   PLACEMENT_PERCENT // استفاده از درصد ارتفاع رنج برای ثبت سفارش
};

enum ENUM_SL_MODE
{
   SL_ATR,    // استفاده از ATR برای استاپ لاس
   SL_PERCENT // استفاده از درصد ارتفاع رنج برای استاپ لاس
};

enum ENUM_TRAILING_MODE
{
   TRAILING_ATR,   // استفاده از ATR برای تریلینگ استاپ
   TRAILING_SIMPLE // استفاده از فاصله ثابت برای تریلینگ استاپ
};

// تنظیمات عمومی
input group "تنظیمات عمومی"
input long InpBaseMagicNumber = 123456; // مجیک نامبر پایه (برای تخصیص منحصربه‌فرد به رنج‌ها)
input double InpRiskPercent = 1.0; // درصد ریسک (۰.۱ تا ۵.۰ برای محاسبه حجم معامله)
input bool InpDebugMode = true; // حالت دیباگ (فعال برای لاگ‌گذاری بیشتر)

// تنظیمات فیلتر ایچیموکو
input group "تنظیمات فیلتر ایچیموکو"
input bool InpIchimoku_Enabled = false; // فعال کردن فیلتر ایچیموکو
input int InpIchimoku_Tenkan_Period = 9; // دوره تنکان‌سن (پیش‌فرض ۹)
input int InpIchimoku_Kijun_Period = 26; // دوره کیجون‌سن (پیش‌فرض ۲۶)
input int InpIchimoku_Senkou_Period = 52; // دوره سنکو اسپن B (پیش‌فرض ۵۲)
input int InpIchimoku_Shift = 26; // شیفت آینده برای ابر (پیش‌فرض ۲۶)

// تنظیمات رنج ۱
input group "تنظیمات رنج ۱"
input bool InpRange1_Enabled = true; // فعال کردن رنج ۱
input ENUM_TIMEFRAMES InpRange1_Execution_Timeframe = PERIOD_H1; // تایم‌فریم اجرا رنج ۱
input int InpRange1_Start_Hour = 23; // ساعت شروع رنج ۱ (۰-۲۳)
input int InpRange1_Start_Minute = 0; // دقیقه شروع رنج ۱ (۰-۵۹)
input int InpRange1_End_Hour = 4; // ساعت پایان رنج ۱ (۰-۲۳)
input int InpRange1_End_Minute = 0; // دقیقه پایان رنج ۱ (۰-۵۹)
input int InpRange1_MinRangePoints = 50; // حداقل ارتفاع رنج ۱ به پوینت
input int InpRange1_MaxRangePoints = 500; // حداکثر ارتفاع رنج ۱ به پوینت
input ENUM_PLACEMENT_MODE InpRange1_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج ۱
input int InpRange1_ATR_Period = 14; // دوره ATR برای ثبت سفارش رنج ۱
input double InpRange1_ATR_Multiplier = 1.2; // ضریب ATR برای ثبت سفارش رنج ۱
input ENUM_SL_MODE InpRange1_SL_Mode = SL_ATR; // حالت استاپ لاس رنج ۱
input int InpRange1_SL_ATR_Period = 14; // دوره ATR برای استاپ لاس رنج ۱
input double InpRange1_SL_ATR_Multiplier = 1.5; // ضریب ATR برای استاپ لاس رنج ۱
input ENUM_TRAILING_MODE InpRange1_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج ۱
input int InpRange1_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج ۱
input double InpRange1_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج ۱
input double InpRange1_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج ۱
input double InpRange1_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج ۱
input int InpRange1_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج ۱ (۰-۲۴)
input color InpRange1_Color = clrBlue; // رنگ مستطیل رنج ۱

// تنظیمات رنج ۲
input group "تنظیمات رنج ۲"
input bool InpRange2_Enabled = false; // فعال کردن رنج ۲
input ENUM_TIMEFRAMES InpRange2_Execution_Timeframe = PERIOD_H1; // تایم‌فریم اجرا رنج ۲
input int InpRange2_Start_Hour = 23; // ساعت شروع رنج ۲ (۰-۲۳)
input int InpRange2_Start_Minute = 0; // دقیقه شروع رنج ۲ (۰-۵۹)
input int InpRange2_End_Hour = 4; // ساعت پایان رنج ۲ (۰-۲۳)
input int InpRange2_End_Minute = 0; // دقیقه پایان رنج ۲ (۰-۵۹)
input int InpRange2_MinRangePoints = 50; // حداقل ارتفاع رنج ۲ به پوینت
input int InpRange2_MaxRangePoints = 500; // حداکثر ارتفاع رنج ۲ به پوینت
input ENUM_PLACEMENT_MODE InpRange2_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج ۲
input int InpRange2_ATR_Period = 14; // دوره ATR برای ثبت سفارش رنج ۲
input double InpRange2_ATR_Multiplier = 1.2; // ضریب ATR برای ثبت سفارش رنج ۲
input ENUM_SL_MODE InpRange2_SL_Mode = SL_ATR; // حالت استاپ لاس رنج ۲
input int InpRange2_SL_ATR_Period = 14; // دوره ATR برای استاپ لاس رنج ۲
input double InpRange2_SL_ATR_Multiplier = 1.5; // ضریب ATR برای استاپ لاس رنج ۲
input ENUM_TRAILING_MODE InpRange2_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج ۲
input int InpRange2_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج ۲
input double InpRange2_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج ۲
input double InpRange2_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج ۲
input double InpRange2_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج ۲
input int InpRange2_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج ۲ (۰-۲۴)
input color InpRange2_Color = clrRed; // رنگ مستطیل رنج ۲

// تنظیمات رنج ۳
input group "تنظیمات رنج ۳"
input bool InpRange3_Enabled = false; // فعال کردن رنج ۳
input ENUM_TIMEFRAMES InpRange3_Execution_Timeframe = PERIOD_H1; // تایم‌فریم اجرا رنج ۳
input int InpRange3_Start_Hour = 23; // ساعت شروع رنج ۳ (۰-۲۳)
input int InpRange3_Start_Minute = 0; // دقیقه شروع رنج ۳ (۰-۵۹)
input int InpRange3_End_Hour = 4; // ساعت پایان رنج ۳ (۰-۲۳)
input int InpRange3_End_Minute = 0; // دقیقه پایان رنج ۳ (۰-۵۹)
input int InpRange3_MinRangePoints = 50; // حداقل ارتفاع رنج ۳ به پوینت
input int InpRange3_MaxRangePoints = 500; // حداکثر ارتفاع رنج ۳ به پوینت
input ENUM_PLACEMENT_MODE InpRange3_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج ۳
input int InpRange3_ATR_Period = 14; // دوره ATR برای ثبت سفارش رنج ۳
input double InpRange3_ATR_Multiplier = 1.2; // ضریب ATR برای ثبت سفارش رنج ۳
input ENUM_SL_MODE InpRange3_SL_Mode = SL_ATR; // حالت استاپ لاس رنج ۳
input int InpRange3_SL_ATR_Period = 14; // دوره ATR برای استاپ لاس رنج ۳
input double InpRange3_SL_ATR_Multiplier = 1.5; // ضریب ATR برای استاپ لاس رنج ۳
input ENUM_TRAILING_MODE InpRange3_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج ۳
input int InpRange3_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج ۳
input double InpRange3_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج ۳
input double InpRange3_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج ۳
input double InpRange3_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج ۳
input int InpRange3_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج ۳ (۰-۲۴)
input color InpRange3_Color = clrGreen; // رنگ مستطیل رنج ۳

// تنظیمات رنج ۴
input group "تنظیمات رنج ۴"
input bool InpRange4_Enabled = false; // فعال کردن رنج ۴
input ENUM_TIMEFRAMES InpRange4_Execution_Timeframe = PERIOD_H1; // تایم‌فریم اجرا رنج ۴
input int InpRange4_Start_Hour = 23; // ساعت شروع رنج ۴ (۰-۲۳)
input int InpRange4_Start_Minute = 0; // دقیقه شروع رنج ۴ (۰-۵۹)
input int InpRange4_End_Hour = 4; // ساعت پایان رنج ۴ (۰-۲۳)
input int InpRange4_End_Minute = 0; // دقیقه پایان رنج ۴ (۰-۵۹)
input int InpRange4_MinRangePoints = 50; // حداقل ارتفاع رنج ۴ به پوینت
input int InpRange4_MaxRangePoints = 500; // حداکثر ارتفاع رنج ۴ به پوینت
input ENUM_PLACEMENT_MODE InpRange4_Placement_Mode = PLACEMENT_ATR; // حالت ثبت سفارش رنج ۴
input int InpRange4_ATR_Period = 14; // دوره ATR برای ثبت سفارش رنج ۴
input double InpRange4_ATR_Multiplier = 1.2; // ضریب ATR برای ثبت سفارش رنج ۴
input ENUM_SL_MODE InpRange4_SL_Mode = SL_ATR; // حالت استاپ لاس رنج ۴
input int InpRange4_SL_ATR_Period = 14; // دوره ATR برای استاپ لاس رنج ۴
input double InpRange4_SL_ATR_Multiplier = 1.5; // ضریب ATR برای استاپ لاس رنج ۴
input ENUM_TRAILING_MODE InpRange4_Trailing_Mode = TRAILING_ATR; // حالت تریلینگ استاپ رنج ۴
input int InpRange4_Trailing_ATR_Period = 14; // دوره ATR برای تریلینگ رنج ۴
input double InpRange4_Trailing_ATR_Multiplier = 1.0; // ضریب ATR برای تریلینگ رنج ۴
input double InpRange4_RR_Ratio = 1.5; // نسبت R:R برای خروج پله‌ای رنج ۴
input double InpRange4_PartialClosePercent = 50.0; // درصد بستن پله‌ای رنج ۴
input int InpRange4_Cleanup_Hours = 5; // ساعت‌های پاکسازی رنج ۴ (۰-۲۴)
input color InpRange4_Color = clrYellow; // رنگ مستطیل رنج ۴

#endif







//+------------------------------------------------------------------+
//|                            CRange.mqh                            |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این فایل قلب اکسپرت Elemento است و کلاس CRange را تعریف می‌کند که هر نمونه از آن یک رنج زمانی مستقل را مدیریت می‌کند. این کلاس تمام منطق استراتژی شکست رنج (Breakout) را پیاده‌سازی می‌کند: شناسایی رنج، ثبت سفارش‌های پندینگ، مدیریت معاملات باز، و پاکسازی.
// نسخه ۱.۵۰ تغییرات جدید:
// ۱. فیلتر ایچیموکو: تابع CheckIchimokuFilter() جهت ابر (Senkou A/B) را در تایم‌فریم رنج محاسبه می‌کند (BUY/SELL/BOTH). در PlacePendingOrders، فقط سفارش‌های مجاز ثبت می‌شوند. حالت فلت (A==B) مثل فیلتر خاموش عمل می‌کند (هر دو سفارش).
// ۲. استاپ لاس اولیه: برای Buy Stop، از sellStopPrice - slDistance، و برای Sell Stop، از buyStopPrice + slDistance محاسبه می‌شود.
// وظایف اصلی:
// ۱. شناسایی و اعتبارسنجی رنج (سقف/کف با iHighest/iLowest، چک کیفیت با Min/MaxRangePoints، رسم مستطیل).
// ۲. ثبت سفارش‌های پندینگ (Buy Stop و Sell Stop با offset بر اساس ATR/درصد، محاسبه SL جدید، expiration).
// ۳. مدیریت معاملات باز (خروج پله‌ای با RR_Ratio و PartialClosePercent، ریسک‌فری با MoveSLToBreakEven، تریلینگ با TrailingStop).
// ۴. پاکسازی (بستن پوزیشن‌ها/سفارش‌ها، حذف گرافیک، ریست به WAITING).
// الگوریتم کلی:
// - Init: مقداردهی متغیرها (شامل تنظیمات ایچیموکو)، ولیدیشن، تنظیم نام مستطیل.
// - UpdateOnNewBar: بر اساس حالت (enum RANGE_STATE)، اجرای توابع IdentifyAndValidateRange, PlacePendingOrders, ManageActiveTrade, یا Cleanup.
// - CancelOppositeOrder: حذف سفارش مخالف در OCO.
// - GetCachedATR: گرفتن ATR کش‌شده برای بهینه‌سازی.
// بهینه‌سازی‌ها: کش ATR و ایچیموکو، نرمال‌سازی دقیق، لاگ conditional، چک IsMarketClosed.
// اصلاحات: اضافه کردن فیلتر ایچیموکو، تغییر SL اولیه، تابع مجازی GetFilterDirection برای انعطاف آینده.
// این کامنت بخشی از سند کلی است: توصیف منطق استراتژی و ادغام با فایل‌های دیگر.

#ifndef CRANGE_MQH
#define CRANGE_MQH

#include <Trade\Trade.mqh>
#include "TradeManager.mqh"
#include "RiskManager.mqh"
#include "TimeHelper.mqh"

extern double g_volumeStep;
extern double g_volumeMin;
extern double g_volumeMax;
extern bool g_isTester;

// تعریف حالت‌های رنج
enum ENUM_RANGE_STATE
{
   RANGE_WAITING,     // انتظار برای پایان زمان رنج
   RANGE_IDENTIFIED,  // رنج معتبر شناسایی شد
   ORDERS_PLACED,     // سفارش‌های پندینگ قرار گرفتند
   TRADE_ACTIVE,      // معامله باز است و مدیریت می‌شود
   RANGE_EXPIRED      // رنج منقضی شده و باید پاکسازی شود
};

// تعریف جهت فیلتر
enum ENUM_FILTER_DIRECTION
{
   FILTER_BUY,   // فقط خرید مجاز
   FILTER_SELL,  // فقط فروش مجاز
   FILTER_BOTH   // هر دو مجاز
};

class CRange
{
private:
   int m_rangeIndex; // شماره رنج (۱ تا ۴)
   long m_magicNumber;
   ENUM_TIMEFRAMES m_timeframe;
   int m_startHour;
   int m_startMinute;
   int m_endHour;
   int m_endMinute;
   int m_minRangePoints;
   int m_maxRangePoints;
   ENUM_PLACEMENT_MODE m_placementMode;
   int m_atrPeriod;
   double m_atrMultiplier;
   ENUM_SL_MODE m_slMode;
   int m_slAtrPeriod;
   double m_slAtrMultiplier;
   ENUM_TRAILING_MODE m_trailingMode;
   int m_trailingAtrPeriod;
   double m_trailingAtrMultiplier;
   double m_rrRatio;
   double m_partialClosePercent;
   int m_cleanupHours;
   color m_color;
   int m_atrHandle; // هندل ATR shared
   bool m_ichimokuEnabled; // فعال بودن فیلتر ایچیموکو
   int m_tenkanPeriod; // دوره تنکان‌سن
   int m_kijunPeriod; // دوره کیجون‌سن
   int m_senkouPeriod; // دوره سنکو اسپن B
   int m_shift; // شیفت آینده برای ابر
   ENUM_RANGE_STATE m_currentState;
   double m_rangeHigh;
   double m_rangeLow;
   datetime m_startTime;
   datetime m_endTime;
   datetime m_cleanupTime;
   bool m_trailingActivated;
   ulong m_activeTicket;
   double m_cachedATR; // کش ATR
   ENUM_FILTER_DIRECTION m_cachedIchimokuDirection; // کش جهت ایچیموکو
   string m_rangeObjectName; // نام مستطیل گرافیکی

public:
   // مقداردهی اولیه
   bool Init(
      int rangeIndex,
      long magicNumber,
      ENUM_TIMEFRAMES timeframe,
      int startHour,
      int startMinute,
      int endHour,
      int endMinute,
      int minRangePoints,
      int maxRangePoints,
      ENUM_PLACEMENT_MODE placementMode,
      int atrPeriod,
      double atrMultiplier,
      ENUM_SL_MODE slMode,
      int slAtrPeriod,
      double slAtrMultiplier,
      ENUM_TRAILING_MODE trailingMode,
      int trailingAtrPeriod,
      double trailingAtrMultiplier,
      double rrRatio,
      double partialClosePercent,
      int cleanupHours,
      color rangeColor,
      int atrHandle,
      bool ichimokuEnabled,
      int tenkanPeriod,
      int kijunPeriod,
      int senkouPeriod,
      int shift
   )
   {
      if(InpDebugMode) Print("مقداردهی اولیه رنج ", rangeIndex, "...");

      m_rangeIndex = rangeIndex;
      m_magicNumber = magicNumber;
      m_timeframe = timeframe;
      m_startHour = startHour;
      m_startMinute = startMinute;
      m_endHour = endHour;
      m_endMinute = endMinute;
      m_minRangePoints = minRangePoints;
      m_maxRangePoints = maxRangePoints;
      m_placementMode = placementMode;
      m_atrPeriod = atrPeriod;
      m_atrMultiplier = atrMultiplier;
      m_slMode = slMode;
      m_slAtrPeriod = slAtrPeriod;
      m_slAtrMultiplier = slAtrMultiplier;
      m_trailingMode = trailingMode;
      m_trailingAtrPeriod = trailingAtrPeriod;
      m_trailingAtrMultiplier = trailingAtrMultiplier;
      m_rrRatio = rrRatio;
      m_partialClosePercent = partialClosePercent;
      m_cleanupHours = cleanupHours;
      m_color = rangeColor;
      m_atrHandle = atrHandle;
      m_ichimokuEnabled = ichimokuEnabled;
      m_tenkanPeriod = tenkanPeriod;
      m_kijunPeriod = kijunPeriod;
      m_senkouPeriod = senkouPeriod;
      m_shift = shift;
      m_currentState = RANGE_WAITING;
      m_rangeHigh = 0;
      m_rangeLow = 0;
      m_startTime = 0;
      m_endTime = 0;
      m_cleanupTime = 0;
      m_trailingActivated = false;
      m_activeTicket = 0;
      m_cachedATR = 0;
      m_cachedIchimokuDirection = FILTER_BOTH;
      m_rangeObjectName = "Range_" + IntegerToString(rangeIndex);

      // ولیدیشن
      if(m_minRangePoints <= 0 || m_maxRangePoints <= m_minRangePoints || m_atrPeriod <= 0 ||
         m_atrMultiplier <= 0 || m_slAtrPeriod <= 0 || m_slAtrMultiplier <= 0 ||
         m_trailingAtrPeriod <= 0 || m_trailingAtrMultiplier <= 0 ||
         m_rrRatio <= 0 || m_partialClosePercent <= 0 || m_partialClosePercent > 100 ||
         m_cleanupHours < 0)
      {
         Print("خطا در ولیدیشن پارامترهای رنج ", rangeIndex);
         return false;
      }

      if(InpDebugMode) Print("رنج ", rangeIndex, " با موفقیت مقداردهی شد.");
      return true;
   }

   // دفع مقداردهی
   void Deinit()
   {
      if(InpDebugMode) Print("دفع مقداردهی رنج ", m_rangeIndex, "...");
      Cleanup();
   }

   // گرفتن تایم‌فریم
   ENUM_TIMEFRAMES GetTimeframe()
   {
      return m_timeframe;
   }

   // گرفتن مجیک نامبر
   long GetMagicNumber()
   {
      return m_magicNumber;
   }

   // آپدیت در کندل جدید
   void UpdateOnNewBar()
   {
      if(InpDebugMode) Print("آپدیت رنج ", m_rangeIndex, " در کندل جدید...");

      // اگر بازار تعطیل است و در حالت تستر نیستیم
      if(!g_isTester && IsMarketClosed())
      {
         if(m_currentState != RANGE_WAITING)
         {
            Cleanup();
         }
         return;
      }

      switch(m_currentState)
      {
         case RANGE_WAITING:
            IdentifyAndValidateRange();
            break;
         case RANGE_IDENTIFIED:
            PlacePendingOrders();
            break;
         case ORDERS_PLACED:
           if(FindActivePosition()) // اگر پوزیشن فعال پیدا شد
      {
         m_currentState = TRADE_ACTIVE; // تغییر حالت
         ManageActiveTrade(); // اولین اجرای مدیریت
      }
           
            if(TimeTradeServer() >= m_cleanupTime)
            {
               Cleanup();
            }
            break;
         case TRADE_ACTIVE:
            ManageActiveTrade();
            if(TimeTradeServer() >= m_cleanupTime)
            {
               Cleanup();
            }
            break;
         case RANGE_EXPIRED:
            Cleanup();
            break;
      }
   }

   // لغو سفارش مخالف (OCO)
   void CancelOppositeOrder(ulong position_ticket) 
{
   if(InpDebugMode) Print("لغو سفارش مخالف برای رنج ", m_rangeIndex, "...");

   // به جای m_activeTicket از ورودی تابع استفاده می‌کنیم
   if(!PositionSelectByTicket(position_ticket)) 
   {
      if(InpDebugMode) Print("پوزیشن با تیکت ", position_ticket, " یافت نشد.");
      return;
   }
      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      CTrade trade;

      for(int i = OrdersTotal() - 1; i >= 0; i--)
      {
         ulong ticket = OrderGetTicket(i);
         if(OrderSelect(ticket) && OrderGetInteger(ORDER_MAGIC) == m_magicNumber)
         {
            ENUM_ORDER_TYPE orderType = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
            if((posType == POSITION_TYPE_BUY && orderType == ORDER_TYPE_SELL_STOP) ||
               (posType == POSITION_TYPE_SELL && orderType == ORDER_TYPE_BUY_STOP))
            {
               if(trade.OrderDelete(ticket))
               {
                  if(InpDebugMode) Print("سفارش مخالف با تیکت ", ticket, " حذف شد.");
               }
            }
         }
      }
   }

private:
   // شناسایی و اعتبارسنجی رنج
   void IdentifyAndValidateRange()
   {
      if(InpDebugMode) Print("شناسایی رنج ", m_rangeIndex, "...");

      // محاسبه زمان شروع و پایان
      if(!CTimeHelper::CalculateRangeTimes(m_startHour, m_startMinute, m_endHour, m_endMinute, m_startTime, m_endTime))
      {
         Print("خطا در محاسبه زمان‌های رنج ", m_rangeIndex);
         return;
      }

      // چک پایان یافتن زمان رنج
      if(TimeTradeServer() < m_endTime)
      {
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " هنوز به پایان نرسیده است.");
         return;
      }

      // محاسبه تعداد کندل‌های رنج
      int barCount = (int)((m_endTime - m_startTime) / (PeriodSeconds(m_timeframe)));
      if(barCount <= 0)
      {
         Print("خطا: تعداد کندل‌های رنج ", m_rangeIndex, " صفر یا منفی است.");
         return;
      }

      // شناسایی سقف و کف
      int highest = iHighest(_Symbol, m_timeframe, MODE_HIGH, barCount, 0);
      int lowest = iLowest(_Symbol, m_timeframe, MODE_LOW, barCount, 0);
      if(highest == -1 || lowest == -1)
      {
         Print("خطا در شناسایی سقف/کف برای رنج ", m_rangeIndex);
         return;
      }

      m_rangeHigh = iHigh(_Symbol, m_timeframe, highest);
      m_rangeLow = iLow(_Symbol, m_timeframe, lowest);
      double rangePoints = (m_rangeHigh - m_rangeLow) / _Point;

      // اعتبارسنجی رنج
      if(rangePoints < m_minRangePoints || rangePoints > m_maxRangePoints)
      {
         if(InpDebugMode) Print("رنج ", m_rangeIndex, " نامعتبر است. ارتفاع=", rangePoints, " پوینت");
         m_currentState = RANGE_EXPIRED;
         return;
      }

      // رسم مستطیل گرافیکی
      ObjectDelete(0, m_rangeObjectName);
      if(ObjectCreate(0, m_rangeObjectName, OBJ_RECTANGLE, 0, m_startTime, m_rangeHigh, m_endTime, m_rangeLow))
      {
         ObjectSetInteger(0, m_rangeObjectName, OBJPROP_COLOR, m_color);
         ObjectSetInteger(0, m_rangeObjectName, OBJPROP_STYLE, STYLE_SOLID);
         ObjectSetInteger(0, m_rangeObjectName, OBJPROP_WIDTH, 1);
         ObjectSetInteger(0, m_rangeObjectName, OBJPROP_FILL, true);
         if(InpDebugMode) Print("مستطیل رنج ", m_rangeIndex, " رسم شد.");
      }

      // آپدیت کش ایچیموکو
      if(m_ichimokuEnabled)
      {
         m_cachedIchimokuDirection = CheckIchimokuFilter();
         if(InpDebugMode) Print("فیلتر ایچیموکو رنج ", m_rangeIndex, ": ", EnumToString(m_cachedIchimokuDirection));
      }
      else
      {
         m_cachedIchimokuDirection = FILTER_BOTH;
      }

      m_currentState = RANGE_IDENTIFIED;
      if(InpDebugMode) Print("رنج ", m_rangeIndex, " شناسایی شد. ارتفاع=", rangePoints, " پوینت");
   }

   // ثبت سفارش‌های پندینگ
   void PlacePendingOrders()
   {
      if(InpDebugMode) Print("ثبت سفارش‌های پندینگ برای رنج ", m_rangeIndex, "...");

      // محاسبه زمان پاکسازی
      m_cleanupTime = CTimeHelper::CalculateCleanupTime(m_endHour, m_endMinute, m_cleanupHours);
      
      // محاسبه فاصله سفارش‌ها
      double offset;
      if(m_placementMode == PLACEMENT_ATR)
      {
         offset = GetCachedATR() * m_atrMultiplier;
      }
      else // PLACEMENT_PERCENT
      {
         offset = (m_rangeHigh - m_rangeLow) * m_atrMultiplier / 100.0;
      }

      // محاسبه استاپ لاس
      double slDistance;
      if(m_slMode == SL_ATR)
      {
         slDistance = GetCachedATR() * m_slAtrMultiplier;
      }
      else // SL_PERCENT
      {
         slDistance = (m_rangeHigh - m_rangeLow) * m_slAtrMultiplier / 100.0;
      }

      // محاسبه قیمت‌های سفارش
      double buyStopPrice = NormalizeDouble(m_rangeHigh + offset, _Digits);
      double sellStopPrice = NormalizeDouble(m_rangeLow - offset, _Digits);
      double buySL = NormalizeDouble(sellStopPrice - slDistance, _Digits); // SL جدید بر اساس sellStopPrice
      double sellSL = NormalizeDouble(buyStopPrice + slDistance, _Digits); // SL جدید بر اساس buyStopPrice

      // محاسبه حجم
      double slPoints = MathMax((buyStopPrice - buySL) / _Point, (sellSL - sellStopPrice) / _Point);
      double lotSize = CRiskManager::CalculateLotSize(InpRiskPercent, slPoints);
      if(lotSize == 0)
      {
         Print("خطا در محاسبه حجم برای رنج ", m_rangeIndex);
         m_currentState = RANGE_EXPIRED;
         return;
      }

      // گرفتن جهت فیلتر
      ENUM_FILTER_DIRECTION direction = GetFilterDirection();

      CTrade trade;
      trade.SetExpertMagicNumber(m_magicNumber);

      // ثبت Buy Stop اگر مجاز باشد
      if(direction == FILTER_BUY || direction == FILTER_BOTH)
      {
         if(trade.BuyStop(lotSize, buyStopPrice, _Symbol, buySL, 0, ORDER_TIME_SPECIFIED, m_cleanupTime))
         {
            if(InpDebugMode) Print("سفارش Buy Stop برای رنج ", m_rangeIndex, " ثبت شد. قیمت=", buyStopPrice, ", SL=", buySL);
         }
         else
         {
            Print("خطا در ثبت Buy Stop برای رنج ", m_rangeIndex, ": ", trade.ResultRetcode());
            m_currentState = RANGE_EXPIRED;
            return;
         }
      }
      else
      {
         if(InpDebugMode) Print("رنج ", m_rangeIndex, ": Buy Stop ثبت نشد به دلیل فیلتر ایچیموکو.");
      }

      // ثبت Sell Stop اگر مجاز باشد
      if(direction == FILTER_SELL || direction == FILTER_BOTH)
      {
         if(trade.SellStop(lotSize, sellStopPrice, _Symbol, sellSL, 0, ORDER_TIME_SPECIFIED, m_cleanupTime))
         {
            if(InpDebugMode) Print("سفارش Sell Stop برای رنج ", m_rangeIndex, " ثبت شد. قیمت=", sellStopPrice, ", SL=", sellSL);
         }
         else
         {
            Print("خطا در ثبت Sell Stop برای رنج ", m_rangeIndex, ": ", trade.ResultRetcode());
            m_currentState = RANGE_EXPIRED;
            return;
         }
      }
      else
      {
         if(InpDebugMode) Print("رنج ", m_rangeIndex, ": Sell Stop ثبت نشد به دلیل فیلتر ایچیموکو.");
      }

      m_currentState = ORDERS_PLACED;
      if(InpDebugMode) Print("رنج ", m_rangeIndex, ": سفارش‌های پندینگ ثبت شدند. تغییر حالت به ORDERS_PLACED.");
   }

   // مدیریت معامله باز
   void ManageActiveTrade()
   {
      if(InpDebugMode) Print("مدیریت معامله باز برای رنج ", m_rangeIndex, "...");

      if(!PositionSelectByTicket(m_activeTicket))
      {
         if(InpDebugMode) Print("پوزیشن با تیکت ", m_activeTicket, " یافت نشد. احتمال بسته شدن.");
         m_currentState = RANGE_EXPIRED;
         return;
      }

      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double currentPrice = posType == POSITION_TYPE_BUY ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double sl = PositionGetDouble(POSITION_SL);

      // محاسبه فاصله استاپ لاس
      double slDistance;
      if(m_slMode == SL_ATR)
      {
         slDistance = GetCachedATR() * m_slAtrMultiplier;
      }
      else
      {
         slDistance = (m_rangeHigh - m_rangeLow) * m_slAtrMultiplier / 100.0;
      }

      // چک خروج پله‌ای
      double targetProfit = slDistance * m_rrRatio;
      if((posType == POSITION_TYPE_BUY && currentPrice >= openPrice + targetProfit) ||
         (posType == POSITION_TYPE_SELL && currentPrice <= openPrice - targetProfit))
      {
         double volume = PositionGetDouble(POSITION_VOLUME);
         double partialVolume = NormalizeDouble(volume * m_partialClosePercent / 100.0, 2);
         if(partialVolume >= g_volumeMin)
         {
            if(CTradeManager::PartialClose(m_activeTicket, partialVolume))
            {
               if(InpDebugMode) Print("بخشی از پوزیشن رنج ", m_rangeIndex, " بسته شد. حجم=", partialVolume);
            }
         }
      }

      // انتقال به نقطه ورود (ریسک‌فری)
      if(!m_trailingActivated)
      {
         if((posType == POSITION_TYPE_BUY && currentPrice >= openPrice + slDistance) ||
            (posType == POSITION_TYPE_SELL && currentPrice <= openPrice - slDistance))
         {
            if(CTradeManager::MoveSLToBreakEven(m_activeTicket, openPrice))
            {
               m_trailingActivated = true;
               if(InpDebugMode) Print("پوزیشن رنج ", m_rangeIndex, " به نقطه ورود منتقل شد.");
            }
         }
      }

      // اعمال تریلینگ استاپ
      if(m_trailingActivated)
      {
         CTradeManager::TrailingStop(m_activeTicket, m_trailingMode, m_trailingAtrPeriod, m_trailingAtrMultiplier, m_timeframe, m_atrHandle);
      }
   }

   // پاکسازی
   void Cleanup()
   {
      if(InpDebugMode) Print("پاکسازی رنج ", m_rangeIndex, "...");

      // بستن پوزیشن باز
      if(m_activeTicket != 0 && PositionSelectByTicket(m_activeTicket))
      {
         if(CTradeManager::ClosePosition(m_activeTicket))
         {
            if(InpDebugMode) Print("پوزیشن با تیکت ", m_activeTicket, " برای رنج ", m_rangeIndex, " بسته شد.");
         }
      }

      // حذف سفارش‌های پندینگ
      for(int i = OrdersTotal() - 1; i >= 0; i--)
      {
         ulong ticket = OrderGetTicket(i);
         if(OrderSelect(ticket) && OrderGetInteger(ORDER_MAGIC) == m_magicNumber)
         {
            CTrade trade;
            if(trade.OrderDelete(ticket))
            {
               if(InpDebugMode) Print("سفارش پندینگ با تیکت ", ticket, " برای رنج ", m_rangeIndex, " حذف شد.");
            }
         }
      }

      // حذف مستطیل گرافیکی
      ObjectDelete(0, m_rangeObjectName);
      if(InpDebugMode) Print("مستطیل رنج ", m_rangeIndex, " حذف شد.");

      // ریست حالت
      m_currentState = RANGE_WAITING;
      m_rangeHigh = 0;
      m_rangeLow = 0;
      m_startTime = 0;
      m_endTime = 0;
      m_cleanupTime = 0;
      m_trailingActivated = false;
      m_activeTicket = 0;
      m_cachedATR = 0;
      m_cachedIchimokuDirection = FILTER_BOTH;
      if(InpDebugMode) Print("رنج ", m_rangeIndex, " برای روز بعد ریست شد. تغییر حالت به WAITING.");
   }

   // بررسی تعطیلی بازار دقیق‌تر
   bool IsMarketClosed()
   {
      datetime from = 0, to = 0;
      MqlDateTime dt;
      TimeToStruct(TimeTradeServer(), dt);
      ENUM_DAY_OF_WEEK day = (ENUM_DAY_OF_WEEK)dt.day_of_week;
      if(!SymbolInfoSessionTrade(_Symbol, day, 0, from, to))
      {
         int err = GetLastError();
         if(InpDebugMode) Print("خطا در SymbolInfoSessionTrade برای رنج ", m_rangeIndex, ": ", err);
         return true;
      }
      if(TimeTradeServer() < from || TimeTradeServer() > to)
      {
         return true;
      }

      // چک weekend ساده
      MqlDateTime serverTime;
      TimeToStruct(TimeTradeServer(), serverTime);
      if(serverTime.day_of_week == 6 || serverTime.day_of_week == 0)
      {
         if(InpDebugMode) Print("بازار تعطیل است برای رنج ", m_rangeIndex);
         return true;
      }
      return false;
   }

   // گرفتن ATR کش‌شده
   double GetCachedATR()
   {
      if(m_cachedATR <= 0)
      {
         double atr[];
         ArraySetAsSeries(atr, true);
         if(CopyBuffer(m_atrHandle, 0, 0, 1, atr) <= 0)
         {
            Print("خطا در گرفتن ATR برای رنج ", m_rangeIndex, ": ", GetLastError());
            return 0;
         }
         m_cachedATR = atr[0];
      }
      return m_cachedATR;
   }

   // محاسبه فیلتر ایچیموکو
   ENUM_FILTER_DIRECTION CheckIchimokuFilter()
   {
      if(InpDebugMode) Print("محاسبه فیلتر ایچیموکو برای رنج ", m_rangeIndex, "...");

   int tenkanHigh_shifted = iHighest(_Symbol, m_timeframe, MODE_HIGH, m_tenkanPeriod, m_shift);
      int tenkanLow_shifted = iLowest(_Symbol, m_timeframe, MODE_LOW, m_tenkanPeriod, m_shift);
      // ... چک کردن tenkanHigh_shifted و tenkanLow_shifted برای خطا ...
      double tenkan_shifted = (iHigh(_Symbol, m_timeframe, tenkanHigh_shifted) + iLow(_Symbol, m_timeframe, tenkanLow_shifted)) / 2.0;
      
      // محاسبه کیجون‌سن برای m_shift کندل قبل
      int kijunHigh_shifted = iHighest(_Symbol, m_timeframe, MODE_HIGH, m_kijunPeriod, m_shift);
      int kijunLow_shifted = iLowest(_Symbol, m_timeframe, MODE_LOW, m_kijunPeriod, m_shift);
      // ... چک کردن kijunHigh_shifted و kijunLow_shifted برای خطا ...
      double kijun_shifted = (iHigh(_Symbol, m_timeframe, kijunHigh_shifted) + iLow(_Symbol, m_timeframe, kijunLow_shifted)) / 2.0;
      
      // محاسبه سنکو اسپن A (شیفت‌شده به آینده)
      double senkouA = (tenkan_shifted + kijun_shifted) / 2.0; 
      // محاسبه سنکو اسپن B
      int senkouHigh = iHighest(_Symbol, m_timeframe, MODE_HIGH, m_senkouPeriod, m_shift);
      int senkouLow = iLowest(_Symbol, m_timeframe, MODE_LOW, m_senkouPeriod, m_shift);
      if(senkouHigh == -1 || senkouLow == -1)
      {
         Print("خطا در محاسبه سنکو اسپن B برای رنج ", m_rangeIndex, ". داده کافی نیست.");
         return FILTER_BOTH;
      }
      double senkouB = (iHigh(_Symbol, m_timeframe, senkouHigh) + iLow(_Symbol, m_timeframe, senkouLow)) / 2.0;

      // مقایسه سنکو A و B
      if(senkouA > senkouB)
      {
         return FILTER_BUY;
      }
      else if(senkouA < senkouB)
      {
         return FILTER_SELL;
      }
      else
      {
         return FILTER_BOTH; // حالت فلت مثل فیلتر خاموش
      }
   }

   // تابع مجازی برای گرفتن جهت فیلتر (برای انعطاف در آینده)
   virtual ENUM_FILTER_DIRECTION GetFilterDirection()
   {
      if(m_ichimokuEnabled)
      {
         return m_cachedIchimokuDirection;
      }
      return FILTER_BOTH;
   }
   
   bool FindActivePosition()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         if(PositionGetInteger(POSITION_MAGIC) == m_magicNumber && PositionGetString(POSITION_SYMBOL) == _Symbol)
         {
            m_activeTicket = ticket; // تیکت رو ذخیره می‌کنیم
            if(InpDebugMode) Print("پوزیشن فعال برای رنج ", m_rangeIndex, " با تیکت ", m_activeTicket, " پیدا شد.");
            return true;
         }
      }
   }
   return false;
}

};

#endif







//+------------------------------------------------------------------+
//|                        TradeManager.mqh                          |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این کتابخانه شامل توابع مدیریت معاملات است. وظایف اصلی:
// 1. PartialClose: بستن بخشی از پوزیشن با نرمالایز حجم و چک min/max.
// 2. MoveSLToBreakEven: انتقال استاپ لاس به نقطه ورود (ریسک‌فری).
// 3. TrailingStop: اعمال تریلینگ استاپ با حالت ATR یا ساده، با چک sl != 0.
// 4. ClosePosition: بستن کامل پوزیشن.
// توابع با تیکت پوزیشن کار می‌کنند تا از تداخل جلوگیری شود.
// تمام عملیات با نرمال‌سازی و بررسی خطا انجام می‌شوند.
// بهینه‌سازی: استفاده از CTrade، لاگ conditional با InpDebugMode.
// اصلاحات: چک حجم در PartialClose، چک sl در TrailingStop.
// تغییرات نسخه 1.50: به‌روزرسانی MoveSLToBreakEven برای اضافه کردن اسپرد و کمیسیون به SL جدید (با DEAL_COMMISSION به جای POSITION_COMMISSION).
// این کامنت بخشی از سند کلی است: توصیف توابع مدیریت معاملات برای ادغام با CRange.

#ifndef TRADE_MANAGER_MQH
#define TRADE_MANAGER_MQH

#include <Trade\Trade.mqh>

extern double g_tickSize; // از اصلی

class CTradeManager
{
public:
   // بستن بخشی از پوزیشن
   static bool PartialClose(ulong ticket, double volume)
   {
      if(InpDebugMode) Print("تلاش برای بستن بخشی از پوزیشن با تیکت ", ticket, ", حجم=", volume);

      if(!PositionSelectByTicket(ticket))
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد.");
         return false;
      }

      CTrade trade;
      if(trade.PositionClosePartial(ticket, volume))
      {
         if(InpDebugMode) Print("بخشی از پوزیشن با تیکت ", ticket, " بسته شد.");
         return true;
      }
      else
      {
         Print("خطا در بستن بخشی از پوزیشن با تیکت ", ticket, ": ", trade.ResultRetcode());
         return false;
      }
   }

   // انتقال استاپ لاس به نقطه ورود با اسپرد/کمیسیون (نسخه 1.50)
   static bool MoveSLToBreakEven(ulong ticket, double breakEvenPrice)
   {
      if(InpDebugMode) Print("تلاش برای انتقال استاپ لاس پوزیشن ", ticket, " به نقطه ورود=", breakEvenPrice);

      if(!PositionSelectByTicket(ticket))
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد.");
         return false;
      }

      // محاسبه اسپرد و کمیسیون (نسخه 1.50)
      double spread = SymbolInfoDouble(_Symbol, SYMBOL_ASK) - SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double commission = 0.0;

      // گرفتن کمیسیون از تاریخچه معاملات
      if(HistorySelectByPosition(PositionGetInteger(POSITION_IDENTIFIER)))
      {
         for(int i = HistoryDealsTotal() - 1; i >= 0; i--)
         {
            ulong dealTicket = HistoryDealGetTicket(i);
            if(HistoryDealSelect(dealTicket))
            {
               if(HistoryDealGetInteger(dealTicket, DEAL_ENTRY) == DEAL_ENTRY_IN &&
                  HistoryDealGetInteger(dealTicket, DEAL_POSITION_ID) == PositionGetInteger(POSITION_IDENTIFIER))
               {
                  commission = HistoryDealGetDouble(dealTicket, DEAL_COMMISSION);
                  commission = MathAbs(commission) / PositionGetDouble(POSITION_VOLUME); // کمیسیون به ازای هر واحد حجم
                  break;
               }
            }
         }
      }
      else
      {
         if(InpDebugMode) Print("هشدار: نتوانست تاریخچه معاملات را برای پوزیشن ", ticket, " لود کند. کمیسیون=0 فرض شد.");
      }

      double adjustment = spread + commission;

      double newSL = breakEvenPrice;
      if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
      {
         newSL += adjustment; // برای Buy، SL بالاتر برای پوشش
      }
      else
      {
         newSL -= adjustment; // برای Sell، SL پایین‌تر
      }

      newSL = NormalizeDouble(newSL, _Digits);

      // چک اگر SL جدید بهتر باشد
      double currentSL = PositionGetDouble(POSITION_SL);
      bool shouldModify = (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY && newSL > currentSL) ||
                          (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL && newSL < currentSL);

      if(!shouldModify)
      {
         if(InpDebugMode) Print("SL جدید بهتر نیست، skip شد برای پوزیشن ", ticket);
         return true; // بدون تغییر
      }

      CTrade trade;
      if(trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP)))
      {
         if(InpDebugMode) Print("استاپ لاس پوزیشن ", ticket, " به ", newSL, " منتقل شد با spread=", spread, " و commission=", commission);
         return true;
      }
      else
      {
         Print("خطا در انتقال استاپ لاس پوزیشن ", ticket, ": ", trade.ResultRetcode());
         return false;
      }
   }

   // اعمال تریلینگ استاپ (با هندل ATR shared)
   static bool TrailingStop(ulong ticket, ENUM_TRAILING_MODE mode, int atrPeriod, double atrMultiplier, ENUM_TIMEFRAMES timeframe, int atrHandle)
   {
      if(InpDebugMode) Print("اعمال تریلینگ استاپ برای پوزیشن ", ticket, "...");

      if(!PositionSelectByTicket(ticket))
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد.");
         return false;
      }

      double sl = PositionGetDouble(POSITION_SL);
      if(sl == 0)
      {
         Print("هشدار: SL اولیه صفر است برای پوزیشن ", ticket, ". تریلینگ skip شد.");
         return false;
      }

      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      double currentPrice = posType == POSITION_TYPE_BUY ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);

      double trailingDistance;
      if(mode == TRAILING_ATR)
      {
         double atr[];
         ArraySetAsSeries(atr, true);
         if(CopyBuffer(atrHandle, 0, 0, 1, atr) <= 0)
         {
            Print("خطا در گرفتن ATR برای تریلینگ: ", GetLastError());
            return false;
         }
         trailingDistance = atr[0] * atrMultiplier;
      }
      else // TRAILING_SIMPLE
      {
         trailingDistance = atrMultiplier * g_tickSize; // فاصله ثابت با tickSize
      }

      double newSL;
      if(posType == POSITION_TYPE_BUY)
      {
         newSL = NormalizeDouble(currentPrice - trailingDistance, _Digits);
         if(newSL > sl)
         {
            CTrade trade;
            if(trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP)))
            {
               if(InpDebugMode) Print("تریلینگ استاپ برای پوزیشن ", ticket, " به‌روزرسانی شد. SL جدید=", newSL);
               return true;
            }
            else
            {
               Print("خطا در به‌روزرسانی تریلینگ استاپ برای پوزیشن ", ticket, ": ", trade.ResultRetcode());
               return false;
            }
         }
      }
      else // POSITION_TYPE_SELL
      {
         newSL = NormalizeDouble(currentPrice + trailingDistance, _Digits);
         if(newSL < sl)
         {
            CTrade trade;
            if(trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP)))
            {
               if(InpDebugMode) Print("تریلینگ استاپ برای پوزیشن ", ticket, " به‌روزرسانی شد. SL جدید=", newSL);
               return true;
            }
            else
            {
               Print("خطا در به‌روزرسانی تریلینگ استاپ برای پوزیشن ", ticket, ": ", trade.ResultRetcode());
               return false;
            }
         }
      }

      return true; // اگر نیازی به تغییر نبود
   }

   // بستن کامل پوزیشن
   static bool ClosePosition(ulong ticket)
   {
      if(InpDebugMode) Print("تلاش برای بستن کامل پوزیشن با تیکت ", ticket);

      if(!PositionSelectByTicket(ticket))
      {
         Print("خطا: پوزیشن با تیکت ", ticket, " یافت نشد.");
         return false;
      }

      CTrade trade;
      if(trade.PositionClose(ticket))
      {
         if(InpDebugMode) Print("پوزیشن با تیکت ", ticket, " بسته شد.");
         return true;
      }
      else
      {
         Print("خطا در بستن پوزیشن با تیکت ", ticket, ": ", trade.ResultRetcode());
         return false;
      }
   }
};

#endif


//+------------------------------------------------------------------+
//|                        RiskManager.mqh                           |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این کتابخانه مسئول مدیریت ریسک و محاسبه حجم معاملات است.
// وظیفه اصلی:
// - CalculateLotSize: محاسبه حجم (LotSize) بر اساس درصد ریسک و فاصله استاپ لاس.
// الگوریتم کلی:
// - فرمول: LotSize = (RiskPercent * AccountBalance) / (SL_Distance * TickValue)
// - حجم با MathRound و گام‌بندی نرمالایز می‌شود تا با قوانین بروکر سازگار باشد.
// - چک min/max برای جلوگیری از حجم نامعتبر.
// بهینه‌سازی: استفاده از کش جهانی برای tickValue و غیره.
// اصلاحات: تغییر MathFloor به MathRound برای دقت بهتر.
// این کامنت بخشی از سند کلی است: توصیف مدیریت ریسک برای ادغام با CRange در محاسبه حجم.

#ifndef RISK_MANAGER_MQH
#define RISK_MANAGER_MQH

extern double g_tickValue;
extern double g_tickSize;
extern double g_volumeStep;
extern double g_volumeMin;
extern double g_volumeMax;

class CRiskManager
{
public:
   // محاسبه حجم معامله
   static double CalculateLotSize(double riskPercent, double slPoints)
   {
      if(InpDebugMode) Print("محاسبه حجم معامله با ریسک ", riskPercent, "% و فاصله استاپ لاس ", slPoints, " پوینت...");

      // گرفتن اطلاعات حساب
      double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
      
      // تبدیل فاصله به ارزش
      if(g_tickSize == 0)
      {
         Print("خطا: tickSize صفر است.");
         return 0;
      }
      double slValue = slPoints * g_tickValue;
      
      // محاسبه حجم
      double lotSize = (riskPercent / 100.0 * accountBalance) / slValue;
      
      // نرمال‌سازی حجم با MathRound
      lotSize = MathRound(lotSize / g_volumeStep) * g_volumeStep;
      lotSize = MathMax(g_volumeMin, MathMin(g_volumeMax, lotSize));
      
      if(lotSize < g_volumeMin)
      {
         Print("خطا: حجم محاسبه شده کمتر از حداقل است.");
         return 0;
      }
      
      if(InpDebugMode) Print("حجم محاسبه شده برای معامله: ", lotSize);
      return lotSize;
   }
};

#endif








//+------------------------------------------------------------------+
//|                        TimeHelper.mqh                            |
//|                        Copyright 2025, Hipoalgorithm Team        |
//|                                                                  |
//+------------------------------------------------------------------+
// توضیح روان و کامل:
// این کتابخانه شامل توابع کمکی برای مدیریت زمان است.
// وظایف اصلی:
// 1. CalculateRangeTimes: محاسبه زمان شروع و پایان رنج با مدیریت عبور از نیمه‌شب و skip تعطیلات.
// 2. CalculateCleanupTime: محاسبه زمان انقضا با اضافه ساعت‌ها و skip تعطیلات.
// 3. IsNonTradingDay: چک روز غیرمعاملاتی با day_of_week و SymbolInfoSessionTrade.
// الگوریتم کلی:
// - زمان‌ها به datetime تبدیل می‌شوند.
// - اگر پایان قبل از شروع باشد، روز بعد اضافه می‌شود.
// - برای تعطیلات، زمان به روز معاملاتی قبل/بعد skip می‌شود.
// بهینه‌سازی: مدیریت دقیق weekend و sessionها.
// اصلاحات: استفاده از ENUM_DAY_OF_WEEK درست.
// این کامنت بخشی از سند کلی است: توصیف مدیریت زمان برای ادغام با CRange در شناسایی رنج و پاکسازی.

#ifndef TIME_HELPER_MQH
#define TIME_HELPER_MQH


class CTimeHelper
{
public:
   // محاسبه زمان شروع و پایان رنج
   static bool CalculateRangeTimes(int startHour, int startMinute, int endHour, int endMinute, datetime &startTime, datetime &endTime)
   {
      if(InpDebugMode) Print("محاسبه زمان شروع و پایان رنج...");

      // گرفتن زمان سرور
      datetime serverTime = TimeTradeServer();
      MqlDateTime dt;
      TimeToStruct(serverTime, dt);

      // تنظیم زمان شروع
      dt.hour = startHour;
      dt.min = startMinute;
      dt.sec = 0;
      startTime = StructToTime(dt);

      // تنظیم زمان پایان
      dt.hour = endHour;
      dt.min = endMinute;
      dt.sec = 0;
      endTime = StructToTime(dt);

      // اگر پایان قبل از شروع باشد, روز بعد
      if(endTime <= startTime)
      {
         endTime += 86400; // اضافه کردن یک روز
      }

      // اگر زمان شروع در آینده باشد, به روز قبل
      if(startTime > serverTime)
      {
         startTime -= 86400;
         endTime -= 86400;
      }

      // چک و skip تعطیلات (اگر در تعطیلی باشد, به روز معاملاتی قبل)
      while(IsNonTradingDay(startTime))
      {
         startTime -= 86400;
         endTime -= 86400;
      }

      if(InpDebugMode) Print("زمان شروع رنج: ", TimeToString(startTime), ", زمان پایان: ", TimeToString(endTime));
      return true;
   }

   // محاسبه زمان پاکسازی
   static datetime CalculateCleanupTime(int endHour, int endMinute, int cleanupHours)
   {
      if(InpDebugMode) Print("محاسبه زمان پاکسازی...");

      MqlDateTime dt;
      TimeToStruct(TimeTradeServer(), dt);
      dt.hour = endHour;
      dt.min = endMinute;
      dt.sec = 0;
      datetime endTime = StructToTime(dt);

      // اگر پایان قبل از زمان فعلی باشد, روز بعد
      if(endTime < TimeTradeServer())
      {
         endTime += 86400;
      }

      // skip تعطیلات برای endTime
      while(IsNonTradingDay(endTime))
      {
         endTime += 86400;
      }

      // اضافه کردن ساعت‌های پاکسازی
      datetime cleanupTime = endTime + cleanupHours * 3600;
      if(InpDebugMode) Print("زمان پاکسازی: ", TimeToString(cleanupTime));
      return cleanupTime;
   }

private:
   // چک روز غیرمعاملاتی
   static bool IsNonTradingDay(datetime time)
   {
      MqlDateTime dt;
      TimeToStruct(time, dt);
      if(dt.day_of_week == 0 || dt.day_of_week == 6)
      {
         return true;
      }
      // چک session (اگر هیچ session نباشد)
      datetime from = 0, to = 0;
      if(!SymbolInfoSessionTrade(_Symbol, (ENUM_DAY_OF_WEEK)dt.day_of_week, 0, from, to))
      {
         return true;
      }
      return false;
   }
};

#endif
